/*******************************************************************************
 * Copyright (c) 2023 Microsoft Research. All rights reserved. 
 *
 * The MIT License (MIT)
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy 
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software. 
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * Contributors:
 *   Markus Alexander Kuppe - initial API and implementation
 ******************************************************************************/
package tlc2.util.statistics;

import tlc2.tool.TLCState;
import tlc2.tool.fp.MemFPSet;
import tlc2.util.FP64;
import tlc2.value.IValue;

// https://en.wikipedia.org/wiki/Count-distinct_problem
public interface CountDistinct {
	
	public void add(final IValue v);
	
	public void add(final TLCState o);
	
	public void add(final long hash);

	public long count();

	public class Noop implements CountDistinct {
		
		@Override
		public void add(final IValue v) {
		}
		
		@Override
		public void add(final TLCState s) {
		}

		@Override
		public void add(final long x) {
		}

		@Override
		public long count() {
			return -1;
		}
	}

	// https://en.wikipedia.org/wiki/Count-distinct_problem#Naive_solution
	public class Naive implements CountDistinct {

		private final MemFPSet fpSet = MemFPSet.NewMemFPSetUnchecked();
		
		@Override
		public void add(final IValue v) {
			fpSet.put(v.fingerPrint(FP64.New()));
		}
		
		@Override
		public void add(TLCState s) {
			fpSet.put(s.fingerPrint());
		}

		@Override
		public void add(long hash) {
			fpSet.put(hash);
		}

		@Override
		public long count() {
			return fpSet.size();
		}
	}

	// https://en.wikipedia.org/wiki/HyperLogLog	
	// Generated by Github Copilot (TODOs are mine)
	public class HyperLogLog implements CountDistinct {
		protected final int m; // number of registers
		protected final int b; // number of bits per register
		protected final int[] M; // registers

		public HyperLogLog(int b) {
			// TODO Assert that b <= 31
			this.b = b;
			this.m = 1 << b;
			this.M = new int[m];
		}
		
		@Override
		public void add(final IValue v) {
			add(v.fingerPrint(FP64.New()));
		}

		@Override
		public void add(final TLCState s) {
			add(s.fingerPrint());
		}

		public void add(long x) {
			int j = (int) (x >>> (64 - b));
			int w = Long.numberOfLeadingZeros((x << b) | (1L << (b - 1))) + 1;
			M[j] = Math.max(M[j], w);
		}

		public long count() {
			double alpha = getAlpha();
			double z = 0;
			for (int i = 0; i < m; i++) {
				z += 1.0 / (1 << M[i]);
			}
			double estimate = alpha * m * m / z;
			if (estimate <= 2.5 * m) {
				int v = 0;
				for (int i = 0; i < m; i++) {
					if (M[i] == 0) {
						v++;
					}
				}
				if (v != 0) {
					estimate = m * Math.log((double) m / v);
				}
			} else if (estimate > 1.0 / 30.0 * Math.pow(2, 64)) {
				estimate = -Math.pow(2, 64) * Math.log(1 - estimate / Math.pow(2, 64));
			}
			return (int) estimate;
		}

		private double getAlpha() {
			switch (m) {
			case 16:
				return 0.673;
			case 32:
				return 0.697;
			case 64:
				return 0.709;
			default:
				return 0.7213 / (1 + 1.079 / m);
			}
		}
	}

	public class SyncedHyperLogLog extends HyperLogLog {

		public SyncedHyperLogLog(int b) {
			super(b);
		}

		public void add(long x) {
			final int j = (int) (x >>> (64 - b));
			final int w = Long.numberOfLeadingZeros((x << b) | (1L << (b - 1))) + 1;
			synchronized (this) {
				M[j] = Math.max(M[j], w);
			}
		}

		public synchronized long count() {
			return super.count();
		}
	}
}
