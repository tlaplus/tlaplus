package tlc2.output;

import java.io.File;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.concurrent.atomic.AtomicLong;
import java.util.regex.Pattern;

import tla2sany.modanalyzer.SpecObj;
import tla2sany.semantic.OpDefNode;
import tlc2.model.Assignment;
import tlc2.model.Formula;
import util.StringHelper;
import util.TLAConstants;

/**
 * There were a lot of utility methods in the toolbox's ModelWriter class that made what statefulness of that class which
 * existed, obscured. I broke out the utility methods into their own class on migration and clean-up.
 */
public final class SpecWriterUtilities {
	/*
     * Constants used for displaying modification history.
     * It has the syntax:
     *   modificationHistory +
     *   (lastModified + date + modifiedBy +
     *      username + newline)*
     *      
     * Note: The StringHelper.newline string wasn't being found on my 64-bit
     * Windows 7 machine.  So on 8 Dec 2010 I removed it from here, and added
     * a "\n" before it when writing a new file.
     */
    public static String MODIFICATION_HISTORY = /* StringHelper.PLATFORM_NEWLINE + */ "\\* Modification History";
    public static String LAST_MODIFIED = StringHelper.PLATFORM_NEWLINE + "\\* Last modified ";
    public static String MODIFIED_BY = " by ";

    /**
     * @param rightMarginWidth the margin width of the output
     * @param addModificationHistory whether to add the modification history
     * @return the content for the end of the module
     */
	public static StringBuilder getModuleClosingTag(final int rightMarginWidth, final boolean addModificationHistory) {
        final StringBuilder buffer = new StringBuilder();
        buffer.append(StringHelper.copyString("=", rightMarginWidth)).append(StringHelper.PLATFORM_NEWLINE);

        if (addModificationHistory) {
            buffer.append(MODIFICATION_HISTORY).append(StringHelper.PLATFORM_NEWLINE)
                .append("\\* Created ").append(new Date()).append(MODIFIED_BY)
                .append(System.getProperty("user.name")).append(StringHelper.PLATFORM_NEWLINE);
        }
        return buffer;
    }

	/**
	 * @return the content for the end of the module
	 */
	public static StringBuilder getGeneratedTimeStampCommentLine() {
		final StringBuilder buffer = new StringBuilder();
		buffer.append(TLAConstants.GENERATION_TIMESTAMP_PREFIX).append(new Date());
		return buffer;
	}

    /**
     * A pattern to match IDs generated by the {@link AbstractSpecWriter#getValidIdentifier(String)} method
     */
    public static final Pattern ID_MATCHER
    	= Pattern.compile("(" + TLAConstants.Schemes.SPEC_SCHEME + "|"
    						  + TLAConstants.Schemes.INIT_SCHEME + "|"
    						  + TLAConstants.Schemes.NEXT_SCHEME + "|"
    						  + TLAConstants.Schemes.CONSTANT_SCHEME + "|"
    						  + TLAConstants.Schemes.SYMMETRY_SCHEME + "|"
    						  + TLAConstants.Schemes.DEFOV_SCHEME + "|"
    						  + TLAConstants.Schemes.CONSTRAINT_SCHEME + "|"
    						  + TLAConstants.Schemes.ACTIONCONSTRAINT_SCHEME + "|"
    						  + TLAConstants.Schemes.INVARIANT_SCHEME + "|"
    						  + TLAConstants.Schemes.PROP_SCHEME + ")_[0-9]{17,}");

    /**
     * Creates a new valid unqiue identifier with timestamp from given scheme.
     * @param scheme a naming scheme, one of the {@link TLAConstants.Schemes} constants
     * @return a valid identifier
     */
	public static String getValidIdentifier(final String scheme) {
		return String.format("%s_%s%s", scheme, System.currentTimeMillis(), 1000 * COUNTER.incrementAndGet());
    }
    
    /**
     * Creates a new valid unqiue identifier without timestamp from given scheme. 
     * This was created to not mess with {@link getValidIdentifier} which is used by other classes. 
     * @param scheme a naming scheme, one of the {@link TLAConstants.Schemes} constants
     * @return a valid identifier
     */
	public static String getValidIdentifierNoTimestamp(final String scheme) {
		return String.format("_%s", scheme);
	}

	/**
     * Converts formula list to a string representation
     * @param formulaList list of assignments
	 * @param labelingScheme one of the {@link TLAConstants.Schemes} constants
     * @return
     */
	public static List<String[]> createListContent(final List<Formula> formulaList, final String labelingScheme) {
		ArrayList<String[]> resultContent = new ArrayList<>(formulaList.size());
		String[] content;
		String label;
		for (int i = 0; i < formulaList.size(); i++) {
			label = getValidIdentifier(labelingScheme);
			// formulas
			// to .cfg : <id>
			// to _MC.tla : <id> == <expression>
			content = new String[] { label, label + TLAConstants.DEFINES_CR + formulaList.get(i).getFormula(), String.valueOf(i) };
			resultContent.add(content);
		}
		return resultContent;
	}

    /**
     * Retrieves the name of the module (filename without extension)
     * 
     * @param moduleFilename
     *            filename of a module
     * @param checkExistence
     *            if true, the method returns module name, iff the specified file exists or null, if the specified file
     *            does not exist, if false - only string manipulations are executed
     * @return module name
     */
	public static String getModuleNameChecked(final String moduleFilename, final boolean checkExistence) {
		final File f = new File(moduleFilename);
		final int index = f.getName().lastIndexOf('.');
		if (checkExistence) {
			return (f.exists())
						? (index != -1) ? f.getName().substring(0, index) : f.getName()
						: null;
		}
		return (index != -1) ? f.getName().substring(0, index) : f.getName();
	}

    /**
     * Creates a simple content for a new TLA+ module
     *  
     * @param moduleFileName, name of the file 
     * @return the stream with content
     */
	public static StringBuilder getExtendingModuleContent(final String moduleFilename, final String... extendedModuleName) {
		final StringBuilder buffer = new StringBuilder();
		buffer.append(TLAConstants.SEP).append(' ').append(TLAConstants.KeyWords.MODULE).append(' ');
		buffer.append(getModuleNameChecked(moduleFilename, false)).append(' ').append(TLAConstants.SEP).append('\n');
		if (extendedModuleName.length != 0) {
			buffer.append(TLAConstants.KeyWords.EXTENDS).append(' ');
			buffer.append(String.join(", ", extendedModuleName));
			buffer.append("\n\n");
		}
		return buffer;
	}

	public static List<String[]> createFalseInit(final String var) {
		final List<String[]> list = new ArrayList<>();
		final String identifier = getValidIdentifier(TLAConstants.Schemes.INIT_SCHEME);
		list.add(new String[] { identifier,
							    (identifier + TLAConstants.DEFINES_CR + "FALSE/\\" + var + TLAConstants.EQ + "0") });
		return list;
	}

	public static List<String[]> createFalseNext(final String var) {
		final List<String[]> list = new ArrayList<>();
		final String identifier = getValidIdentifier(TLAConstants.Schemes.NEXT_SCHEME);
		list.add(new String[] { identifier,
								(identifier + TLAConstants.DEFINES_CR + "FALSE/\\" + var + TLAConstants.PRIME
											+ TLAConstants.EQ + var) });
		return list;
	}

    /**
     * Converts formula list to a string representation
     * @param serializedFormulaList, list of strings representing formulas (with enablement flag)
	 * @param labelingScheme one of the {@link TLAConstants.Schemes} constants
     * @return
     */
	public static List<String[]> createFormulaListContent(final List<String> serializedFormulaList,
			final String labelingScheme) {
		List<Formula> formulaList = Formula.deserializeFormulaList(serializedFormulaList);
		return createFormulaListContentFormula(formulaList, labelingScheme);
	}

	public static List<String[]> createFormulaListContentFormula(final List<Formula> serializedFormulaList,
			final String labelingScheme) {
		return SpecWriterUtilities.createListContent(serializedFormulaList, labelingScheme);
	}
	
	/**
	 * @param value if null or empty, an empty list will be returned
	 * @param labelingScheme one of the {@link TLAConstants.Schemes} constants
	 * @return the content for a single source element
	 */
	public static List<String[]> createSourceContent(final String value, final String labelingScheme) {
		return createSourceContent(value, labelingScheme, true);
	}
	
	/**
	 * @param value if null or empty, an empty list will be returned
	 * @param identifierOrLabelingScheme an identifier or one of the
	 *                                   {@link TLAConstants.Schemes} constants
	 * @param isScheme                   true if {@code identifierOrLabelingScheme}
	 *                                   is one of the scheme constants (in which
	 *                                   case an identifier will be generated based
	 *                                   off of it.)
	 * @return the content for a single source element
	 */
	public static List<String[]> createSourceContent(final String value, final String identifierOrLabelingScheme,
			final boolean isScheme) {
		final ArrayList<String[]> result = new ArrayList<>();
		if ((value == null) || (value.trim().length() == 0)) {
			return result;
		}
		
        final String identifier = isScheme ? SpecWriterUtilities.getValidIdentifier(identifierOrLabelingScheme)
        								   : identifierOrLabelingScheme;
        final StringBuilder buffer = new StringBuilder();

        buffer.append(identifier).append(TLAConstants.DEFINES_CR);
        buffer.append(value);

        result.add(new String[] { identifier, buffer.toString() });
        return result;
	}

    /**
     * Create a list of overrides. If the override is not in the spec's root module, then
     * the config file will have     A <- [M] id . This means that A is defined in module M,
     * and its definition is being overriden in the spec root module which is dependent upon M.
     * The following is an example from Leslie Lamport that explains what occurred before changing
     * the code and what occurs now.
     * Consider the root module

    ----------------- MODULE TestA --------------------
    M(a,b) == INSTANCE TestB WITH CB <- a, CD <- b
    ==================================================

    which imports the module

    ----------------- MODULE TestB --------------------
    CONSTANTS CB, CD

    Foo(x) == <<x, CB, CD>>
    ==================================================

    If you go to definition overrides, you'll find the option of
    overriding M!Foo.  Selecting it, the toolbox asks you to define an operator
    M!Foo of 3 arguments.  If you do it and run TLC, you get the error

    The configuration file substitutes for Foo with
    def_ov_12533499062845000 of different number of arguments.

    Here's what's going on.  The INSTANCE statement imports the operator
    M!Foo into module TestA.  As you may recall, you use that operator
    in an expression by writing something like

    M(42, "a")!F(-13)

    but in the semantic tree, it looks just as if M!F were any other
    operator with three arguments.  When TLC sees the override instruction

    Foo <- [TestB]def_ov_12533495599614000

    in the .cfg file, it tries to substitute an operator def_ov_...  with
    3 arguments for the operator Foo of module TestB that has only a
    single argument.  Hence, the error.

    ------

    Here's the fix.  Instead of giving the user the option of overriding
    M!Foo, in the menu, he should simply see Foo and, if he clicks once
    it, he should see that it's in module TestB. If he chooses to override
    Foo, he should be asked to define an operator of one argument.
    
     * @param overrides
	 * @param labelingScheme one of the {@link TLAConstants.Schemes} constants
	 * @param specObj
     * @return
     * 
     * Was throwing null-pointer exception when called with spec unparsed.
     * Hacked a fix to handle this case.  LL 20 Sep 2009
     */
	public static List<String[]> createOverridesContent(final List<Assignment> overrides, final String labelingScheme,
			final SpecObj specObj) {
		final ArrayList<String[]> resultContent = new ArrayList<>(overrides.size());
		String[] content;
		String id;
		Assignment formula;

        // getting the opdefnodes is necessary for retrieving the correct label
        // to appear in the cfg file as explained in the documentation for this method
		if (specObj == null) {
			return resultContent;
		}
		final OpDefNode[] opDefNodes = specObj.getExternalModuleTable().getRootModule().getOpDefs();
		final HashMap<String, OpDefNode> nodeTable = new HashMap<>(opDefNodes.length);

		for (int j = 0; j < opDefNodes.length; j++) {
			final String key = opDefNodes[j].getName().toString();
			nodeTable.put(key, opDefNodes[j]);
		}

		for (int i = 0; i < overrides.size(); i++) {
            id = getValidIdentifier(labelingScheme);
            // formulas
            // to .cfg : <id>
            // to _MC.tla : <id> == <expression>
            formula = overrides.get(i);

            final OpDefNode defNode = nodeTable.get(formula.getLabel());
			if (defNode == null) {
				// should raise an error
				content = null;
			} else {
				final OpDefNode source = defNode.getSource();
				if (source == defNode) {
                    // user is overriding a definition in the root module
					if (formula.isModelValue() && !formula.isSetOfModelValues()) {
                        // model value
                        content = new String[] { formula.getLabel() + TLAConstants.EQ + formula.getLabel(), TLAConstants.EMPTY_STRING };
					} else {
                        // not a model value
                        content = new String[] { formula.getLabel() + TLAConstants.ARROW + id,
                                formula.getParametrizedLabel(id) + TLAConstants.DEFINES_CR + formula.getRight() };
                    }
				} else if (source.getSource() == source) {
					// user is overriding a definition that is not in the root module
					if (formula.isModelValue() && !formula.isSetOfModelValues()) {
                        // model value
                        content = new String[] {
                                source.getName().toString() + TLAConstants.ARROW + "["
                                        + source.getOriginallyDefinedInModuleNode().getName().toString() + "]" + id
                                        + " " + id + TLAConstants.EQ + source.getName().toString(), "CONSTANT " + id };
					} else {
                        // not a model value
                        content = new String[] {
                                source.getName().toString() + TLAConstants.ARROW + "["
                                        + source.getOriginallyDefinedInModuleNode().getName().toString() + "]" + id,
                                formula.getParametrizedLabel(id) + TLAConstants.DEFINES_CR + formula.getRight() };
                    }
				} else {
                    // should raise an error window
                    content = null;
                }
            }

            resultContent.add(content);
        }
		
        return resultContent;
    }

    /**
     * Counter to be able to generate unique identifiers
     */
    private static final AtomicLong COUNTER = new AtomicLong(1L);

}
