/* Generated By:23&JavaCC: Do not edit this line. TLAplusParser.java */
package tla2sany.parser;

import tla2sany.st.ParseTree;
import tla2sany.st.TreeNode;
import tlc2.output.EC;
import util.Assert;
import util.TLAConstants;
import util.ToolIO;
import util.UniqueString;

import java.util.ArrayList;
import java.util.Objects;
import java.util.Stack;

@SuppressWarnings("unused")
public class TLAplusParser implements tla2sany.st.SyntaxTreeConstants, ParseTree, TLAplusParserConstants {

    static final private int[] jj_la1_0 = new int[]{0x0, 0x0, 0x0, 0x0, 0x4, 0x80000, 0x80000, 0x100008, 0x0, 0x0, 0x0, 0x0, 0x100008, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,};
    static final private int[] jj_la1_1 = new int[]{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4, 0x0, 0x8000, 0x808, 0x0, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x200000, 0x0, 0x40000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x200000, 0x0, 0x0, 0x0, 0x0, 0x140, 0x0, 0x0, 0xc0, 0x800820, 0x0, 0x800820, 0x0, 0x800800, 0x0, 0x0, 0x800000, 0x800000, 0x20, 0x0, 0x0, 0x2000000, 0x0, 0x0, 0x0, 0x80000000, 0x80000000, 0x40000000, 0x400000, 0x0, 0x400000, 0x400000, 0x0, 0x400000, 0x0, 0x0, 0x200, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4000000, 0x4000000, 0x180b4600, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x14000, 0x0, 0x0, 0x0, 0x18000000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4000000, 0x200000, 0x200000, 0x0, 0x0, 0x0, 0x0, 0x4000000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x180b4600,};
    static final private int[] jj_la1_2 = new int[]{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x800000, 0x0, 0x100000, 0x4000, 0x0, 0x800000, 0x800000, 0x800000, 0x800000, 0x0, 0x8000000, 0x0, 0x800000, 0x0, 0x0, 0x800000, 0x0, 0x8000000, 0x800000, 0x8000000, 0x20000000, 0x800000, 0x20000000, 0x0, 0x8000000, 0x0, 0x400000, 0x0, 0x0, 0x100, 0x0, 0x80000000, 0x0, 0x0, 0x118000, 0x800000, 0x118000, 0x1800, 0x0, 0x0, 0x8000000, 0x0, 0x0, 0x18000, 0x8000000, 0x0, 0x4, 0x400, 0xc0, 0x400, 0x0, 0x0, 0x418, 0x0, 0x800000, 0x0, 0x0, 0x800000, 0x0, 0x2, 0x0, 0x60220, 0x1, 0x800000, 0x800000, 0x0, 0x800000, 0x800000, 0x800000, 0x0, 0x80000, 0x20000000, 0x20200000, 0x20200000, 0x0, 0x0, 0x20000000, 0x0, 0x0, 0x800000, 0x0, 0x0, 0x800000, 0x800000, 0x0, 0x0, 0x800000, 0x800000, 0x0, 0x0, 0x800000, 0x1800000, 0x1800000, 0x800000, 0x800000, 0x800000, 0x800000, 0x1800000, 0x1800000, 0x800000, 0x800000, 0x800000, 0x800000, 0x800000, 0x800000, 0x800000, 0x4000000, 0x800000, 0x4000000, 0x800000, 0x0, 0x800000, 0x0, 0x0, 0x20000000, 0x200000, 0x80004000, 0x80004000, 0x0, 0x0, 0x800000, 0x0, 0x20200000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x20000000, 0x1000000, 0x0,};
//  public tla2sany.st.ParseErrors getErrors() { return PErrors; } Unused, apparently
// The front end can simply read the public PErrors.
    static final private int[] jj_la1_3 = new int[]{0xff800000, 0xffc00000, 0x0, 0x3c0000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3c0000, 0xffc00000, 0x0, 0x0, 0x0, 0xffc00000, 0x0, 0x0, 0xffc00000, 0x0, 0xffc00000, 0x0, 0x0, 0x0, 0x3c0000, 0xffc00000, 0x0, 0x0, 0xfffc0000, 0xfffc0000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffc00000, 0x0, 0x0, 0x0, 0xffc00000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x80, 0x0, 0x0, 0xa9, 0xffbcc0a9, 0x0, 0xffbcc000, 0x0, 0x400, 0xffbc0000, 0x0, 0xfffc0000, 0x0, 0x0, 0x0, 0x80, 0x0, 0x0, 0x0, 0x80, 0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x806, 0x1, 0x0, 0x1, 0x0, 0x0, 0x0, 0x300, 0x400, 0xa9, 0x0, 0x0, 0x0, 0x0, 0x80, 0x0, 0xff800000, 0xa9, 0xff800000, 0x0, 0x3c0000, 0x400, 0xfffc0000, 0xfffc0000, 0x0, 0x4280, 0x0,};
    static final private int[] jj_la1_4 = new int[]{0x1, 0x1, 0xfffffffe, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xfffffffe, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x1, 0x0, 0x1, 0x0, 0x0, 0x0, 0xfffffffe, 0x1, 0x0, 0x0, 0xffffffff, 0xffffffff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x100000, 0x1, 0x0, 0x0, 0x0, 0x1, 0x100000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffffffff, 0x0, 0xffffffff, 0x0, 0x0, 0xffffffff, 0x0, 0xffffffff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x100000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x24, 0x0, 0x0, 0xffffffff, 0x0, 0xffffffff, 0x0, 0xfffffffe, 0x0, 0xffffffff, 0xffffffff, 0x0, 0x0, 0x0,};
    static final private int[] jj_la1_5 = new int[]{0x0, 0x0, 0xffffffff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffffffff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffffffff, 0x0, 0x0, 0x0, 0xffffffff, 0xffffffff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffffffff, 0x0, 0xffffffff, 0x0, 0x0, 0xffffffff, 0x0, 0xffffffff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4000000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffffffff, 0x0, 0xffffffff, 0x0, 0xffffffff, 0x0, 0xffffffff, 0xffffffff, 0x0, 0x0, 0x0,};
    static final private int[] jj_la1_6 = new int[]{0x0, 0x0, 0xffffffff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffffffff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffffffff, 0x0, 0x0, 0x0, 0xffffffff, 0xffffffff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffffffff, 0x0, 0xffffffff, 0x0, 0x0, 0xffffffff, 0x0, 0xffffffff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffffffff, 0x0, 0xffffffff, 0x0, 0xffffffff, 0x0, 0xffffffff, 0xffffffff, 0x0, 0x0, 0x0,};
    static final private int[] jj_la1_7 = new int[]{0x0, 0x0, 0x7f, 0x0, 0x0, 0x80, 0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7f, 0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x80, 0x80, 0x0, 0x80, 0x0, 0x0, 0x0, 0x7f, 0x0, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0x0, 0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1f00, 0x0, 0x0, 0x0, 0x0, 0x80, 0x0, 0x0, 0x0, 0x80, 0x0, 0x0, 0x0, 0xff, 0x0, 0xff, 0x0, 0x0, 0xff, 0x0, 0x7f, 0x0, 0x0, 0x0, 0x80, 0x0, 0x0, 0x0, 0x80, 0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x80, 0x0, 0x0, 0x0, 0x0, 0x80, 0x0, 0x7f, 0x0, 0x7f, 0x300, 0x3ff, 0x0, 0x3ff, 0x7f, 0x0, 0x0, 0x0,};
    /***********************************************************************
     * The root node.                                                       *
     ***********************************************************************/

    public final ArrayList<UniqueString> dependencyList = new ArrayList<>(20);
    final ParseErrors PErrors = new ParseErrors();
    final Stack<UniqueString> internals = new Stack<>();
    private final Operator FcnOp;
    private final UniqueString At = UniqueString.uniqueStringOf("@");
    private final tla2sany.parser.OperatorStack OperatorStack;
    private final String emptyString = "";
    /*************************************************************************
     * The nesting level of the proof we're currently processing, counting    *
     * from 0 a la Java.                                                      *
     *************************************************************************/

    private final int MaxProofDepth = 100;
    private final int[] proofLevelStack = new int[MaxProofDepth];
    final private int[] jj_la1 = new int[140];
    /***********************************************************************
     * This is set to a non-null value only in Expression().  If a          *
     * ClosedExpressionOrOp node is found when parsing an expression,       *
     * anchor is set to that node.  It is set to null in the following      *
     * places:                                                              *
     *                                                                      *
     *  - When beginning to parse a Substitution()                          *
     *                                                                      *
     *  - When OpSuite() or Substitution() finds that anchor equals an      *
     *    Op Symbol, as described below.                                    *
     *                                                                      *
     * The Substitution() and OpSuite() procedures look for an              *
     * Expression or Op Symbol by calling Expression() and, if that throws  *
     * an exception, catching the expression and checking if anchor is the  *
     * desired Op Symbol.                                                   *
     ***********************************************************************/

// Lookahead mechanisms for definitions
    final private JJCalls[] jj_2_rtns = new JJCalls[77];
    private final Operators operators;
    final private LookaheadSuccess jj_ls = new LookaheadSuccess();
    private final java.util.ArrayList<int[]> jj_expentries = new java.util.ArrayList<>();
    private final int[] jj_lasttokens = new int[100];
    public SyntaxTreeNode ParseTree;
    public TLAplusParserTokenManager token_source;
    public Token token, jj_nt;
    public boolean lookingAhead = false;
    // global variable follows !!! Make sure it is set everywhere as required
    Operator lastOp;
    Object[] msgStack = new Object[512];
    int msgStackMaxSize = 512;
    int msgStackCurrentSize = 0;
    SimpleCharStream jj_input_stream;
    private UniqueString mn = null;
    /**********************************************************************
     * The module name.                                                    *
     **********************************************************************/

    private boolean numberFlag = false;
    private boolean decimalFlag = false;
    private SyntaxTreeNode FairnessHook;
    private BracketStack BStack;
    /*
  this is required to store temporarily information required by
  the semantic lookahead, as it doesn't have access to the variables
  of the production
*/
    private SyntaxTreeNode local;
    private SyntaxTreeNode anchor = null;

//
    private String expecting = "nothing";
    /*************************************************************************
     * heirsTable is an array of physical length heirsSize that implements a  *
     * dynamic array of length heirsIndex, where heirsIndex <= heirsSize.     *
     * Elements are added to heirsTable by the addHeir method, which          *
     * increments heirsSize if needed.  Elements are removed from the array   *
     * by the getLastHeirs() and popHeir() methods.                           *
     *                                                                        *
     * It appears that the heirsTable is used as a stack of sequences of      *
     * syntax tree nodes, each being the sequence of heirs (children) of a    *
     * node that is currently being parsed.  The top of the stack is the      *
     * sequence at the end of the heirsTable array.  Each sequence is begun   *
     * by a null entry.  The bpa() method is called when about to push such   *
     * a sequence onto the stack; it adds the null element that marks the     *
     * beginning of the sequence.  Similarly, the epa() method is called      *
     * after popping a sequence off the top of the stack; it removes the      *
     * null element.                                                          *
     *************************************************************************/
    private SyntaxTreeNode[] heirsTable = new SyntaxTreeNode[512];
    private int heirsSize = 512;
    private int heirsIndex = 0;
    /***************************************************************************
     * Fields and methods for parsing proofs.                                   *
     ***************************************************************************/
    private int proofDepth = -1;
    private int jj_ntk;
    private Token jj_scanpos, jj_lastpos;
    private int jj_la;
    private boolean jj_semLA;
//
    private int jj_gen;
    private boolean jj_rescan = false;
    private int jj_gc = 0;
    private int[] jj_expentry;
    private int jj_kind = -1;
    private int jj_endpos;

    public TLAplusParser(final Operators operators, final java.io.InputStream stream) {
        this(operators, stream, null);
    }

    public TLAplusParser(final Operators operators, final java.io.InputStream stream, final String encoding) {
        this.operators = operators;
        this.FcnOp = operators.getOperator(UniqueString.uniqueStringOf("["));
        this.OperatorStack = new tla2sany.parser.OperatorStack(operators, PErrors);

        try {
            jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1);
        } catch (final java.io.UnsupportedEncodingException e) {
            throw new RuntimeException(e);
        }
        token_source = new TLAplusParserTokenManager(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 140; i++) jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
    }

    public TLAplusParser(final Operators operators, final TLAplusParserTokenManager tm) {
        this.operators = operators;
        this.FcnOp = operators.getOperator(UniqueString.uniqueStringOf("["));
        this.OperatorStack = new tla2sany.parser.OperatorStack(operators, PErrors);

        token_source = tm;
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 140; i++) jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
    }

    @Override
    public String[] dependencies() {
        /***********************************************************************
         * This method is used in modanalyzer/{SyntaxTreePrinter,ParserUnit}.   *
         ***********************************************************************/
        final String[] deps = new String[dependencyList.size()];
        for (int lvi = 0; lvi < deps.length; lvi++)
            deps[lvi] = dependencyList.get(lvi).toString();
        return deps;
    }

    @Override
    public TreeNode rootNode() {
        return ParseTree;
    }

    @Override
    public String moduleName() {
        return mn.toString();
    }

    /***********************************************************************
     * This is a stack of the kinds and offsets of the tokens that start a  *
     * bulleted list within which the parser is currently grabbing tokens.  *
     ***********************************************************************/

    @Override
    public boolean parse() {
        /***********************************************************************
         * This is a wrapper for actual parsing procedure CompilationUnit().    *
         * If an exception occurs, or if an error was pushed onto PErrors,      *
         * then an error message is printed and it returns false.  Otherwise,   *
         * it returns true.  Note that if we want to be able to parse an        *
         * expression, we need to implement a similar wrapper for               *
         * Expression().                                                        *
         ***********************************************************************/

        /***********************************************************************
         * The following code sets BStack to a new BracketStack object and      *
         * initializes its classes field as described in BracketStack.java.     *
         ***********************************************************************/
        BStack = new BracketStack();
        BStack.newClass();
//    BStack.registerInCurrentClass( BAND );
        BStack.registerInCurrentClass(AND);
        BStack.newClass();
//    BStack.registerInCurrentClass( BOR );
        BStack.registerInCurrentClass(OR);
        BStack.newClass();
        BStack.registerInCurrentClass(PROOF);
        BStack.newClass();
        BStack.registerInCurrentClass(LBR);
        BStack.newClass();
        BStack.registerInCurrentClass(ASSUME);

        try {
            ParseTree = CompilationUnit();
        } catch (final ParseException e) {
            PErrors.push(new ParseError(msgStackToString(e)));
        } catch (final TokenMgrError tme) {
            // lexical error.
            final String msg = tme.getMessage();
            final int bl = jj_input_stream.getBeginLine() + 1;
            final int el = jj_input_stream.getEndLine() + 1;
            // lexical error.
            if ((msg.contains("EOF")) && (bl != el)) {
                PErrors.push(new ParseError(
                        "Lexical {error: EOF reached, " +
                                "possibly open comment starting around line " +
                                (bl - 1)));
            } else PErrors.push(new ParseError(msg));
//      PErrors.push( new ParseError( tme.getMessage() )) ;
        } /*** end catch(TokenMgrError) ****/
        if (PErrors.empty()) Assert.check(heirsIndex == 0, EC.SANY_PARSER_CHECK_1
//   "Assertion error in TLA+ Parser sanity check"
        );
        /*********************************************************************
         * This is a sanity check.  The assertion should never be false.      *
         *********************************************************************/
        else {
            /*********************************************************************
             * An error has been pushed onto PErrors.  It might have been done    *
             * when an exception was caught, or by detecting an error during the  *
             * parsing without throwing an exception.  This happens in            *
             * ExceptComponent() if it finds "!.@", and in FairnessExpr().        *
             *********************************************************************/
            final tla2sany.st.ParseError[] list = PErrors.errors();
            for (final tla2sany.st.ParseError parseError : list) {
                ToolIO.out.println(parseError.reportedError());
//        ToolIO.out.println( "+ " + list[i].defaultError() );
            }
        }
//   ParseTree.setNumberFlags( numberFlag, decimalFlag );
        return PErrors.empty();
    }

    boolean testTN() {
        /***********************************************************************
         * THIS METHOD IS APPARENTLY NOT USED.                                  *
         ***********************************************************************/
        return local.isKind(N_IdPrefix)
                && BStack.aboveReference(local.first().first().location[0]);
    }

    /*************************************************************************
     * The following code is lifted directly from the getToken method         *
     * created by JavaCC in the file TLAplusParser.java.                      *
     *                                                                        *
     * J-Ch doesn't remember why he defined this method instead of just       *
     * using the GetToken method.  He thinks that it was to make sure         *
     * it would always return a token rather than null.                       *
     *************************************************************************/
    private Token getNextPreviewToken(final Token t) {
        if (t.next == null) t.next = token_source.getNextToken();
        /********************************************************************
         * token_source is declared in configuration/Configuration.java to   *
         * be a ConfigurationTokenManager.                                   *
         ********************************************************************/
        return t.next;
    }

    // borrowed from code generated by JavaCC.
    private Token initPreviewToken() {
        return lookingAhead ? jj_scanpos : token;
        /*********************************************************************
         * `lookingAhead', `token', and `jj_scanpos' are declared in          *
         * TLAplusParser (created by javacc from this file).  The javacc      *
         * documentation says that token is the value returned by             *
         * getToken(0).  God only knows what lookingAhead and jj_scanpos      *
         * are.                                                               *
         *********************************************************************/
    }

    private void belchDEF() {
        /***********************************************************************
         * The purpose of this method seems to be to introduce a dummy          *
         * <DEFBREAK> token into the token stream, which is used in parsing     *
         * the OperatorOrFunctionDefinition non-terminal.                       *
         ***********************************************************************/
        Token previousT = initPreviewToken();
        Token currentT = getNextPreviewToken(previousT);
        previousT.next = null;  // <-- to break recursion
        Token nextT = getNextPreviewToken(currentT);
        currentT.next = previousT;
        while (nextT.kind != EOF
                && nextT.kind != THEOREM
                && nextT.kind != PROPOSITION
                /***************************************************************
                 * This test for PROPOSITION added by LL on 5 Sep 2010 to get   *
                 * the parser to handle a named PROPOSITION, LEMMA, or          *
                 * COROLLARY.                                                   *
                 ***************************************************************/
//           && nextT.kind != ASSUME
                /****************************************************************
                 * This test for ASSUME removed on 26 June 2007.                 *
                 * It made belchDEF get hung up on nested ASSUME/PROVEs.         *
                 * However, this permitted extra DEFBREAK tokens to be inserted. *
                 * Those extra tokens were eliminated by the change on the same  *
                 * date described below.                                         *
                 ****************************************************************/
                && nextT.kind != ASSUMPTION
                && nextT.kind != END_MODULE) {
            /*********************************************************************
             * As long as we have not yet reached the end of the stream or a      *
             * THEOREM, ASSUME, or END_MODULE token, move forward through the     *
             * token stream looking for a "==" token.  Maintain a chain of the    *
             * tokens passed over, with t.next equal to the previous token, and   *
             * t.next = null for the first token.                                 *
             *                                                                    *
             * At this point, the last three tokens obtained are previoustT,      *
             * currentT, and nextT, where currentT.next = previousT and           *
             * nextT.next points to the first unexamined token.                   *
             *********************************************************************/
            if (currentT.kind == DEF) {
                /*******************************************************************
                 * currentT is a "==" token.                                        *
                 *******************************************************************/
                Token t = previousT;
                if (t.kind == RBR || t.kind == RSB) {
                    /*****************************************************************
                     * t = previousT is a ")" or "]" token.                           *
                     *****************************************************************/
                    // the following code assumes that parentheses are evenly balanced.
                    // something could be added to reinforce the test.
                    // they do not have to be on the same line either, btw.
                    int depth = 1;
                    while (t.next != null) {
                        t = t.next;
                        if ((t.kind == LBR || t.kind == LSB) && depth == 1) break;
                        if ((t.kind == LBR || t.kind == LSB) && depth > 1) depth--;
                        if ((t.kind == RBR || t.kind == RSB)) depth++;
                    }
                    if (t.next == null) break;
                    else if (t.next.kind == IDENTIFIER)
                        t = t.next;
                    // we are positioned at first symbol before "[" or "(" : must be an identifier
                } else
                /*****************************************************************
                 * t = previousT is not a ")" or "]" token.                       *
                 *****************************************************************/
                    if (t.kind == IDENTIFIER) {
                        /**************************************************************
                         * t is an IDENTIFIER token.                                   *
                         *                                                             *
                         * If t.next [the previous token in the input stream] is a     *
                         * non-prefix operator and is not preceded in the stream by    *
                         * "<-" [so it belongs to a preceding substitution], then set  *
                         * t to t.next if it is a prefix operator and to t.next.next   *
                         * if it is an infix operator.                                 *
                         *                                                             *
                         * Note: If belchDef is called with the input stream at        *
                         * something like "++ a ==", then evaluating t.next.next       *
                         * dereferences null.  This should happen only if the user     *
                         * has left off the first parameter of the definitiion and     *
                         * the resulting exception seems to be caught, but it          *
                         * produces a misleading error message.  This type of rare     *
                         * error is hardly worth worrying about, but it would be easy  *
                         * enough to add a test and might be worth doing if it's easy  *
                         * to produce the right error message.                         *
                         *                                                             *
                         * Modified 22 Feb 2013 by LL to check that something like     *
                         * "++ a ==" is preceded by an identifier.  This fixes         *
                         * mishandled case of something like                           *
                         *                                                             *
                         *      USE ... DEF ++                                         *
                         *      a == ...                                               *
                         **************************************************************/
                        final Token identifier = t;
                        if (isOp(t.next)
                                && !isPostfixOp(t.next)
                                && (!isInfixOp(t.next)
                                || ((t.next.next != null)
                                && (t.next.next.kind == IDENTIFIER))
                        )
                        ) {
                            t = t.next;
                            if (t.next.kind == SUBSTITUTE)
                                t = identifier; // skip back
                            else if (isInfixOp(t)) t = t.next;
                            // else assume prefix
                        }
                    } else {
                        /**************************************************************
                         * t is not an IDENTIFIER token.                               *
                         *                                                             *
                         * If it is an operator token, set t to t.next.  (It will be   *
                         * a postfix operator unless the user made an error.)          *
                         **************************************************************/
                        if (isOp(t)) { // assume postfix op, the parser will catch the error
                            t = t.next;
                        }
                    }
                /*******************************************************************
                 * Insert a DEFBREAK token into the input stream right before       *
                 * token t, and exit the while loop.                                *
                 *                                                                  *
                 * Changed by LL on 26 June 2007 so it doesn't add the DEFBREAK     *
                 * token if there's already one there.  (This could happen because  *
                 * of the change to pass over ASSUMEs described above.)             *
                 *******************************************************************/
                if ((t.next == null)
                        || (t.next.kind != DEFBREAK)) {
                    final Token i = new Token();
                    i.kind = DEFBREAK;
                    i.image = "Beginning of definition";
                    i.beginLine = t.beginLine;
                    i.beginColumn = t.beginColumn;
                    i.endLine = t.endLine;
                    i.endColumn = t.endColumn;
                    i.next = t.next;
                    t.next = i;
                }
                break;  /* EXIT while */
            } else {
                /*******************************************************************
                 * currentT is not a "==" token.                                    *
                 *******************************************************************/
                previousT = currentT;
                currentT = nextT;
                nextT = getNextPreviewToken(currentT);
                currentT.next = previousT;
            }
        }  /* END while */
        // reverse pointers.
        /***********************************************************************
         * Go back through the examined tokens, making t.next point to the      *
         * next one for each token t.                                           *
         ***********************************************************************/
        while (previousT != null) {
            currentT.next = nextT;
            nextT = currentT;
            currentT = previousT;
            previousT = currentT.next;
        }
        // relink firstT
        currentT.next = nextT;
    }

    boolean
    isOp(final Token t) {
        return t.kind >= op_57 && t.kind <= op_119;
    }

    boolean isInfixOp(final Token t) {
        return t.kind >= op_1 && t.kind <= op_119;
    }

    boolean isPostfixOp(final Token t) {
        return t.kind >= op_57 && t.kind <= op_70;
    }

    /*************************************************************************
     * This seems to equal the last Prefix, Infix, PostFix, or NonExpPrefix   *
     * op that was parsed.                                                    *
     *************************************************************************/

    boolean isGenOp(final SyntaxTreeNode tn) { /* has to be of the form prefix, opsym */
        final int kind = tn.getKind();
        return kind == N_GenPrefixOp
                || kind == N_GenNonExpPrefixOp
                || kind == N_GenInfixOp
                || kind == N_GenPostfixOp
                || kind == N_FcnAppl;
    }

    boolean isFieldNameToken(final Token t) {
        /***********************************************************************
         * Modified by LL on 10 Oct 2007 because of new keywords added and      *
         * obsolete ones removed.                                               *
         ***********************************************************************/
        return (t.kind >= ACTION && t.kind <= EXCEPT)
                || (t.kind == EXTENDS)
                || (t.kind >= IF && t.kind <= SF)
                || (t.kind == STATE)
                || (t.kind >= THEN && t.kind <= WITH)
                || (t.kind == US)
                || (t.kind >= op_112 && t.kind <= op_116);
    }

    boolean isLabel(final SyntaxTreeNode node) {
        /***********************************************************************
         * Checks that node is a label, meaning that it is either an            *
         * identifier token or else an OpApplication node each of whose         *
         * arguments is an OpArgs node whose child is a GeneralId node with an  *
         * empty IdPrefix.                                                      *
         ***********************************************************************/
        if (node == null) {
            return false;
        }
        if (node.isKind(N_GeneralId)) {
            return (node.heirs()[0].heirs().length == 0);
        }
        if (!node.isKind(N_OpApplication)) {
            return false;
        }
        final SyntaxTreeNode opArgs = (SyntaxTreeNode) node.heirs()[1];
        if (opArgs.kind != N_OpArgs) {
            ToolIO.out.println("Bug: not N_OpArgs node");
        }
        /*******************************************************************
         * Sanity check--can be removed after debugging.                    *
         *******************************************************************/
        for (int i = 1; i < opArgs.heirs().length; i = i + 2) {
            /*********************************************************************
             * THe OpArg node for Op(arg_1, ... , arg_N) has the 2N+1 heirs       *
             *                                                                    *
             *     "("   arg_1   ","  ...  ","   arg_N   ")"                      *
             *********************************************************************/
            final SyntaxTreeNode genId = (SyntaxTreeNode) opArgs.heirs()[i];
            if (genId.kind != N_GeneralId) {
                return false;
            }
            if (genId.heirs()[0].heirs().length != 0) {
                return false;
            }
        } // for
        return true;
    }

    boolean labelDoesNotChangeParse(final SyntaxTreeNode labeledExpr,
                                    final Operator labelOp) {
        /***********************************************************************
         * Checks if preceding the expression labeledExpr with a label has not  *
         * changed the parsing of the enclosing expression.  It has changed     *
         * the parsing iff                                                      *
         *   /\ labeledExpr is an infix or postfix expression with operator     *
         *      labelOp                                                         *
         *   /\ the top of OperatorStack is an infix or prefix operator stackOp *
         *   /\ it is not the case that stackOp \prec labelOp.                  *
         ***********************************************************************/
        if (!(labeledExpr.isKind(N_InfixExpr)
                || labeledExpr.isKind(N_PostfixExpr))) {
            return true;
        }

        final OSelement topNode = OperatorStack.topOfStack();
        if (topNode == null) {
            return true;
        }
        final Operator stackOp = topNode.getOperator();
        return (stackOp == null) || Operator.prec(stackOp, labelOp);
    }

    void checkIndentation(final SyntaxTreeNode nd, final SyntaxTreeNode junct)
            throws ParseException {
        /***********************************************************************
         * Goes through the descendants of node nd, stopping at an N_DisjList   *
         * or N_ConjList node.  For each node it finds, if checks whether it    *
         * is properly indented with respect to the current N_DisjItem or       *
         * N_ConjItem junct.  If not, it reports an error by throwing an        *
         * exception.                                                           *
         ***********************************************************************/
        final TreeNode[] children = nd.heirs();
        for (final TreeNode treeNode : children) {
            final SyntaxTreeNode child = (SyntaxTreeNode) treeNode;
            if (!(child.isKind(N_ConjList)
                    || child.isKind(N_DisjList))) {
                if (!BStack.aboveReference(child.location[1])) {
                    throw new ParseException(
                            "Item at " + child.getLocation() +
                                    " is not properly indented inside conjunction or " +
                                    " disjunction list item at " + junct.getLocation());
                }
                checkIndentation(child, junct);
            }
        }
    }

    boolean caseSep() {
        final Token t = getToken(1);
        return (t.kind == CASESEP);
    }

    boolean matchFcnConst() {
        /***********************************************************************
         * Seems to return true iff the next current token sequence begins      *
         * with "<< ...  >> \in" or "Identifier [, Identifier] \in".  It is     *
         * used after a "{" to see if this is a subset expression such as "{x   *
         * \in S : exp}" and after a "[" to see if it is a function expression  *
         * such as "[x \in S |-> exp]".  This leads to the bug that it starts   *
         * incorrectly interpreting the expressions "{x \in S}" and             *
         * "{<<1, 2>> \in {}}" as a subset expression and reports an error.     *
         ***********************************************************************/
        Token t = initPreviewToken();
        t = getNextPreviewToken(t);
        if (t.kind == LAB) {
            int count = 1;
            while (count != 0) {
                t = getNextPreviewToken(t);
                if (t.kind == LAB) count++;
                if (t.kind == RAB) count--;
                if (t.kind == EOF) return false;
            }
            t = getNextPreviewToken(t);
            return (t.kind == IN);
        } else if (t.kind == IDENTIFIER) {
            t = getNextPreviewToken(t);
            while (t.kind == COMMA) {
                t = getNextPreviewToken(t);
                if (t.kind != IDENTIFIER) return false;
                t = getNextPreviewToken(t);
            }
            return (t.kind == IN);
        } else
            return false;
    }

    private void pushMsg(final String s, final Token t) {
        if (msgStackCurrentSize == msgStackMaxSize) {
            final Object[] neo = new Object[2 * msgStackMaxSize];
            System.arraycopy(msgStack, 0, neo, 0, msgStackMaxSize);
            msgStack = neo;
            msgStackMaxSize *= 2;
        }
        msgStack[msgStackCurrentSize] = s;
        msgStack[msgStackCurrentSize + 1] = t;
        msgStackCurrentSize += 2;
    }

    private void popMsg() {
        msgStackCurrentSize -= 2;
    }

    /***********************************************************************
     * It appears that the value of expecting is what is printed out in     *
     * error messages as what the parser was expecting when it encountered  *
     * an error.                                                            *
     ***********************************************************************/

    private String msgStackToString(final ParseException e) {
        final StringBuilder msg;

        msg = new StringBuilder("***Parse Error***\n");
        if (!expecting.equals(emptyString)) {
            msg.append("Was expecting \"");
            msg.append(expecting);
            msg.append("\"\n");
        }

        msg.append(e.getShortMessage());

        msg.append("\n\nResidual stack trace follows:\n");
        int last = msgStackCurrentSize - 10;
        if (last < 0) last = 0;
        for (int lvi = msgStackCurrentSize; lvi > last; lvi -= 2) {
            msg.append((String) msgStack[lvi - 2]);
            msg.append(" starting at line ");
            final Token t = (Token) msgStack[lvi - 1];
            msg.append(t.beginLine);
            msg.append(", column ");
            msg.append(t.beginColumn);
            msg.append(".\n");
        }
        return msg.toString();
    }

    private void addHeir(final SyntaxTreeNode sn) {
        /***********************************************************************
         * Appends the syntax tree sn to the end of the dynamic array           *
         * implemented by heirsTable.                                           *
         ***********************************************************************/
        if (heirsIndex == heirsSize) {
            final SyntaxTreeNode[] nh = new SyntaxTreeNode[heirsSize + 512];
            System.arraycopy(heirsTable, 0, nh, 0, heirsSize);
            heirsSize += 512;
            heirsTable = nh;
        }
        heirsTable[heirsIndex] = sn;
        heirsIndex++;
    }

    private SyntaxTreeNode[] getLastHeirs() {
        /***********************************************************************
         * This method will throw an array-out-of-bounds exception if called    *
         * when heirsIndex = 0 (so the dynamic array implemented by heirsTable  *
         * is empty) or if that dynamic array contains no null entry.           *
         *                                                                      *
         * If the last element of the dynamic heirsTable array is null, then    *
         * it returns null.  Otherwise, it returns an array equal to the        *
         * sequence of non-null elements at the end of the dynamic heirsTable   *
         * array and removes them from that array.                              *
         ***********************************************************************/
        int lvi = heirsIndex - 1;
        while (heirsTable[lvi] != null) lvi--;
        /***********************************************************************
         * Assert: /\ lvi < heirsIndex                                          *
         *         /\ heirsTable[lvi] = null                                    *
         *         /\ \A i \in lvi+1 .. heirsIndex-1 : heirsTable[i] # null     *
         ***********************************************************************/
        final int as = heirsIndex - lvi - 1;
        if (as == 0)
            return null;
        else {
            final SyntaxTreeNode[] ts = new SyntaxTreeNode[as];
            System.arraycopy(heirsTable, lvi + 1, ts, 0, as);
            heirsIndex = lvi + 1;
            /*********************************************************************
             * Assert /\ as > 0                                                   *
             *        /\ \A i \in 0..as-1 : ts[i] = heirsTable[lvi + i + 1]       *
             *        /\ heirsIndex = lvi + 1                                     *
             *********************************************************************/
            return ts;
        }
    }

    private boolean popHeir() {
        /************************************************************************
         * Throws an array-out-of-bounds exception if heirsIndex = 0 (meaning    *
         * that the dynamic array implemented by heirsTable is empty).           *
         *                                                                       *
         * It removes the last element from the heirsTable array and returns     *
         * true iff the new last element is null.                                *
         ************************************************************************/
        return heirsTable[--heirsIndex] == null;
    }

    private void bpa(final String s) { // Beginning of Production Actions
        addHeir(null);
        if (System.getProperty("TLA-StackTrace", "off").equals("on")) ToolIO.out.println("Beginning " + s);
        pushMsg(s, getToken(1));
        expecting = emptyString;
    }

    private void epa() {
        popMsg();
        if (System.getProperty("TLA-StackTrace", "off").equals("on"))
            ToolIO.out.println("Ending " + msgStack[msgStackCurrentSize]);
        Assert.check(popHeir(), EC.SANY_PARSER_CHECK_2);
        // "Assertion error in epa()"
        expecting = emptyString;
    }

    private void addDependency(final UniqueString s) {
        final int lvi = internals.search(s);
        if (lvi < 0)
            dependencyList.add(s);
    }

    private UniqueString reduceString(final String s) {
        final int l = s.length();
        final StringBuilder copy = new StringBuilder(l);
        int i = 0;
        int j = 0;
        while (i != l) {
            if (s.charAt(i) == '\\') {
                i++;
                final char c = s.charAt(i);
                if (c == '\\') copy.append('\\');
                else if (c == 'n') copy.append('\n');
                else if (c == 'r') copy.append('\r');
                else if (c == 'f') copy.append('\f');
                else if (c == 't') copy.append('\t');
                else if (c == '"') copy.append('"');
            } else
                copy.append(s.charAt(i));
            i++;
            j++;
        }
        copy.setLength(j);
        return UniqueString.uniqueStringOf(copy.toString());
    }

    /*************************************************************************
     * The level number of a proof with steps numbered <n>x is n.  The value  *
     * of proofLevelStack[proofDepth] is the level number of the current      *
     * proof.  If we have started processing a proof haven't yet determined   *
     * its level, then proofLevelStack[proofDepth] equals -1.                 *
     *************************************************************************/

    private int levelOfProofStepLexeme(final Token tok) {
        /*************************************************************************
         * The level of a ProofStepLexeme or ProofStepDotLexeme.  It returns -1   *
         * for "*" and -2 for "*".                                                *
         *************************************************************************/
        final String im = tok.image;
        if (im.charAt(1) == '*') {
            return -1;
        }
        if (im.charAt(1) == '+') {
            return -2;
        }
        return Integer.parseInt(im.substring(1, im.indexOf('>')));
        /***********************************************************************
         * The ".intValue()" added by SZ because Java 1.4 doesn't support       *
         * auto-boxing.                                                         *
         ***********************************************************************/
    }

    /***************************************************************************
     * The following method returns the canonical form of the step number       *
     * contained in token t.  This means that a "+" or "*" is replaced by the   *
     * appropriate level number, and leading zeros are removed from a regular   *
     * level number.                                                            *
     ***************************************************************************/
    private UniqueString correctedStepNum(final Token t) {
        String str = t.image;
        if (str.charAt(1) == '*'
                || str.charAt(1) == '+') {
            int level = getProofLevel();
            if ((level < 0) && (proofDepth > 0)) {
                /*********************************************************************
                 * We've started a proof without yet determining the level number.    *
                 * Since this method is being called when encountering a step number  *
                 * token, this means we've encountered a step number inside a BY. So  *
                 * the actual level number to use here is the "previous" level        *
                 * number.                                                            *
                 *********************************************************************/
                level = proofLevelStack[proofDepth - 1];
            }
            str = "<" + level + str.substring(2);
        } else {
            str = "<" + levelOfProofStepLexeme(t) + str.substring(str.indexOf('>'));
        }
        return UniqueString.uniqueStringOf(str);
    }

    private void pushProofLevel() throws ParseException {
        /*************************************************************************
         * Called to begin the processing of a new proof level.  It increments    *
         * proofDepth and sets the proofLevelStack entry to -1.                   *
         *************************************************************************/
        proofDepth++;
        if (proofDepth >= MaxProofDepth) {
            throw new ParseException("Proofs nested more than " +
                    MaxProofDepth + "deep.");
        }
        proofLevelStack[proofDepth] = -1;
    }

    private void popProofLevel() throws ParseException {
        if (proofDepth < 0) {
            throw new ParseException("Parser bug: an extra QED step found.");
        }
        proofDepth--;
    }

    private int getProofLevel() {
        if (proofDepth < 0) {
            return proofDepth;
        }
        return proofLevelStack[proofDepth];
    }

    private void setProofLevel(final int val) throws ParseException {
        if (proofDepth < 0) {
            throw new ParseException("Parser bug: proof step found outside proof.");
        }
        proofLevelStack[proofDepth] = val;
    }

    private boolean beginsProof(final Token tok) {
        /*************************************************************************
         * True iff the token tok begins a new proof--that is, iff it is either   *
         * "BY", "PROOF", a step number that has a higher level than the current  *
         * level, begins "<+>", or begins "<*>" and we are not inside a proof.    *
         *************************************************************************/
        final String im = tok.image;
        if (im.length() < 2) {
            return false;
        }
        /***********************************************************************
         * This can happen if the user makes a weird error.                     *
         ***********************************************************************/
        if (im.charAt(1) == '*') {
            return (proofDepth < 0);
        }

        if (im.charAt(1) == '+') {
            return true;
        }
        switch (tok.kind) {
            case ProofStepLexeme, BareLevelLexeme, UnnumberedStepLexeme, ProofStepDotLexeme -> {
                if (proofDepth < 0) {
                    return true;
                }
                final int tokLevel = levelOfProofStepLexeme(tok);
                return (proofLevelStack[proofDepth] >= 0)
                        && (tokLevel > proofLevelStack[proofDepth]);
            }
            case BY, PROOF, OBVIOUS, OMITTED -> {
                return true;
            }
        }// switch
        return false;
    }

    private boolean correctLevel(final Token tok) {
        /*************************************************************************
         * True iff tok is a correct proof step token for the current level of    *
         * proof, where precedeByPROOF is true iff the proof is preceded by a     *
         * "PROOF" token (needed in case this is the first step of the proof).    *
         * If this is the first step being processed for current proof, then it   *
         * sets the current proof level.                                          *
         *************************************************************************/
        final int tokLevel = levelOfProofStepLexeme(tok);

        /*************************************************************************
         * Set lastDepth to the level of the containing proof, or -1 if this is   *
         * the top-level proof.                                                   *
         *************************************************************************/
        int lastLevel = -1;
        if (proofDepth > 0) {
            lastLevel = proofLevelStack[proofDepth - 1];
        }
        switch (tokLevel) {
            case -1:
                /*********************************************************************
                 * tok is <*>...  This is always legal because it can begin a proof   *
                 * iff it was preceded by a "PROOF".                                  *
                 *********************************************************************/
                if (proofLevelStack[proofDepth] < 0) {
                    proofLevelStack[proofDepth] = lastLevel + 1;
                }
                return true;

            case -2:
                /*********************************************************************
                 * tok is <+>...  This is legal iff it begins a proof.                *
                 *********************************************************************/
                if (proofLevelStack[proofDepth] < 0) {
                    proofLevelStack[proofDepth] = lastLevel + 1;
                    return true;
                } else return false;

            default:
                if (proofLevelStack[proofDepth] < 0) {
                    proofLevelStack[proofDepth] = tokLevel;
                    return (tokLevel > lastLevel);
                } else return (proofLevelStack[proofDepth] == tokLevel);
        }
    }

    /* beginning of the grammar productions */
    public final Token PrefixOpToken() throws ParseException {
        final Token t;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case op_26 -> t = jj_consume_token(op_26);
            case op_29 -> t = jj_consume_token(op_29);
            case op_58 -> t = jj_consume_token(op_58);
            case CASESEP -> t = jj_consume_token(CASESEP);
            case op_61 -> t = jj_consume_token(op_61);
            case op_112 -> t = jj_consume_token(op_112);
            case op_113 -> t = jj_consume_token(op_113);
            case op_114 -> t = jj_consume_token(op_114);
            case op_115 -> t = jj_consume_token(op_115);
            case op_116 -> t = jj_consume_token(op_116);
            default -> {
                jj_la1[0] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
            }
        }
        {
            if (true) return t;
        }
        throw new Error("Missing return statement in function");
    }

    /***************************************************************************
     * NEPrefixOpToken and PrefixOpToken differ because the first includes      *
     * "-." while the second contains does not.  Neither includes "-".          *
     ***************************************************************************/
    public final Token NEPrefixOpToken() throws ParseException {
        final Token t;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case op_26 -> t = jj_consume_token(op_26);
            case op_29 -> t = jj_consume_token(op_29);
            case op_58 -> t = jj_consume_token(op_58);
            case CASESEP -> t = jj_consume_token(CASESEP);
            case op_61 -> t = jj_consume_token(op_61);
            case op_76 -> t = jj_consume_token(op_76);
            case op_112 -> t = jj_consume_token(op_112);
            case op_113 -> t = jj_consume_token(op_113);
            case op_114 -> t = jj_consume_token(op_114);
            case op_115 -> t = jj_consume_token(op_115);
            case op_116 -> t = jj_consume_token(op_116);
            default -> {
                jj_la1[1] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
            }
        }
        {
            if (true) return t;
        }
        throw new Error("Missing return statement in function");
    }

    public final Token InfixOpToken() throws ParseException {
        final Token t;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case op_1 -> t = jj_consume_token(op_1);
            case AND -> t = jj_consume_token(AND);
            case op_3 -> t = jj_consume_token(op_3);
            case op_4 -> t = jj_consume_token(op_4);
            case OR -> t = jj_consume_token(OR);
            case op_6 -> t = jj_consume_token(op_6);
            case op_7 -> t = jj_consume_token(op_7);
            case op_8 -> t = jj_consume_token(op_8);
            case op_9 -> t = jj_consume_token(op_9);
            case op_10 -> t = jj_consume_token(op_10);
            case op_11 -> t = jj_consume_token(op_11);
            case op_12 -> t = jj_consume_token(op_12);
            case op_13 -> t = jj_consume_token(op_13);
            case op_14 -> t = jj_consume_token(op_14);
            case op_15 -> t = jj_consume_token(op_15);
            case op_16 -> t = jj_consume_token(op_16);
            case op_17 -> t = jj_consume_token(op_17);
            case op_18 -> t = jj_consume_token(op_18);
            case op_19 -> t = jj_consume_token(op_19);
            case IN -> t = jj_consume_token(IN);
            case op_21 -> t = jj_consume_token(op_21);
            case op_22 -> t = jj_consume_token(op_22);
            case op_23 -> t = jj_consume_token(op_23);
            case op_24 -> t = jj_consume_token(op_24);
            case op_25 -> t = jj_consume_token(op_25);
            case op_27 -> t = jj_consume_token(op_27);
            case op_30 -> t = jj_consume_token(op_30);
            case op_31 -> t = jj_consume_token(op_31);
            case op_32 -> t = jj_consume_token(op_32);
            case op_33 -> t = jj_consume_token(op_33);
            case op_34 -> t = jj_consume_token(op_34);
            case op_35 -> t = jj_consume_token(op_35);
            case op_36 -> t = jj_consume_token(op_36);
            case op_37 -> t = jj_consume_token(op_37);
            case op_38 -> t = jj_consume_token(op_38);
            case op_39 -> t = jj_consume_token(op_39);
            case op_40 -> t = jj_consume_token(op_40);
            case op_41 -> t = jj_consume_token(op_41);
            case op_42 -> t = jj_consume_token(op_42);
            case op_43 -> t = jj_consume_token(op_43);
            case op_44 -> t = jj_consume_token(op_44);
            case op_45 -> t = jj_consume_token(op_45);
            case op_46 -> t = jj_consume_token(op_46);
            case op_47 -> t = jj_consume_token(op_47);
            case op_48 -> t = jj_consume_token(op_48);
            case op_49 -> t = jj_consume_token(op_49);
            case op_50 -> t = jj_consume_token(op_50);
            case op_51 -> t = jj_consume_token(op_51);
            case op_52 -> t = jj_consume_token(op_52);
            case op_53 -> t = jj_consume_token(op_53);
            case op_54 -> t = jj_consume_token(op_54);
            case op_55 -> t = jj_consume_token(op_55);
            case op_56 -> t = jj_consume_token(op_56);
            case op_59 -> t = jj_consume_token(op_59);
            case op_62 -> t = jj_consume_token(op_62);
            case op_63 -> t = jj_consume_token(op_63);
            case op_64 -> t = jj_consume_token(op_64);
            case EQUALS -> t = jj_consume_token(EQUALS);
            case op_66 -> t = jj_consume_token(op_66);
            case op_67 -> t = jj_consume_token(op_67);
            case op_71 -> t = jj_consume_token(op_71);
            case op_72 -> t = jj_consume_token(op_72);
            case op_73 -> t = jj_consume_token(op_73);
            case op_74 -> t = jj_consume_token(op_74);
            case op_75 -> t = jj_consume_token(op_75);
            case op_77 -> t = jj_consume_token(op_77);
            case op_78 -> t = jj_consume_token(op_78);
            case op_79 -> t = jj_consume_token(op_79);
            case op_80 -> t = jj_consume_token(op_80);
            case op_81 -> t = jj_consume_token(op_81);
            case op_82 -> t = jj_consume_token(op_82);
            case op_83 -> t = jj_consume_token(op_83);
            case op_84 -> t = jj_consume_token(op_84);
            case op_85 -> t = jj_consume_token(op_85);
            case op_86 -> t = jj_consume_token(op_86);
            case op_87 -> t = jj_consume_token(op_87);
            case op_88 -> t = jj_consume_token(op_88);
            case op_89 -> t = jj_consume_token(op_89);
            case op_90 -> t = jj_consume_token(op_90);
            case op_91 -> t = jj_consume_token(op_91);
            case op_92 -> t = jj_consume_token(op_92);
            case op_93 -> t = jj_consume_token(op_93);
            case op_94 -> t = jj_consume_token(op_94);
            case op_95 -> t = jj_consume_token(op_95);
            case op_96 -> t = jj_consume_token(op_96);
            case op_97 -> t = jj_consume_token(op_97);
            case op_98 -> t = jj_consume_token(op_98);
            case op_100 -> t = jj_consume_token(op_100);
            case op_101 -> t = jj_consume_token(op_101);
            case op_102 -> t = jj_consume_token(op_102);
            case op_103 -> t = jj_consume_token(op_103);
            case op_104 -> t = jj_consume_token(op_104);
            case op_105 -> t = jj_consume_token(op_105);
            case op_106 -> t = jj_consume_token(op_106);
            case op_107 -> t = jj_consume_token(op_107);
            case op_108 -> t = jj_consume_token(op_108);
            case op_109 -> t = jj_consume_token(op_109);
            case op_110 -> t = jj_consume_token(op_110);
            case op_111 -> t = jj_consume_token(op_111);
            case op_117 -> t = jj_consume_token(op_117);
            case op_118 -> t = jj_consume_token(op_118);
            case op_119 -> t = jj_consume_token(op_119);
            default -> {
                jj_la1[2] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
            }
        }
        {
            if (true) return t;
        }
        throw new Error("Missing return statement in function");
    }

    public final Token PostfixOpToken() throws ParseException {
        final Token t;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case op_57 -> t = jj_consume_token(op_57);
            case op_68 -> t = jj_consume_token(op_68);
            case op_69 -> t = jj_consume_token(op_69);
            case op_70 -> t = jj_consume_token(op_70);
            default -> {
                jj_la1[3] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
            }
        }
        {
            if (true) return t;
        }
        throw new Error("Missing return statement in function");
    }

// NumberedAssumeProve() commented out 5 Mar 2007 by LL
// number . sequence
// SyntaxTreeNode
// NumberedAssumeProve () : {
//   SyntaxTreeNode tn;
//   Token t;
//   boolean b = false;
//   bpa("Numbered Assume-Prove");
// }{
//   [ LOOKAHEAD(2)
//     t = <NUMBER_LITERAL>  { addHeir( new SyntaxTreeNode(mn, t) );
// expecting = "."; }
//     t = <DOT> {
//       BStack.newReference(t.endColumn, ASSUME); b = true;
//       addHeir( new SyntaxTreeNode(mn, t) );
// expecting = "Assume-Prove, Assume-Decl or expression"; } ]
//   ( tn = AssumeProve()
//   | LOOKAHEAD( { IsNotExpression() } ) tn = AssumeDecl()
//   | tn = Expression() ) /* XXX parser confusion here !!! */
//   { if (b) BStack.popReference();
//     addHeir(tn);
//     SyntaxTreeNode sn[] = getLastHeirs();
//     epa(); return new SyntaxTreeNode( mn, N_NumberedAssumeProve, sn); }
// }

    public final SyntaxTreeNode CompilationUnit() throws ParseException {
        final SyntaxTreeNode tempASTN;
        belchDEF();
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case BEGIN_PRAGMA -> Prelude();
            default -> jj_la1[4] = jj_gen;
        }
        tempASTN = Module();
        token_source.SwitchTo(0);
        {
            if (true) return tempASTN;
        }
        throw new Error("Missing return statement in function");
    }

    /* SwitchTo is used to reset the state of the tokenizer */
    public final void Prelude() throws ParseException {
        jj_consume_token(BEGIN_PRAGMA);
        label_1:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case NUMBER:
                case IDENTIFIER:
                    break;
                default:
                    jj_la1[5] = jj_gen;
                    break label_1;
            }
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case NUMBER -> jj_consume_token(NUMBER);
                case IDENTIFIER -> jj_consume_token(IDENTIFIER);
                default -> {
                    jj_la1[6] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
                }
            }
        }
    }

    public final SyntaxTreeNode Module() throws ParseException {
        Token t;
        final SyntaxTreeNode[] lSTN = new SyntaxTreeNode[4];
        bpa("Module definition");
        internals.push(null);
        Object pop;
        expecting = "---- MODULE";
        lSTN[0] = BeginModule();
        expecting = "EXTENDS clause or module body";
        lSTN[1] = Extends();
        expecting = "Module body";
        lSTN[2] = Body();
        expecting = "==== or more Module body";
        lSTN[3] = EndModule();
        do {
            pop = internals.pop();
        } while (pop != null);
        internals.push(lSTN[0].zero[1].image);
        epa();
        {
            if (true) return new SyntaxTreeNode(mn, N_Module, lSTN);
        }
        throw new Error("Missing return statement in function");
    }

    public final SyntaxTreeNode BeginModule() throws ParseException {
        final SyntaxTreeNode[] lSTN = new SyntaxTreeNode[3];
        Token t;
        bpa("Begin module");
        expecting = "---- MODULE (beginning of module)";
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case _BM0 -> t = jj_consume_token(_BM0);
            case _BM1 -> t = jj_consume_token(_BM1);
            case _BM2 -> t = jj_consume_token(_BM2);
            default -> {
                jj_la1[7] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
            }
        }
        lSTN[0] = new SyntaxTreeNode(mn, t);
        expecting = "Identifier";
        t = getToken(1);
        if (isFieldNameToken(t)) t.kind = IDENTIFIER;
        lSTN[1] = Identifier();
        if (mn == null) mn = lSTN[1].image;
        expecting = "----";
        t = jj_consume_token(SEPARATOR);
        lSTN[2] = new SyntaxTreeNode(mn, t);
        epa();
        {
            if (true) return new SyntaxTreeNode(mn, N_BeginModule, lSTN);
        }
        throw new Error("Missing return statement in function");
    }

    public final SyntaxTreeNode EndModule() throws ParseException {
        final SyntaxTreeNode[] lSTN = new SyntaxTreeNode[1];
        final Token t;
        t = jj_consume_token(END_MODULE);
        lSTN[0] = new SyntaxTreeNode(mn, t);
        {
            if (true) return new SyntaxTreeNode(mn, N_EndModule, lSTN);
        }
        throw new Error("Missing return statement in function");
    }

    public final SyntaxTreeNode Extends() throws ParseException {
        SyntaxTreeNode tn;
        Token t;
        bpa("Extends");
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case EXTENDS -> {
                t = jj_consume_token(EXTENDS);
                addHeir(new SyntaxTreeNode(mn, t));
                expecting = "Identifier";
                t = getToken(1);
                if (isFieldNameToken(t)) t.kind = IDENTIFIER;
                tn = Identifier();
                addDependency(tn.image);
                addHeir(tn);
                expecting = "comma or module body";
                label_2:
                while (true) {
                    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                        case COMMA:
                            break;
                        default:
                            jj_la1[8] = jj_gen;
                            break label_2;
                    }
                    t = jj_consume_token(COMMA);
                    addHeir(new SyntaxTreeNode(mn, t));
                    expecting = "Identifier";
                    t = getToken(1);
                    if (isFieldNameToken(t)) t.kind = IDENTIFIER;
                    tn = Identifier();
                    addDependency(tn.image);
                    addHeir(tn);
                }
            }
            default -> jj_la1[9] = jj_gen;
        }
        final SyntaxTreeNode[] sn = getLastHeirs();
        epa();
        {
            if (true) return new SyntaxTreeNode(mn, N_Extends, sn);
        }
        throw new Error("Missing return statement in function");
    }

    public final SyntaxTreeNode Body() throws ParseException {
        SyntaxTreeNode tn;
        final SyntaxTreeNode[] sn;
        Token t;
        bpa("Module body");
        expecting = "LOCAL, INSTANCE, PROOF, ASSUMPTION, THEOREM, " +
                "RECURSIVE, declaration, or definition";
        label_3:
        while (true) {
            if (jj_2_1(1)) {
            } else {
                break;
            }
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case SEPARATOR -> {
                    t = jj_consume_token(SEPARATOR);
                    tn = new SyntaxTreeNode(mn, t);
                }
                case VARIABLE -> tn = VariableDeclaration();
                case CONSTANT -> tn = ParamDeclaration();
                default -> {
                    jj_la1[10] = jj_gen;
                    if (jj_2_2(2)) {
                        tn = OperatorOrFunctionDefinition();
                    } else {
                        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                            case RECURSIVE -> tn = Recursive();
                            default -> {
                                jj_la1[11] = jj_gen;
                                if (jj_2_3(2)) {
                                    tn = Instance();
                                } else if (jj_2_4(2)) {
                                    tn = Assumption();
                                } else if (jj_2_5(2)) {
                                    tn = Theorem();
                                } else {
                                    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                                        case _BM1, _BM2, _BM0 -> {
                                            tn = Module();
                                            belchDEF();
                                        }
                                        default -> {
                                            jj_la1[12] = jj_gen;
                                            if ((getToken(1).kind == USE && getToken(2).kind != ONLY)
                                                    || (getToken(1).kind == HIDE)) {
                                                tn = UseOrHideOrBy();
                                            } else {
                                                jj_consume_token(-1);
                                                throw new ParseException();
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            addHeir(tn);
        }
        sn = getLastHeirs();
        epa();
        {
            if (true) return new SyntaxTreeNode(mn, N_Body, sn);
        }
        throw new Error("Missing return statement in function");
    }

    public final SyntaxTreeNode VariableDeclaration() throws ParseException {
        SyntaxTreeNode tn;
        final SyntaxTreeNode[] sn;
        Token t;
        final SyntaxTreeNode[] lSTN = new SyntaxTreeNode[1];
        bpa("variable declaration");
        t = jj_consume_token(VARIABLE);
        lSTN[0] = new SyntaxTreeNode(mn, t);
        expecting = "Identifier";
        tn = Identifier();
        addHeir(tn);
        expecting = "comma or module body";
        label_4:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case COMMA:
                    break;
                default:
                    jj_la1[13] = jj_gen;
                    break label_4;
            }
            t = jj_consume_token(COMMA);
            addHeir(new SyntaxTreeNode(mn, t));
            expecting = "Identifier";
            tn = Identifier();
            addHeir(tn);
        }
        sn = getLastHeirs();
        epa();
        {
            if (true) return new SyntaxTreeNode(mn, N_VariableDeclaration, lSTN, sn);
        }
        throw new Error("Missing return statement in function");
    }

    public final SyntaxTreeNode ParamDeclaration() throws ParseException {
        SyntaxTreeNode tn;
        final SyntaxTreeNode[] sn;
        Token t;
        bpa("Parameter declaration");
        expecting = TLAConstants.KeyWords.CONSTANT;
        tn = ParamSubDecl();
        addHeir(tn);
        expecting = "Identifier, operator or _";
        tn = ConstantDeclarationItems();
        addHeir(tn);
        expecting = ",";
        label_5:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case COMMA:
                    break;
                default:
                    jj_la1[14] = jj_gen;
                    break label_5;
            }
            t = jj_consume_token(COMMA);
            addHeir(new SyntaxTreeNode(mn, t));
            expecting = "Identifier, operator or _";
            tn = ConstantDeclarationItems();
            addHeir(tn);
        }
        sn = getLastHeirs();
        epa();
        {
            if (true) return new SyntaxTreeNode(mn, N_ParamDeclaration, sn);
        }
        throw new Error("Missing return statement in function");
    }

    /***************************************************************************
     * Used to allow "STATE FUNCTION", "TEMPORAL", etc.                         *
     ***************************************************************************/
    public final SyntaxTreeNode ParamSubDecl() throws ParseException {
        final SyntaxTreeNode tn;
        final SyntaxTreeNode[] sn;
        final Token t;
        Token u;
        bpa("Parameter declaration item");
        t = jj_consume_token(CONSTANT);
        sn = new SyntaxTreeNode[1];
        sn[0] = new SyntaxTreeNode(mn, t);
        tn = new SyntaxTreeNode(mn, N_ConsDecl, sn);
        epa();
        {
            if (true) return tn;
        }
        throw new Error("Missing return statement in function");
    }

    /***************************************************************************
     * Recursive ::= <CONSTANT> ConstantDeclarationItems                        *
     *                 ( <COMMA> ConstantDeclarationItems )*                    *
     *                                                                          *
     * Produces an N_Recursive node.                                            *
     ***************************************************************************/
    public final SyntaxTreeNode Recursive() throws ParseException {
        SyntaxTreeNode tn;
        final SyntaxTreeNode[] sn;
        Token t;
        bpa("Recursive");
        expecting = "RECURSIVE";
        t = jj_consume_token(RECURSIVE);
        addHeir(new SyntaxTreeNode(mn, t));
        expecting = "Identifier, operator or _";
        tn = ConstantDeclarationItems();
        addHeir(tn);
        expecting = ",";
        label_6:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case COMMA:
                    break;
                default:
                    jj_la1[15] = jj_gen;
                    break label_6;
            }
            t = jj_consume_token(COMMA);
            addHeir(new SyntaxTreeNode(mn, t));
            expecting = "Identifier, operator or _";
            tn = ConstantDeclarationItems();
            addHeir(tn);
            expecting = "`,' or `)'";
        }
        sn = getLastHeirs();
        epa();
        {
            if (true) return new SyntaxTreeNode(mn, N_Recursive, sn);
        }
        throw new Error("Missing return statement in function");
    }

    public final SyntaxTreeNode ConstantDeclarationItems() throws ParseException {
        final SyntaxTreeNode tn;
        final SyntaxTreeNode[] sn;
        final int kind;
        Token t;
        bpa("Constant declaration items");
        expecting = "Identifier, _ or prefix op";
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case IDENTIFIER -> {
                tn = Identifier();
                addHeir(tn);
                kind = N_IdentDecl;
                expecting = "(, comma, or Module Body";
                if (jj_2_6(2)) {
                    /*******************************************************************
                     * The following comment apparently made sense at the time.  I      *
                     * wonder what it should have said.                                 *
                     *                                                                  *
                     * This lookahead was added by J-Ch & LL on 1 Mar 2007 to fix the   *
                     * error when it tried to parse                                     *
                     *                                                                  *
                     *    CONSTANT ASSUME A                                             *
                     *             (B+C)                                                *
                     *    PROVE ...                                                     *
                     *******************************************************************/
                    t = jj_consume_token(LBR);
                    addHeir(new SyntaxTreeNode(mn, t));
                    expecting = "_";
                    t = jj_consume_token(US);
                    addHeir(new SyntaxTreeNode(mn, t));
                    expecting = "comma or )";
                    label_7:
                    while (true) {
                        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                            case COMMA:
                                break;
                            default:
                                jj_la1[16] = jj_gen;
                                break label_7;
                        }
                        t = jj_consume_token(COMMA);
                        addHeir(new SyntaxTreeNode(mn, t));
                        expecting = "_";
                        t = jj_consume_token(US);
                        addHeir(new SyntaxTreeNode(mn, t));
                        expecting = "comma or )";
                    }
                    t = jj_consume_token(RBR);
                    addHeir(new SyntaxTreeNode(mn, t));
                }
            }
            case op_76, op_26, op_29, op_58, CASESEP, op_61, op_112, op_113, op_114, op_115, op_116 -> {
                // LOOKAHEAD( <OpSymbol>, { isPrefixDeclOp( getToken(1) )  } )
                tn = NonExpPrefixOp();
                expecting = "_";
                kind = N_PrefixDecl;
                addHeir(tn);
                t = jj_consume_token(US);
                addHeir(new SyntaxTreeNode(mn, t));
            }
            case US -> {
                t = jj_consume_token(US);
                expecting = "prefix or postfix operator";
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case op_1, AND, op_3, op_4, OR, op_6, op_7, op_8, op_9, op_10, op_11, op_12, op_13, op_14, op_15, op_16, op_17, op_18, op_19, IN, op_21, op_22, op_23, op_24, op_25, op_27, op_30, op_31, op_32, op_33, op_34, op_35, op_36, op_37, op_38, op_39, op_40, op_41, op_42, op_43, op_44, op_45, op_46, op_47, op_48, op_49, op_50, op_51, op_52, op_53, op_54, op_55, op_56, op_59, op_62, op_63, op_64, EQUALS, op_66, op_67, op_71, op_72, op_73, op_74, op_75, op_77, op_78, op_79, op_80, op_81, op_82, op_83, op_84, op_85, op_86, op_87, op_88, op_89, op_90, op_91, op_92, op_93, op_94, op_95, op_96, op_97, op_98, op_100, op_101, op_102, op_103, op_104, op_105, op_106, op_107, op_108, op_109, op_110, op_111, op_117, op_118, op_119 -> {
                        tn = InfixOp();
                        expecting = "_";
                        kind = N_InfixDecl;
                        addHeir(new SyntaxTreeNode(mn, t));
                        addHeir(tn);
                        t = jj_consume_token(US);
                        addHeir(new SyntaxTreeNode(mn, t));
                    }
                    case op_57, op_68, op_69, op_70 -> {
                        tn = PostfixOp();
                        kind = N_PostfixDecl;
                        addHeir(new SyntaxTreeNode(mn, t));
                        addHeir(tn);
                    }
                    default -> {
                        jj_la1[17] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                    }
                }
            }
            default -> {
                jj_la1[18] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
            }
        }
        sn = getLastHeirs();
        epa();
        {
            if (true) return new SyntaxTreeNode(mn, kind, sn);
        }
        throw new Error("Missing return statement in function");
    }

    /***************************************************************************
     * The following production OperatorOrFunctionDefinition() produces an      *
     * N_OperatorDefinition, N_FunctionDefinition, or N_ModuleDefinition        *
     * node.  These nodes have syntax "[LOCAL] ...".  The resulting node n      *
     * has n.zero equal to null if the "LOCAL" is missing and equal to an       *
     * array of length 1 containing the LOCAL token if it is present.  The      *
     * rest of the children/heirs of the node are in the array n.one.           *
     ***************************************************************************/
    public final SyntaxTreeNode OperatorOrFunctionDefinition() throws ParseException {
        SyntaxTreeNode tn;
        SyntaxTreeNode zn = null;
        bpa("Definition");
        int kind;
        String n;
        Token t;
        expecting = "LOCAL, Identifier or Operator Symbol";
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case LOCAL -> {
                t = jj_consume_token(LOCAL);
                zn = new SyntaxTreeNode(mn, t);
            }
            default -> jj_la1[19] = jj_gen;
        }
        t = jj_consume_token(DEFBREAK);
        expecting = "LOCAL, Identifier or Operator Symbol";
        if (jj_2_8(2147483647)) {
            /* recognize function */
            tn = Identifier();
            addHeir(tn);
            kind = N_FunctionDefinition;
            expecting = "[";
            t = jj_consume_token(LSB);
            addHeir(new SyntaxTreeNode(mn, t));
            expecting = "Identifier";
            tn = QuantBound();
            addHeir(tn);
            expecting = "COMMA or ]";
            label_8:
            while (true) {
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case COMMA:
                        break;
                    default:
                        jj_la1[20] = jj_gen;
                        break label_8;
                }
                t = jj_consume_token(COMMA);
                addHeir(new SyntaxTreeNode(mn, t));
                expecting = "Identifier";
                tn = QuantBound();
                addHeir(tn);
            }
            t = jj_consume_token(RSB);
            expecting = "==";
            addHeir(new SyntaxTreeNode(mn, t));
            t = jj_consume_token(DEF);
            belchDEF();
            addHeir(new SyntaxTreeNode(mn, t));
            expecting = "Expression";
            tn = Expression();
            addHeir(tn);
        } else if (jj_2_9(2147483647)) {
            tn = PostfixLHS();
            addHeir(tn);
            expecting = "==";
            t = jj_consume_token(DEF);
            belchDEF();
            kind = N_OperatorDefinition;
            addHeir(new SyntaxTreeNode(mn, t));
            expecting = "Expression";
            tn = Expression();
            addHeir(tn);
        } else if (jj_2_10(2147483647)) {
            tn = InfixLHS();
            addHeir(tn);
            expecting = "==";
            t = jj_consume_token(DEF);
            belchDEF();
            kind = N_OperatorDefinition;
            addHeir(new SyntaxTreeNode(mn, t));
            expecting = "Expression";
            tn = Expression();
            addHeir(tn);
        } else if (jj_2_11(2147483647)) {
            /* recognize operator OR module instance */
            tn = IdentLHS();
            addHeir(tn);
            expecting = "==";
            t = jj_consume_token(DEF);
            belchDEF();
            addHeir(new SyntaxTreeNode(mn, t));
            expecting = "Expression or Instance";
            if (jj_2_7(1)) {
                tn = Expression();
                kind = N_OperatorDefinition;
            } else {
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case INSTANCE -> {
                        tn = Instantiation();
                        kind = N_ModuleDefinition;
                    }
                    default -> {
                        jj_la1[21] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                    }
                }
            }
            addHeir(tn);
        } else {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case op_76, op_26, op_29, op_58, CASESEP, op_61, op_112, op_113, op_114, op_115, op_116 -> {
                    tn = PrefixLHS();
                    addHeir(tn);
                    expecting = "==";
                    t = jj_consume_token(DEF);
                    belchDEF();
                    kind = N_OperatorDefinition;
                    addHeir(new SyntaxTreeNode(mn, t));
                    expecting = "Expression";
                    tn = Expression();
                    addHeir(tn);
                }
                default -> {
                    jj_la1[22] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
                }
            }
        }
        final SyntaxTreeNode[] sn = getLastHeirs();
        epa();
        {
            if (true) return new SyntaxTreeNode(mn, kind, zn, sn);
        }
        throw new Error("Missing return statement in function");
    }

    public final SyntaxTreeNode IdentifierTuple() throws ParseException {
        SyntaxTreeNode tn;
        SyntaxTreeNode[] hn;
        Token t;
        bpa("Identifier tuple");
        t = jj_consume_token(LAB);
        addHeir(new SyntaxTreeNode(mn, t));
        expecting = "Identifier or >>";
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case IDENTIFIER -> {
                tn = Identifier();
                addHeir(tn);
                expecting = "COMMA or >>";
                label_9:
                while (true) {
                    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                        case COMMA:
                            break;
                        default:
                            jj_la1[23] = jj_gen;
                            break label_9;
                    }
                    t = jj_consume_token(COMMA);
                    addHeir(new SyntaxTreeNode(mn, t));
                    expecting = "COMMA or >>";
                    tn = Identifier();
                    addHeir(tn);
                    expecting = "COMMA or >>";
                }
            }
            default -> jj_la1[24] = jj_gen;
        }
        t = jj_consume_token(RAB);
        addHeir(new SyntaxTreeNode(mn, t));
        final SyntaxTreeNode[] sn = getLastHeirs();
        epa();
        {
            if (true) return new SyntaxTreeNode(mn, N_IdentifierTuple, sn);
        }
        throw new Error("Missing return statement in function");
    }

// SyntaxTreeNode
// NumerableStep() : {
// /***************************************************************************
// * Returns an N_NumerableStep node, which has the syntax                    *
// *                                                                          *
// *  ( <ProofStep[Dot]Lexeme> (N_NonExprBody node)                           *
// *   | N_NonExprBody node )                                                 *
// *  ( N_Proof node | N_TerminalProof node)?                                 *
// ***************************************************************************/
//  Token t = null;
//  SyntaxTreeNode tn = null;
//  boolean mayHaveProof = true ;
//  bpa("NumerableStep") ;
//  }{( LOOKAHEAD(2)
//      (t = <ProofStepLexeme> | t = <ProofStepDotLexeme>)
//      { tn = new SyntaxTreeNode(mn, t) ;
//        addHeir(tn);
//        if ((proofDepth > 0) && (proofLevelStack[proofDepth-1] == -1)){
//          throw new ParseException(tn.getLocation() +
//                     ": numbered step inside unnumbered proof.");
//         } ;
//        if (!correctLevel(t)) {
//          throw new ParseException(tn.getLocation() +
//                     ": step number has incorrect level.");
//         } ;
//       }
//      ( (t = <CASE> {addHeir(new SyntaxTreeNode(mn, t)); })?          // XXXX
// //     ^^^^^^^^^^^
// // javacc generates the following warning here:
// //   Choice conflict in [...] construct at line 2700, column 8.
// //   Expansion nested within construct and expansion following construct
// //   have common prefixes, one of which is: "CASE"
// //   Consider using a lookahead of 2 or more for nested expansion.
// //
// // This conflict is between "<1>2.  CASE expr" and
// // "<1>2.  CASE p -> ...".  This is an inherent ambiguity that arises
// // from the use of "CASE" as a keyword here.  Javacc resolves
// // conflicts by choosing the first successful match.  Here, this
// // means that "<1>2.  CASE p -> ..." is parsed as
// //
// //      <ProofStepDotLexeme> <CASE> Expression()
// //
// // causing an error when it tries to parse "-> ..." as an expression.
//
//
//
//        tn = Expression() {addHeir(tn);                               // XXXX
//                           mayHaveProof = true ;}   // XXXX
//       |                                                              // XXXX
//         tn = NonExprBody() {addHeir(tn);
//                             mayHaveProof = nonExprBodyMayHaveProof;}
//       )                                                              // XXXX
//    | t = <CASE> {addHeir(new SyntaxTreeNode(mn, t)); }             // XXXX
//      tn = Expression() {addHeir(tn);                               // XXXX
//                         mayHaveProof = nonExprBodyMayHaveProof;} // XXXX
//
//    | tn = NonExprBody()
//        { addHeir(tn);
//          mayHaveProof = nonExprBodyMayHaveProof;
//          if (getProofLevel() == -2)
//            { setProofLevel(-1) ;
//           }
//          else {
//           if (getProofLevel() != -1) {
//          throw new ParseException(tn.getLocation() +
//                     ": Unnumbered step in numbered proof.");
//             }
//           }
//       }
//   )
//   ( LOOKAHEAD( {mayHaveProof && beginsProof(getToken(1))} )
//      tn = Proof()
//      { addHeir(tn) ; }
//   )?
//   { SyntaxTreeNode sn[] = getLastHeirs();
//     epa();
//     return new SyntaxTreeNode(mn, N_NumerableStep, sn);
//   }
// }

// /***************************************************************************
// * Hack: In addition to returning a node, NonExprBody() needs to return a   *
// * boolean saying whether or not the statement it is returning can have a   *
// * proof.  It does this by setting the field nonExprBodyMayHaveProof.       *
// ***************************************************************************/
// SyntaxTreeNode
// NonExprBody() : {
//  SyntaxTreeNode tn = null;
//  Token t = null;
//  nonExprBodyMayHaveProof = false ;
//  bpa("NonExprBody") ;
// }{ (  LOOKAHEAD(2)
//       (t = <SUFFICES>    { addHeir(new SyntaxTreeNode(mn, t)); }) ?
//       tn = AssumeProve() { addHeir(tn) ;
//                            nonExprBodyMayHaveProof = true;}
//     | LOOKAHEAD(2)
//       ( t = <PROVE> | t = <SUFFICES>)   // | t = <PROOFCASE>
//       { addHeir(new SyntaxTreeNode(mn, t));
//         expecting = "expression";}
//       tn = Expression() { addHeir(tn) ;
//                           nonExprBodyMayHaveProof = true;}
//     | t = <HAVE> { addHeir(new SyntaxTreeNode(mn, t)) ;
//                    expecting = "expression";}
//       tn = Expression() { addHeir(tn) ; }
//     | t = <TAKE> { addHeir(new SyntaxTreeNode(mn, t)) ;
//                    expecting = "identifier";}
//       ( LOOKAHEAD (  <IDENTIFIER> (<COMMA> <IDENTIFIER>)* <IN>
//                    | <LAB>)
//         tn = QuantBound() { addHeir(tn) ;
//                             expecting = "comma or step";}
//         ( t = <COMMA> { addHeir( new SyntaxTreeNode(mn, t) );
//                         expecting = "identifier or tuple of identifiers";}
//           tn = QuantBound() { addHeir(tn) ;
//                               expecting = "comma or proof step";}
//         )*
//       |
//         tn = Identifier() { addHeir(tn) ;
//                              expecting = "comma or proof step";}
//          ( t = <COMMA> { addHeir( new SyntaxTreeNode(mn, t) );
//                           expecting = "identifier";}
//            tn = Identifier() { addHeir(tn) ;
//                                expecting = "comma or proof step";}
//          )*
//       )
//
//     | t = <WITNESS> { addHeir(new SyntaxTreeNode(mn, t)) ;
//                       expecting = "expression";}
//       tn = Expression() { addHeir(tn) ; }
//       /*********************************************************************
//       * Note: The semantic phase must determine if this is expr \in expr,  *
//       * or <<expr, ...  , expr>> \in expr, or just expr.                   *
//       *********************************************************************/
//       ( t = <COMMA> { addHeir( new SyntaxTreeNode(mn, t) );
//                         expecting = "expression";}
//         tn = Expression() { addHeir(tn) ;
//                             expecting = "comma or colon";}
//       )*
//
//     | t = <PICK> { addHeir(new SyntaxTreeNode(mn, t)) ;
//                    expecting = "identifier";}
//       ( LOOKAHEAD ( <IDENTIFIER> ( <COMMA> <IDENTIFIER> )* <COLON> )
//                           /* CommaList Identifier */
//         tn = Identifier() { addHeir(tn) ;
//                              expecting = "comma, or colon";}
//          ( t = <COMMA> { addHeir( new SyntaxTreeNode(mn, t) );
//                           expecting = "identifier";}
//            tn = Identifier() { addHeir(tn) ;
//                                expecting = "comma or colon";}
//          )*
//       |
//         tn = QuantBound() { addHeir(tn) ;
//                             expecting = "comma or colon";}
//         ( t = <COMMA> { addHeir( new SyntaxTreeNode(mn, t) );
//                         expecting = "identifier or tuple of identifiers";}
//           tn = QuantBound() { addHeir(tn) ;
//                               expecting = "comma or colon";}
//         )*
//        )
//        t = <COLON> { addHeir( new SyntaxTreeNode(mn, t) );
//                      expecting = "expression";}
//        tn = Expression() { addHeir(tn) ; }
//        { nonExprBodyMayHaveProof = true;}
//    )
//   { SyntaxTreeNode sn[] = getLastHeirs();
//     epa();
//     return new SyntaxTreeNode(mn, N_NonExprBody, sn);
//   }
// }

    public final SyntaxTreeNode IdentLHS() throws ParseException {
        SyntaxTreeNode tn;
        Token t;
        bpa("Identifier LHS");
        tn = Identifier();
        addHeir(tn);
        expecting = "( or ==";
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case LBR -> {
                t = jj_consume_token(LBR);
                addHeir(new SyntaxTreeNode(mn, t));
                expecting = "Identifier Declaration, prefix op, _ or )";
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case IDENTIFIER -> tn = IdentDecl();
                    case US, op_76, op_26, op_29, op_58, CASESEP, op_61, op_112, op_113, op_114, op_115, op_116 ->
                            tn = SomeFixDecl();
                    default -> {
                        jj_la1[25] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                    }
                }
                addHeir(tn);
                expecting = "COMMA or )";
                label_10:
                while (true) {
                    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                        case COMMA:
                            break;
                        default:
                            jj_la1[26] = jj_gen;
                            break label_10;
                    }
                    t = jj_consume_token(COMMA);
                    addHeir(new SyntaxTreeNode(mn, t));
                    expecting = "Identifier Declaration, prefix op or _";
                    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                        case IDENTIFIER -> tn = IdentDecl();
                        case US, op_76, op_26, op_29, op_58, CASESEP, op_61, op_112, op_113, op_114, op_115, op_116 ->
                                tn = SomeFixDecl();
                        default -> {
                            jj_la1[27] = jj_gen;
                            jj_consume_token(-1);
                            throw new ParseException();
                        }
                    }
                    addHeir(tn);
                    expecting = "COMMA or )";
                }
                t = jj_consume_token(RBR);
                addHeir(new SyntaxTreeNode(mn, t));
            }
            default -> jj_la1[28] = jj_gen;
        }
        final SyntaxTreeNode[] sn = getLastHeirs();
        epa();
        {
            if (true) return new SyntaxTreeNode(mn, N_IdentLHS, sn);
        }
        throw new Error("Missing return statement in function");
    }

    public final SyntaxTreeNode PrefixLHS() throws ParseException {
        final SyntaxTreeNode[] sn = new SyntaxTreeNode[2];
        final SyntaxTreeNode tn;
        final Token t;
        bpa("Prefix LHS");
        t = NEPrefixOpToken();
        sn[0] = new SyntaxTreeNode(mn, t);
        expecting = "Identifier";
        tn = Identifier();
        sn[1] = tn;
        epa();
        {
            if (true) return new SyntaxTreeNode(mn, N_PrefixLHS, sn);
        }
        throw new Error("Missing return statement in function");
    }

    public final SyntaxTreeNode InfixLHS() throws ParseException {
        final SyntaxTreeNode[] sn = new SyntaxTreeNode[3];
        SyntaxTreeNode tn;
        final Token t;
        bpa("Infix LHS");
        tn = Identifier();
        sn[0] = tn;
        t = InfixOpToken();
        sn[1] = new SyntaxTreeNode(mn, t);
        tn = Identifier();
        sn[2] = tn;
        epa();
        {
            if (true) return new SyntaxTreeNode(mn, N_InfixLHS, sn);
        }
        throw new Error("Missing return statement in function");
    }

    public final SyntaxTreeNode PostfixLHS() throws ParseException {
        final SyntaxTreeNode[] sn = new SyntaxTreeNode[2];
        final SyntaxTreeNode tn;
        final Token t;
        bpa("Postfix LHS");
        tn = Identifier();
        sn[0] = tn;
        t = PostfixOpToken();
        sn[1] = new SyntaxTreeNode(mn, t);
        epa();
        {
            if (true) return new SyntaxTreeNode(mn, N_PostfixLHS, sn);
        }
        throw new Error("Missing return statement in function");
    }

    public final SyntaxTreeNode IdentDecl() throws ParseException {
        final SyntaxTreeNode tn;
        Token t;
        bpa("Identifier Declation");
        tn = Identifier();
        addHeir(tn);
        expecting = "( or ...";
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case LBR -> {
                t = jj_consume_token(LBR);
                addHeir(new SyntaxTreeNode(mn, t));
                expecting = "_";
                t = jj_consume_token(US);
                addHeir(new SyntaxTreeNode(mn, t));
                expecting = "COMMA or )";
                label_11:
                while (true) {
                    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                        case COMMA:
                            break;
                        default:
                            jj_la1[29] = jj_gen;
                            break label_11;
                    }
                    t = jj_consume_token(COMMA);
                    addHeir(new SyntaxTreeNode(mn, t));
                    expecting = "_";
                    t = jj_consume_token(US);
                    addHeir(new SyntaxTreeNode(mn, t));
                    expecting = "COMMA or )";
                }
                t = jj_consume_token(RBR);
                addHeir(new SyntaxTreeNode(mn, t));
            }
            default -> jj_la1[30] = jj_gen;
        }
        final SyntaxTreeNode[] sn = getLastHeirs();
        epa();
        {
            if (true) return new SyntaxTreeNode(mn, N_IdentDecl, sn);
        }
        throw new Error("Missing return statement in function");
    }

    public final SyntaxTreeNode SomeFixDecl() throws ParseException {
        final SyntaxTreeNode localASTN = null;
        final SyntaxTreeNode tn;
        SyntaxTreeNode[] sn;
        final int kind;
        Token t;
        final UniqueString n;
        bpa("Op. Symbol Declaration");
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case op_76, op_26, op_29, op_58, CASESEP, op_61, op_112, op_113, op_114, op_115, op_116 -> {
                // LOOKAHEAD( <OpSymbol>, { isPrefixDeclOp( getToken(1) )  } )
                tn = NonExpPrefixOp();
                kind = N_PrefixDecl;
                sn = new SyntaxTreeNode[2];
                sn[0] = tn;
                expecting = "_";
                t = jj_consume_token(US);
                sn[1] = new SyntaxTreeNode(mn, t);
            }
            case US -> {
                t = jj_consume_token(US);
                expecting = "infix or postfix operator";
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case op_1, AND, op_3, op_4, OR, op_6, op_7, op_8, op_9, op_10, op_11, op_12, op_13, op_14, op_15, op_16, op_17, op_18, op_19, IN, op_21, op_22, op_23, op_24, op_25, op_27, op_30, op_31, op_32, op_33, op_34, op_35, op_36, op_37, op_38, op_39, op_40, op_41, op_42, op_43, op_44, op_45, op_46, op_47, op_48, op_49, op_50, op_51, op_52, op_53, op_54, op_55, op_56, op_59, op_62, op_63, op_64, EQUALS, op_66, op_67, op_71, op_72, op_73, op_74, op_75, op_77, op_78, op_79, op_80, op_81, op_82, op_83, op_84, op_85, op_86, op_87, op_88, op_89, op_90, op_91, op_92, op_93, op_94, op_95, op_96, op_97, op_98, op_100, op_101, op_102, op_103, op_104, op_105, op_106, op_107, op_108, op_109, op_110, op_111, op_117, op_118, op_119 -> {
                        tn = InfixOp();
                        kind = N_InfixDecl;
                        sn = new SyntaxTreeNode[3];
                        sn[1] = tn;
                        sn[0] = new SyntaxTreeNode(mn, t);
                        expecting = "_";
                        t = jj_consume_token(US);
                        sn[2] = new SyntaxTreeNode(mn, t);
                    }
                    case op_57, op_68, op_69, op_70 -> {
                        tn = PostfixOp();
                        kind = N_PostfixDecl;
                        sn = new SyntaxTreeNode[2];
                        sn[1] = tn;
                        sn[0] = new SyntaxTreeNode(mn, t);
                    }
                    default -> {
                        jj_la1[31] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                    }
                }
            }
            default -> {
                jj_la1[32] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
            }
        }
        epa();
        {
            if (true) return new SyntaxTreeNode(mn, kind, sn);
        }
        throw new Error("Missing return statement in function");
    }

    public final SyntaxTreeNode Instance() throws ParseException {
        final SyntaxTreeNode tn;
        SyntaxTreeNode zn = null;
        final Token t;
        bpa("Instance");
        expecting = "LOCAL or instance";
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case LOCAL -> {
                t = jj_consume_token(LOCAL);
                zn = new SyntaxTreeNode(mn, t);
            }
            default -> jj_la1[33] = jj_gen;
        }
        tn = Instantiation();
        addHeir(tn);
        expecting = "COMMA or Module Body";
        final SyntaxTreeNode[] sn = getLastHeirs();
        epa();
        {
            if (true) return new SyntaxTreeNode(mn, N_Instance, zn, sn);
        }
        throw new Error("Missing return statement in function");
    }

    public final SyntaxTreeNode Instantiation() throws ParseException {
        SyntaxTreeNode tn;
        Token t;
        bpa("NonLocalInstance");
        t = jj_consume_token(INSTANCE);
        addHeir(new SyntaxTreeNode(mn, t));
        expecting = "Module identifier";
        t = getToken(1);
        if (isFieldNameToken(t)) t.kind = IDENTIFIER;
        tn = Identifier();
        addDependency(tn.image);
        addHeir(tn);
        expecting = "WITH or another definition.";
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case WITH -> {
                t = jj_consume_token(WITH);
                addHeir(new SyntaxTreeNode(mn, t));
                expecting = emptyString;
                tn = Substitution();
                addHeir(tn);
                expecting = emptyString;
                label_12:
                while (true) {
                    if (jj_2_12(3)) {
                    } else {
                        break label_12;
                    }
                    t = jj_consume_token(COMMA);
                    addHeir(new SyntaxTreeNode(mn, t));
                    expecting = emptyString;
                    tn = Substitution();
                    addHeir(tn);
                    expecting = emptyString;
                }
            }
            default -> jj_la1[34] = jj_gen;
        }
        final SyntaxTreeNode[] sn = getLastHeirs();
        epa();
        {
            if (true) return new SyntaxTreeNode(mn, N_NonLocalInstance, sn);
        }
        throw new Error("Missing return statement in function");
    }

    public final SyntaxTreeNode Substitution() throws ParseException {
        final SyntaxTreeNode[] zn = new SyntaxTreeNode[3];
        SyntaxTreeNode tn;
        final Token t;
        anchor = null;
        /***********************************************************************
         * See the comments for the declaration of anchor to see what this is   *
         * being used for.                                                      *
         ***********************************************************************/
        final String n;
        bpa("Substitution");
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case IDENTIFIER -> {
                tn = Identifier();
                zn[0] = tn;
            }
            case op_76, op_26, op_29, op_58, CASESEP, op_61, op_112, op_113, op_114, op_115, op_116 -> {
                tn = NonExpPrefixOp();
                zn[0] = tn;
            }
            case op_1, AND, op_3, op_4, OR, op_6, op_7, op_8, op_9, op_10, op_11, op_12, op_13, op_14, op_15, op_16, op_17, op_18, op_19, IN, op_21, op_22, op_23, op_24, op_25, op_27, op_30, op_31, op_32, op_33, op_34, op_35, op_36, op_37, op_38, op_39, op_40, op_41, op_42, op_43, op_44, op_45, op_46, op_47, op_48, op_49, op_50, op_51, op_52, op_53, op_54, op_55, op_56, op_59, op_62, op_63, op_64, EQUALS, op_66, op_67, op_71, op_72, op_73, op_74, op_75, op_77, op_78, op_79, op_80, op_81, op_82, op_83, op_84, op_85, op_86, op_87, op_88, op_89, op_90, op_91, op_92, op_93, op_94, op_95, op_96, op_97, op_98, op_100, op_101, op_102, op_103, op_104, op_105, op_106, op_107, op_108, op_109, op_110, op_111, op_117, op_118, op_119 -> {
                tn = InfixOp();
                zn[0] = tn;
            }
            case op_57, op_68, op_69, op_70 -> {
                tn = PostfixOp();
                zn[0] = tn;
            }
            default -> {
                jj_la1[35] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
            }
        }
        expecting = "<-";
        t = jj_consume_token(SUBSTITUTE);
        zn[1] = new SyntaxTreeNode(mn, t);
        expecting = "Expression or Op. Symbol";
        tn = OpOrExpr();
        epa();
        zn[2] = tn;
        {
            if (true) return new SyntaxTreeNode(mn, N_Substitution, zn);
        }
        throw new Error("Missing return statement in function");
    }

    public final SyntaxTreeNode PrefixOp() throws ParseException {
        final Token t;
        t = PrefixOpToken();
        lastOp = operators.getOperator(UniqueString.uniqueStringOf(t.image)); // YYY to revise
        {
            if (true) return new SyntaxTreeNode(mn, N_PrefixOp, t);
        }
        throw new Error("Missing return statement in function");
    }

    public final SyntaxTreeNode NonExpPrefixOp() throws ParseException {
        final Token t;
        t = NEPrefixOpToken();
        lastOp = operators.getOperator(UniqueString.uniqueStringOf(t.image)); // YYY to revise
        {
            if (true) return new SyntaxTreeNode(mn, N_NonExpPrefixOp, t);
        }
        throw new Error("Missing return statement in function");
    }

    public final SyntaxTreeNode InfixOp() throws ParseException {
        final Token t;
        bpa("Infix Op");
        t = InfixOpToken();
        lastOp = operators.getOperator(UniqueString.uniqueStringOf(t.image)); // YYY to revise
        epa();
        {
            if (true) return new SyntaxTreeNode(mn, N_InfixOp, t);
        }
        throw new Error("Missing return statement in function");
    }

    // OpSuite

    public final SyntaxTreeNode PostfixOp() throws ParseException {
        final Token t;
        t = PostfixOpToken();
        lastOp = operators.getOperator(UniqueString.uniqueStringOf(t.image)); // YYY to revise
        {
            if (true) return new SyntaxTreeNode(mn, N_PostfixOp, t);
        }
        throw new Error("Missing return statement in function");
    }

    public final SyntaxTreeNode Identifier() throws ParseException {
        final Token t;
        t = jj_consume_token(IDENTIFIER);
        {
            if (true) return new SyntaxTreeNode(mn, t);
        }
        throw new Error("Missing return statement in function");
    }

    /***************************************************************************
     * Assumption ::= ( <ASSUME> | <ASSUMPTION> )                               *
     *                  ( Identifier <DEF> )? Expression                        *
     ***************************************************************************/
    public final SyntaxTreeNode Assumption() throws ParseException {
        SyntaxTreeNode tn;
        final SyntaxTreeNode zn = null;
        Token t;
        bpa("Assumption");
// expecting = "LOCAL or ASSUM...";
        expecting = "ASSUM...";
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case ASSUMPTION -> t = jj_consume_token(ASSUMPTION);
            case ASSUME -> t = jj_consume_token(ASSUME);
            default -> {
                jj_la1[38] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
            }
        }
        addHeir(new SyntaxTreeNode(mn, t));
        if (jj_2_15(2)) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case DEFBREAK -> t = jj_consume_token(DEFBREAK);
                default -> jj_la1[39] = jj_gen;
            }
            /* A DEFBREAK might get added here by belchDEF */
            tn = Identifier();
            addHeir(tn);
            expecting = "==";
            t = jj_consume_token(DEF);
            // belchDEF(); extra belchDEF removed 15 Mar 2007 by LL because it caused
            // an extra <DEFBREAK> to be inserted, producing an error.
            addHeir(new SyntaxTreeNode(mn, t));
        }
        belchDEF();
        expecting = "Expression";
        tn = Expression();
        addHeir(tn);
        final SyntaxTreeNode[] sn = getLastHeirs();
        epa();
        {
            if (true) return new SyntaxTreeNode(mn, N_Assumption, zn, sn);
        }
        throw new Error("Missing return statement in function");
    }

    public final SyntaxTreeNode AssumeProve() throws ParseException {
        /*************************************************************************
         * AssumeProve ::= (<IDENTIFIER> <COLONCOLON>)?                           *
         *                 (<ASSUME> | <BOXASSUME>)                               *
         *                   (AssumeProve | NewDecl | Expression)                 *
         *                 (<COMMA> (AssumeProve  | NewDecl | Expression))+       *
         *                 (<PROVE> | <BOXPROVE>) Expression                      *
         *                                                                        *
         * For ASSUME A1, A2 PROVE B, it constructs an AssumeProve node tn with   *
         * tn.zero equal to the array containing the 6 elements                   *
         *                                                                        *
         *     "ASSUME"  A1  ","  A2  "PROVE"  B                                  *
         *                                                                        *
         * If there is a label "foo::", it returns an N_Label node.               *
         *                                                                        *
         * Changed 18 May 2008 by LL to allow a label.                            *
         *                                                                        *
         * Comment by LL on 25 May 2010: I don't understand this "label"          *
         * business.  Testing shows that an ASSUME/PROVE can't have a label.  I   *
         * have no idea what the code that apparently is looking for a label is   *
         * supposed to do, but it never seems to do anything.                     *
         *                                                                        *
         * The []ASSUME / []PROVE added by LL on 9 Feb 2011.  This grammar        *
         * allows []ASSUME and []PROVE to be used interchangably with ASSUME and  *
         * PROVE. The semantic processing should report an error if []ASSUME is   *
         * used with PROVE and vice-versa.                                        *
         *************************************************************************/
        SyntaxTreeNode tn;
        Token t;
        SyntaxTreeNode[] sn;
        bpa("Assume-Prove");
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case IDENTIFIER -> {
                tn = Identifier();
                /*********************************************************************
                 * The semantic analyzer expects the label name to be a GeneralId     *
                 * node whose first child is an empty N_IdPrefix node and whose       *
                 * second child is the label's Identifier node.                       *
                 *********************************************************************/
                addHeir(new SyntaxTreeNode(
                        mn,
                        N_GeneralId,
                        new SyntaxTreeNode[]{
                                new SyntaxTreeNode(
                                        mn,
                                        N_IdPrefix,
                                        new SyntaxTreeNode[0]),
                                tn}
                ));
                t = jj_consume_token(COLONCOLON);
                addHeir(new SyntaxTreeNode(mn, t));
                tn = AssumeProve();
                addHeir(tn);
                sn = getLastHeirs();
                epa();
                {
                    if (true) return new SyntaxTreeNode(mn, N_Label, sn);
                }
            }
            default -> jj_la1[40] = jj_gen;
        }
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case ASSUME -> t = jj_consume_token(ASSUME);
            case BOXASSUME -> t = jj_consume_token(BOXASSUME);
            default -> {
                jj_la1[41] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
            }
        }
        addHeir(new SyntaxTreeNode(mn, t));
        expecting = "Expression, Declaration, or AssumeProve";
        if ((getToken(1).kind == ASSUME || getToken(1).kind == BOXASSUME)
                || ((getToken(2).kind == COLONCOLON) &&
                (getToken(3).kind == ASSUME || getToken(3).kind == BOXASSUME))) {
            /*****************************************************
             * Check for COLONCOLON added by LL 17 Feb 2009.      *
             *****************************************************/
            tn = AssumeProve();
        } else {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case ACTION, CONSTANT, NEW, STATE, TEMPORAL, VARIABLE -> tn = NewSymb();
                default -> {
                    jj_la1[42] = jj_gen;
                    if (jj_2_16(1)) {
                        tn = Expression();

                    } else {
                        jj_consume_token(-1);
                        throw new ParseException();
                    }
                }
            }
        }
        addHeir(tn);
        expecting = "PROVE or `,'";
        label_13:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case COMMA:
                    break;
                default:
                    jj_la1[43] = jj_gen;
                    break label_13;
            }
            t = jj_consume_token(COMMA);
            addHeir(new SyntaxTreeNode(mn, t));
            expecting = "Expression, Declaration, or AssumeProve";
            if ((getToken(1).kind == ASSUME || getToken(1).kind == BOXASSUME)
                    || ((getToken(2).kind == COLONCOLON) &&
                    (getToken(3).kind == ASSUME || getToken(3).kind == BOXASSUME))) {
                /*****************************************************
                 * Check for COLONCOLON added by LL 17 Feb 2009.      *
                 *****************************************************/
                tn = AssumeProve();
            } else {
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case ACTION, CONSTANT, NEW, STATE, TEMPORAL, VARIABLE -> tn = NewSymb();
                    default -> {
                        jj_la1[44] = jj_gen;
                        if (jj_2_17(1)) {
                            tn = Expression();
                        } else {
                            jj_consume_token(-1);
                            throw new ParseException();
                        }
                    }
                }
            }
            addHeir(tn);
            expecting = "PROVE or `,'";
        }
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case PROVE -> t = jj_consume_token(PROVE);
            case BOXPROVE -> t = jj_consume_token(BOXPROVE);
            default -> {
                jj_la1[45] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
            }
        }
        addHeir(new SyntaxTreeNode(mn, t));
        expecting = "Expression";
        tn = Expression();
        addHeir(tn);
        sn = getLastHeirs();
        epa();
        {
            if (true) return new SyntaxTreeNode(mn, N_AssumeProve, sn);
        }
        throw new Error("Missing return statement in function");
    }

    public final SyntaxTreeNode NewSymb() throws ParseException {
        /*************************************************************************
         * NewSymb ::=   (<NEW> | <CONSTANT> | <NEW> <CONSTANT>)                  *
         *               (Identifier <IN> Expression | IdentDecl | SomeFixDecl)   *
         *              | [<NEW>] <VARIABLE> Identifier                           *
         *              | [<NEW>] (<STATE> | <ACTION> | <TEMPORAL>)               *
         *                (IdentDecl | SomeFixDecl)                               *
         *************************************************************************/
        SyntaxTreeNode tn;
        Token t;
        final boolean hasArgs;
        /***********************************************************************
         * We want to allow "NEW Id \in S" but disallow "NEW Id(_) \in S".      *
         * For simplicity, the we do this by letting javacc accept either, but  *
         * set hasArgs to true in the latter case and report the error when we  *
         * detect the "\in".                                                    *
         ***********************************************************************/
        bpa("NEW symbol declaration");
        expecting = "NEW, CONSTANT, VARIABLE, STATE, ACTION, or TEMPORAL";
        if (jj_2_20(2)) {
            if (jj_2_18(2)) {
                t = jj_consume_token(NEW);
                addHeir(new SyntaxTreeNode(mn, t));
                t = jj_consume_token(CONSTANT);
                addHeir(new SyntaxTreeNode(mn, t));
            } else {
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case NEW -> {
                        t = jj_consume_token(NEW);
                        addHeir(new SyntaxTreeNode(mn, t));
                    }
                    case CONSTANT -> {
                        t = jj_consume_token(CONSTANT);
                        addHeir(new SyntaxTreeNode(mn, t));
                    }
                    default -> {
                        jj_la1[46] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                    }
                }
            }
            expecting = "Constant declaration";
            if (jj_2_19(2)) {
                tn = IdentDecl();
                hasArgs = tn.heirs().length > 1;
                addHeir(tn);
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case IN -> {
                        t = jj_consume_token(IN);
                        if (hasArgs) {
                            {
                                if (true) throw new ParseException(
                                        "declared symbol with arguments before \\in at "
                                                + tn.getLocation());
                            }
                        }
                        addHeir(new SyntaxTreeNode(mn, t));
                        expecting = "Expression";
                        tn = Expression();
                        addHeir(tn);
                    }
                    default -> jj_la1[47] = jj_gen;
                }
            } else {
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case US, op_76, op_26, op_29, op_58, CASESEP, op_61, op_112, op_113, op_114, op_115, op_116 -> {
                        tn = SomeFixDecl();
                        addHeir(tn);
                    }
                    default -> {
                        jj_la1[48] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                    }
                }
            }
        } else if (jj_2_21(2)) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case NEW -> {
                    t = jj_consume_token(NEW);
                    addHeir(new SyntaxTreeNode(mn, t));
                }
                default -> jj_la1[49] = jj_gen;
            }
            t = jj_consume_token(VARIABLE);
            addHeir(new SyntaxTreeNode(mn, t));
            expecting = "Identifier";
            tn = Identifier();
            /**************************************************
             * The semantic processor expects an N_IdentDecl   *
             * node, and doesn't cope with a bare Identifier   *
             * node.                                           *
             **************************************************/
            final SyntaxTreeNode[] sn = new SyntaxTreeNode[1];
            sn[0] = tn;
            addHeir(new SyntaxTreeNode(mn, N_IdentDecl, sn));
        } else if (jj_2_22(2)) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case NEW -> {
                    t = jj_consume_token(NEW);
                    addHeir(new SyntaxTreeNode(mn, t));
                }
                default -> jj_la1[50] = jj_gen;
            }
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case STATE -> t = jj_consume_token(STATE);
                case ACTION -> t = jj_consume_token(ACTION);
                case TEMPORAL -> t = jj_consume_token(TEMPORAL);
                default -> {
                    jj_la1[51] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
                }
            }
            addHeir(new SyntaxTreeNode(mn, t));
            expecting = "Declaration";
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case IDENTIFIER -> {
                    tn = IdentDecl();
                    addHeir(tn);
                }
                case US, op_76, op_26, op_29, op_58, CASESEP, op_61, op_112, op_113, op_114, op_115, op_116 -> {
                    tn = SomeFixDecl();
                    addHeir(tn);
                }
                default -> {
                    jj_la1[52] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
                }
            }
        } else {
            jj_consume_token(-1);
            throw new ParseException();
        }
        final SyntaxTreeNode[] sn = getLastHeirs();
        epa();
        {
            if (true) return new SyntaxTreeNode(mn, N_NewSymb, sn);
        }
        throw new Error("Missing return statement in function");
    }

    // AssumeDecl() commented out 27 March 2007; it seems to be left over
//   from the old proof grammar.
// SyntaxTreeNode
// AssumeDecl () : {
//   SyntaxTreeNode zn[] = null;
//   SyntaxTreeNode tn;
//   Token t;
//   bpa("Assume Decl.");
// }{
//   ( tn = VariableDeclaration() { zn = new SyntaxTreeNode[1]; zn[0] = tn; }
//   | ( tn = ParamDeclaration() {
//         zn = new SyntaxTreeNode[2]; zn[0] = tn;
// expecting = "optional \\in or ..."; }
//       zn[1] = MaybeBound() )
//   | LOOKAHEAD (2) tn = OperatorOrFunctionDefinition() { zn = new SyntaxTreeNode[1]; zn[0] = tn; }
//   | tn = Instance() { zn = new SyntaxTreeNode[1]; zn[0] = tn; } )
//   { epa();
//     return new SyntaxTreeNode( mn, N_AssumeDecl, zn );  }
// }
    public final SyntaxTreeNode MaybeBound() throws ParseException {
        SyntaxTreeNode[] zn = null;
        SyntaxTreeNode tn;
        final Token t;
        bpa("Domain binding");
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case IN -> {
                t = jj_consume_token(IN);
                zn = new SyntaxTreeNode[2];
                zn[0] = new SyntaxTreeNode(mn, t);
                zn[0].setKind(T_IN);
                expecting = "Expression";
                zn[1] = Expression();
            }
            default -> jj_la1[53] = jj_gen;
        }
        epa();
        {
            if (true) return new SyntaxTreeNode(mn, N_MaybeBound, zn);
        }
        throw new Error("Missing return statement in function");
    }

    /***************************************************************************
     * Theorem ::= ( <THEOREM> | <PROPOSITION> )                                *
     *                ( Identifier <DEF> )? ( AssumeProve | Expression )        *
     *                                                                          *
     * Produces a Theorem node tn with tn.zero containing 2 or 4 nodes,         *
     * depending on whether or not the "Identifier <DEF>" is present.           *
     ***************************************************************************/
    public final SyntaxTreeNode Theorem() throws ParseException {
        SyntaxTreeNode tn;
        Token t;
        bpa("Theorem");
        expecting = "THEOREM, PROPOSITION";
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case THEOREM -> t = jj_consume_token(THEOREM);
            case PROPOSITION -> t = jj_consume_token(PROPOSITION);
            default -> {
                jj_la1[54] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
            }
        }
        addHeir(new SyntaxTreeNode(mn, t));
        expecting = "Identifier, Assume-Prove or Expression";
        if (jj_2_23(2)) {
            tn = Identifier();
            addHeir(tn);
            expecting = "==";
            t = jj_consume_token(DEF);
            // belchDEF(); extra belchDEF removed 15 Mar 2007 by LL because it caused
            // an extra <DEFBREAK> to be inserted, producing an error.
            addHeir(new SyntaxTreeNode(mn, t));
        }
        belchDEF();
        if (jj_2_24(3)) {
            if (getToken(1).kind == ASSUME || getToken(1).kind == BOXASSUME) {

            } else {
                jj_consume_token(-1);
                throw new ParseException();
            }
            tn = AssumeProve();
        } else if (jj_2_25(1)) {
            tn = Expression();
        } else {
            jj_consume_token(-1);
            throw new ParseException();
        }
        addHeir(tn);
        if (beginsProof(getToken(1))) {
            tn = Proof();
            addHeir(tn);
        }
        final SyntaxTreeNode[] sn = getLastHeirs();
        epa();
        {
            if (true) return new SyntaxTreeNode(mn, N_Theorem, sn);
        }
        throw new Error("Missing return statement in function");
    }

    /***************************************************************************
     * The Grammar of Proofs                                                    *
     *  XXXXXXX THIS IS OBSOLETE                                                *
     * Proof ::= InnerProof                                                     *
     *   // Proof checks that we're not inside a proof at the end.              *
     *                                                                          *
     * InnerProof ::=                                                           *
     *      TerminalProof                                                       *
     *    | (<PROOF>)?                                                          *
     *      ( Step )* // Terminated by lookahead for "QED"                      *
     *      QEDStep                                                             *
     *                                                                          *
     *   // Note: (InnerProof)? uses lookahead for beginsProof(...)             *
     *                                                                          *
     * TerminalProof ::=    <BY> ...                                            *
     *                    | (<PROOF>)? OBVIOUS                                  *
     * QEDStep ::= (<ProofStepLexeme> | <ProofStepDotLexeme> )?                 *
     *             <QED> (InnerProof)?                                          *
     *                                                                          *
     * Step ::=   N_DefStep                                                     *
     *          | N_UseOrHide                                                   *
     *          | N_NonLocalInstance                                            *
     *          | N_NumerableStep                                               *
     *          | N_QEDStep                                                     *
     *                                                                          *
     * NumerableStep ==    ExprStep                                             *
     *                   | NumberedStep                                         *
     *                   | UnnumberedStep                                       *
     *                                                                          *
     * DefStep ::= (<DEFINE>)? OperatorOrFunctionDefinition                     *
     *                                                                          *
     * NumberedStep ::= (<ProofStepLexeme> | <ProofStepDotLexeme> )             *
     *                  UnnumberedStep                                          *
     *                                                                          *
     * ExprStep ::= (   <PROVE>                                                 *
     *                | <SUFFICES>                                              *
     *                | (<ProofStepLexeme> | <ProofStepDotLexeme> )             *
     *                  (<SUFFICES>)?                                           *
     *              )                                                           *
     *              Expression                                                  *
     *                                                                          *
     * UnnumberedStep ::=                                                       *
     *     Have                                                                 *
     *   | Take                                                                 *
     *   | Witness                                                              *
     *   | (  Pick                                                              *
     *      | (<SUFFICES>)? (AssumeProve | <CASE> Expression)                   *
     *     )                                                                    *
     *     (InnerProof)?                                                        *
     ***************************************************************************/
    public final SyntaxTreeNode Proof() throws ParseException {
/***************************************************************************
 * Returns an N_Proof or N_TerminalProof node.  The heirs of an N_Proof     *
 * node consist of an option PROOF token followed by a seequence of         *
 * N_ProofStep nodes.  The heirs of an N_ProofStep node are a StartStep()   *
 * token, a statement body, and an optional proof.  A statement body is     *
 * one of the following node kinds:                                         *
 *                                                                          *
 *   Have no proof:                                                         *
 *     N_DefStep   N_UseOrHide   N_NonLocalInstance   N_HaveStep,           *
 *     N_TakeStep  N_WitnessStep                                            *
 *                                                                          *
 *   Have a proof                                                           *
 *     N_QEDStep  N_PickStep   N_CaseStep   N_AssertStep                    *
 ***************************************************************************/
        SyntaxTreeNode tn;
        Token t;
        Token t0 = null;
        pushProofLevel();
        bpa("Proof");
        if ((getToken(1).kind == BY) || (getToken(2).kind == BY)) {
            tn = UseOrHideOrBy();
        } else if (jj_2_27(2)) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case PROOF -> t0 = jj_consume_token(PROOF);
                default -> jj_la1[55] = jj_gen;
            }
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case OBVIOUS -> t = jj_consume_token(OBVIOUS);
                case OMITTED -> t = jj_consume_token(OMITTED);
                default -> {
                    jj_la1[56] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
                }
            }
            final SyntaxTreeNode[] sn;
            if (t0 != null) {
                sn = new SyntaxTreeNode[2];
                sn[0] = new SyntaxTreeNode(mn, t0);
                sn[1] = new SyntaxTreeNode(mn, t);
            } else {
                sn = new SyntaxTreeNode[1];
                sn[0] = new SyntaxTreeNode(mn, t);
            }
            tn = new SyntaxTreeNode(mn, N_TerminalProof, sn);
        } else if (jj_2_28(1)) {
            if (jj_2_26(2)) {
                t = jj_consume_token(PROOF);
                addHeir(new SyntaxTreeNode(mn, t));
            }
            label_14:
            while (true) {
                if (getToken(2).kind != QED) {
                } else {
                    break;
                }
                tn = Step();
                addHeir(tn);
                expecting = "a proof step";
            }
            tn = QEDStep();
            addHeir(tn);
            final SyntaxTreeNode[] sn = getLastHeirs();
            tn = new SyntaxTreeNode(mn, N_Proof, sn);
        } else {
            jj_consume_token(-1);
            throw new ParseException();
        }
        epa();
        popProofLevel();
        {
            if (true) return tn;
        }
        throw new Error("Missing return statement in function");
    }

    public final SyntaxTreeNode UseOrHideOrBy() throws ParseException {
/***************************************************************************
 * Returns an N_TerminalProof (for a BY) or N_UseOrHide node.  Having       *
 * one nonterminal that returns both is the only easy way I know to         *
 * avoid having to duplicate the code for handling BY and for handling      *
 * USE/HIDE.  Lookahead should prevent it from being called to parse        *
 * the wrong kind of object.                                                *
 *                                                                          *
 * Note: This production accepts a By, USE, or HIDE with no items.  This    *
 * should be reported by an error in the semantic analysis phase.           *
 ***************************************************************************/
        SyntaxTreeNode tn;
        Token t;
        int kind = N_UseOrHide;
        bpa("UseOrHideOrBy");
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case BY, PROOF -> {
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case PROOF -> {
                        t = jj_consume_token(PROOF);
                        addHeir(new SyntaxTreeNode(mn, t));
                    }
                    default -> jj_la1[57] = jj_gen;
                }
                t = jj_consume_token(BY);
                kind = N_TerminalProof;
                addHeir(new SyntaxTreeNode(mn, t));
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case ONLY -> {
                        t = jj_consume_token(ONLY);
                        addHeir(new SyntaxTreeNode(mn, t));
                    }
                    default -> jj_la1[58] = jj_gen;
                }
            }
            case USE -> {
                t = jj_consume_token(USE);
                addHeir(new SyntaxTreeNode(mn, t));
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case ONLY -> {
                        t = jj_consume_token(ONLY);
                        addHeir(new SyntaxTreeNode(mn, t));
                    }
                    default -> jj_la1[59] = jj_gen;
                }
            }
            case HIDE -> {
                t = jj_consume_token(HIDE);
                addHeir(new SyntaxTreeNode(mn, t));
            }
            default -> {
                jj_la1[60] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
            }
        }
        expecting = "an expression, `MODULE' or `DEF'";
        if (jj_2_31(1)) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case MODULE -> {
                    t = jj_consume_token(MODULE);
                    addHeir(new SyntaxTreeNode(mn, t));
                    expecting = "identifier";
                    tn = Identifier();
                    addHeir(tn);
                }
                default -> {
                    jj_la1[61] = jj_gen;
                    if (jj_2_29(1)) {
                        tn = Expression();
                        addHeir(tn);
                    } else {
                        jj_consume_token(-1);
                        throw new ParseException();
                    }
                }
            }
            label_15:
            while (true) {
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case COMMA:
                        break;
                    default:
                        jj_la1[62] = jj_gen;
                        break label_15;
                }
                t = jj_consume_token(COMMA);
                addHeir(new SyntaxTreeNode(mn, t));
                expecting = "MODULE or expression";
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case MODULE -> {
                        t = jj_consume_token(MODULE);
                        addHeir(new SyntaxTreeNode(mn, t));
                        expecting = "identifier";
                        tn = Identifier();
                        addHeir(tn);
                    }
                    default -> {
                        jj_la1[63] = jj_gen;
                        if (jj_2_30(1)) {
                            tn = Expression();
                            addHeir(tn);
                        } else {
                            jj_consume_token(-1);
                            throw new ParseException();
                        }
                    }
                }
                if (kind == N_TerminalProof) {
                    expecting = "comma, DEF, or [.]";
                } else {
                    expecting = "comma, DEF, or proof step";
                }
            }
        }
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case DF -> {
                t = jj_consume_token(DF);
                addHeir(new SyntaxTreeNode(mn, t));
                expecting = "MODULE or expression";
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case MODULE -> {
                        t = jj_consume_token(MODULE);
                        addHeir(new SyntaxTreeNode(mn, t));
                        expecting = "identifier";
                        tn = Identifier();
                        addHeir(tn);
                    }
                    default -> {
                        jj_la1[64] = jj_gen;
                        if (jj_2_32(1)) {
                            tn = Expression();
                            addHeir(tn);
                        } else {
                            jj_consume_token(-1);
                            throw new ParseException();
                        }
                    }
                }
                label_16:
                while (true) {
                    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                        case COMMA:
                            break;
                        default:
                            jj_la1[65] = jj_gen;
                            break label_16;
                    }
                    t = jj_consume_token(COMMA);
                    addHeir(new SyntaxTreeNode(mn, t));
                    expecting = "MODULE or expression";
                    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                        case MODULE -> {
                            t = jj_consume_token(MODULE);
                            addHeir(new SyntaxTreeNode(mn, t));
                            expecting = "identifier";
                            tn = Identifier();
                            addHeir(tn);
                        }
                        default -> {
                            jj_la1[66] = jj_gen;
                            if (jj_2_33(1)) {
                                tn = Expression();
                                addHeir(tn);
                            } else {
                                jj_consume_token(-1);
                                throw new ParseException();
                            }
                        }
                    }
                    if (kind == N_TerminalProof) {
                        expecting = "comma or [.]";
                    } else {
                        expecting = "comma or proof step";
                    }
                }
            }
            default -> jj_la1[67] = jj_gen;
        }
        if (kind == N_TerminalProof) {
            expecting = "[.]";
        }
        final SyntaxTreeNode[] sn = getLastHeirs();
        epa();
        {
            if (true) return new SyntaxTreeNode(mn, kind, sn);
        }
        throw new Error("Missing return statement in function");
    }

    public final Token StepStartToken() throws ParseException {
        final Token t;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case ProofStepLexeme -> t = jj_consume_token(ProofStepLexeme);
            case ProofImplicitStepLexeme -> t = jj_consume_token(ProofImplicitStepLexeme);
            case ProofStepDotLexeme -> t = jj_consume_token(ProofStepDotLexeme);
            case BareLevelLexeme -> t = jj_consume_token(BareLevelLexeme);
            case UnnumberedStepLexeme -> t = jj_consume_token(UnnumberedStepLexeme);
            default -> {
                jj_la1[68] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
            }
        }
        {
            if (true) return t;
        }
        throw new Error("Missing return statement in function");
    }

    public final SyntaxTreeNode QEDStep() throws ParseException {
/***************************************************************************
 * Returns an N_ProofStep node whose body is an N_QEDStep node.             *
 ***************************************************************************/
        Token t;
        SyntaxTreeNode tn;
        SyntaxTreeNode[] sn;
        final int level = -1;
        bpa("QED step");
        expecting = "Step number";
        t = StepStartToken();
        tn = new SyntaxTreeNode(mn, t);
        if (!correctLevel(t)) {
            {
                if (true) throw new ParseException(tn.getLocation() +
                        ": QED step's number has bad level.");
            }
        }
        if ((t.kind == ProofImplicitStepLexeme)
                || (t.kind == ProofStepLexeme)
                || (t.kind == ProofStepDotLexeme)) {
            tn.originalImage = tn.image;
            tn.image = correctedStepNum(t);
// ToolIO.out.println("correcting " + tn.originalImage) ;
        }

        addHeir(tn);
        expecting = "QED";
        t = jj_consume_token(QED);
        sn = new SyntaxTreeNode[1];
        sn[0] = new SyntaxTreeNode(mn, t);
        addHeir(new SyntaxTreeNode(mn, N_QEDStep, sn));
        if (beginsProof(getToken(1))) {
            tn = Proof();
            addHeir(tn);
        }
        sn = getLastHeirs();
        epa();
        {
            if (true) return new SyntaxTreeNode(mn, N_ProofStep, sn);
        }
        throw new Error("Missing return statement in function");
    }

    public final SyntaxTreeNode Step() throws ParseException {
/***************************************************************************
 * Returns an N_ProofStep node with the following heirs:                    *
 *                                                                          *
 *  - A StepStart() token.                                                  *
 *                                                                          *
 *  - An N_DefStep (for an operator or function def or named                *
 *    instantiation, N_UseOrHide, N_NonLocalInstance, N_HaveStep,           *
 *    N_TakeStep, N_WitnessStep, N_PickStep, N_CaseStep, or                 *
 *    N_AssertStep node.  (An N_AssertStep node has an optional             *
 *    "SUFFICES" followed by an expression or N_AssumeProve node.)          *
 *                                                                          *
 *  - An optional N_Proof or N_TerminalProof node.                          *
 *                                                                          *
 * Note: The grammar accepts a USE or HIDE with no items.  This should      *
 * be reported as an error in the semantic analysis phase.                  *
 ***************************************************************************/
        Token t;
        SyntaxTreeNode tn;
        boolean mayHaveProof = false;
        bpa("Step");
        expecting = "Step number";
        t = StepStartToken();
        tn = new SyntaxTreeNode(mn, t);
        if (!correctLevel(t)) {
            {
                if (true) throw new ParseException(tn.getLocation() +
                        ": step's number has bad level.");
            }
        }
        if ((t.kind == ProofImplicitStepLexeme)
                || (t.kind == ProofStepLexeme)
                || (t.kind == ProofStepDotLexeme)) {
            tn.originalImage = tn.image;
            tn.image = correctedStepNum(t);
        }
        addHeir(tn);
        expecting = "proof step";
        if ((getToken(1).kind == USE) || (getToken(1).kind == HIDE)) {
            tn = UseOrHideOrBy();
            addHeir(tn);
        } else if (getToken(1).kind == INSTANCE) {
            tn = Instantiation();
            addHeir(tn);
        } else if ((getToken(1).kind == DEFBREAK)
                || (getToken(1).kind == DEFINE)) {
            tn = DefStep();
            addHeir(tn);
        } else {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case HAVE -> {
                    tn = HaveStep();
                    addHeir(tn);
                }
                case TAKE -> {
                    tn = TakeStep();
                    addHeir(tn);
                }
                case WITNESS -> {
                    tn = WitnessStep();
                    addHeir(tn);
                }
                case PICK -> {
                    tn = PickStep();
                    addHeir(tn);
                    mayHaveProof = true;
                }
                case CASE -> {
                    tn = CaseStep();
                    addHeir(tn);
                    mayHaveProof = true;
                }
                default -> {
                    jj_la1[69] = jj_gen;
                    if (jj_2_34(1)) {
                        tn = AssertStep();
                        addHeir(tn);
                        mayHaveProof = true;
                    } else {
                        jj_consume_token(-1);
                        throw new ParseException();
                    }
                }
            }
        }
        if (beginsProof(getToken(1))) {
            if (!mayHaveProof) {
                {
                    if (true) throw new ParseException(tn.getLocation() +
                            ": proof of step that does not take a proof.");
                }
            }
            tn = Proof();
            addHeir(tn);
        }
        final SyntaxTreeNode[] sn = getLastHeirs();
        epa();
        {
            if (true) return new SyntaxTreeNode(mn, N_ProofStep, sn);
        }
        throw new Error("Missing return statement in function");
    }

    public final SyntaxTreeNode DefStep() throws ParseException {
/***************************************************************************
 * Returns an N_DefStep node whose heirs begin with an optional <DEFINE>    *
 * followed by a non-empty sequence of nodes returned by                    *
 * OperatorOrFunctionDefinition().                                          *
 ***************************************************************************/
        Token t;
        SyntaxTreeNode tn;
        bpa("DefStep");
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case DEFINE -> {
                t = jj_consume_token(DEFINE);
                addHeir(new SyntaxTreeNode(mn, t));
            }
            default -> jj_la1[70] = jj_gen;
        }
        label_17:
        while (true) {
            tn = OperatorOrFunctionDefinition();
            addHeir(tn);
            if (jj_2_35(2)) {
            } else {
                break;
            }
        }
        final SyntaxTreeNode[] sn = getLastHeirs();
        epa();
        {
            if (true) return new SyntaxTreeNode(mn, N_DefStep, sn);
        }
        throw new Error("Missing return statement in function");
    }

    public final SyntaxTreeNode HaveStep() throws ParseException {
/***************************************************************************
 * Returns an N_HaveStep node whose heirs are a <HAVE> token and an         *
 * expression node.                                                         *
 ***************************************************************************/
        Token t;
        SyntaxTreeNode tn;
        bpa("HaveStep");
        t = jj_consume_token(HAVE);
        addHeir(new SyntaxTreeNode(mn, t));
        expecting = "expression";
        tn = Expression();
        addHeir(tn);
        final SyntaxTreeNode[] sn = getLastHeirs();
        epa();
        {
            if (true) return new SyntaxTreeNode(mn, N_HaveStep, sn);
        }
        throw new Error("Missing return statement in function");
    }

    public final SyntaxTreeNode TakeStep() throws ParseException {
/***************************************************************************
 * Returns an N_TakeStep node whose first heir is a <TAKE> token and whose  *
 * remaining heirs are a sequence of QuantBound() nodes or a sequence of    *
 * identifiers.                                                             *
 ***************************************************************************/
        Token t;
        SyntaxTreeNode tn;
        bpa("TakeStep");
        t = jj_consume_token(TAKE);
        addHeir(new SyntaxTreeNode(mn, t));
        expecting = "identifier";
        if (jj_2_36(2147483647)) {
            tn = QuantBound();
            addHeir(tn);
            expecting = "comma or step";
            label_18:
            while (true) {
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case COMMA:
                        break;
                    default:
                        jj_la1[71] = jj_gen;
                        break label_18;
                }
                t = jj_consume_token(COMMA);
                addHeir(new SyntaxTreeNode(mn, t));
                expecting = "identifier or tuple of identifiers";
                tn = QuantBound();
                addHeir(tn);
                expecting = "comma or proof step";
            }
        } else {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case IDENTIFIER -> {
                    tn = Identifier();
                    addHeir(tn);
                    expecting = "comma or proof step";
                    label_19:
                    while (true) {
                        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                            case COMMA:
                                break;
                            default:
                                jj_la1[72] = jj_gen;
                                break label_19;
                        }
                        t = jj_consume_token(COMMA);
                        addHeir(new SyntaxTreeNode(mn, t));
                        expecting = "identifier";
                        tn = Identifier();
                        addHeir(tn);
                        expecting = "comma or proof step";
                    }
                }
                default -> {
                    jj_la1[73] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
                }
            }
        }
        final SyntaxTreeNode[] sn = getLastHeirs();
        epa();
        {
            if (true) return new SyntaxTreeNode(mn, N_TakeStep, sn);
        }
        throw new Error("Missing return statement in function");
    }

    public final SyntaxTreeNode WitnessStep() throws ParseException {
/***************************************************************************
 * Returns an N_WitnessStep node whose heirs are a <WITNESS> token and a    *
 * sequence of expression nodes.  It's up to later processing to decide if  *
 * those expressions have the form <<expr, ...  , expr>> \in expr,          *
 * expr \in expr, or just expr.                                             *
 ***************************************************************************/
        Token t;
        SyntaxTreeNode tn;
        bpa("WitnessStep");
        t = jj_consume_token(WITNESS);
        addHeir(new SyntaxTreeNode(mn, t));
        expecting = "expression";
        tn = Expression();
        addHeir(tn);
        label_20:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case COMMA:
                    break;
                default:
                    jj_la1[74] = jj_gen;
                    break label_20;
            }
            t = jj_consume_token(COMMA);
            addHeir(new SyntaxTreeNode(mn, t));
            expecting = "expression";
            tn = Expression();
            addHeir(tn);
            expecting = "comma or colon";
        }
        final SyntaxTreeNode[] sn = getLastHeirs();
        epa();
        {
            if (true) return new SyntaxTreeNode(mn, N_WitnessStep, sn);
        }
        throw new Error("Missing return statement in function");
    }

    public final SyntaxTreeNode PickStep() throws ParseException {
/***************************************************************************
 * Returns an N_PickStep node whose heirs are a <PICK> token and an         *
 * expression node.                                                         *
 ***************************************************************************/
        Token t;
        SyntaxTreeNode tn;
        bpa("PickStep");
        t = jj_consume_token(PICK);
        addHeir(new SyntaxTreeNode(mn, t));
        expecting = "identifier";
        if (jj_2_37(2147483647)) {
            /* CommaList Identifier */
            tn = Identifier();
            addHeir(tn);
            expecting = "comma, or colon";
            label_21:
            while (true) {
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case COMMA:
                        break;
                    default:
                        jj_la1[75] = jj_gen;
                        break label_21;
                }
                t = jj_consume_token(COMMA);
                addHeir(new SyntaxTreeNode(mn, t));
                expecting = "identifier";
                tn = Identifier();
                addHeir(tn);
                expecting = "comma or colon";
            }
        } else {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case LAB, IDENTIFIER -> {
                    tn = QuantBound();
                    addHeir(tn);
                    expecting = "comma or colon";
                    label_22:
                    while (true) {
                        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                            case COMMA:
                                break;
                            default:
                                jj_la1[76] = jj_gen;
                                break label_22;
                        }
                        t = jj_consume_token(COMMA);
                        addHeir(new SyntaxTreeNode(mn, t));
                        expecting = "identifier or tuple of identifiers";
                        tn = QuantBound();
                        addHeir(tn);
                        expecting = "comma or colon";
                    }
                }
                default -> {
                    jj_la1[77] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
                }
            }
        }
        t = jj_consume_token(COLON);
        addHeir(new SyntaxTreeNode(mn, t));
        expecting = "expression";
        tn = Expression();
        addHeir(tn);
        final SyntaxTreeNode[] sn = getLastHeirs();
        epa();
        {
            if (true) return new SyntaxTreeNode(mn, N_PickStep, sn);
        }
        throw new Error("Missing return statement in function");
    }

    public final SyntaxTreeNode CaseStep() throws ParseException {
/***************************************************************************
 * Returns an N_CaseStep node whose heirs are a <CASE> token and an         *
 * expression node.                                                         *
 ***************************************************************************/
        Token t;
        SyntaxTreeNode tn;
        bpa("CaseStep");
        t = jj_consume_token(CASE);
        addHeir(new SyntaxTreeNode(mn, t));
        expecting = "expression";
        tn = Expression();
        addHeir(tn);
        final SyntaxTreeNode[] sn = getLastHeirs();
        epa();
        {
            if (true) return new SyntaxTreeNode(mn, N_CaseStep, sn);
        }
        throw new Error("Missing return statement in function");
    }

    public final SyntaxTreeNode AssertStep() throws ParseException {
/***************************************************************************
 * Returns an N_AssertStep node whose heirs are an optional <SUFFICES>      *
 * token and an expression or N_AssumeProve node.                           *
 ***************************************************************************/
        Token t;
        SyntaxTreeNode tn;
        bpa("AssertStep");
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case SUFFICES -> {
                t = jj_consume_token(SUFFICES);
                addHeir(new SyntaxTreeNode(mn, t));
                expecting = "expression or ASSUME/PROVE";
            }
            default -> jj_la1[78] = jj_gen;
        }
        if (jj_2_38(1)) {
            tn = Expression();
        } else if (getToken(1).kind == ASSUME || getToken(1).kind == BOXASSUME) {
            tn = AssumeProve();
        } else {
            jj_consume_token(-1);
            throw new ParseException();
        }
        addHeir(tn);
        final SyntaxTreeNode[] sn = getLastHeirs();
        epa();
        {
            if (true) return new SyntaxTreeNode(mn, N_AssertStep, sn);
        }
        throw new Error("Missing return statement in function");
    }

    public final SyntaxTreeNode IdPrefix() throws ParseException {
        SyntaxTreeNode tn;
        bpa("ID Prefix");
        label_23:
        while (true) {
            if (jj_2_39(2147483647)) {
            } else {
                break;
            }
            tn = IdPrefixElement();
            addHeir(tn);
        }
        final SyntaxTreeNode[] sn = getLastHeirs();
        epa();
        {
            if (true) return new SyntaxTreeNode(mn, N_Proof, sn);
        }
        throw new Error("Missing return statement in function");
    }

    public final SyntaxTreeNode IdPrefixElement() throws ParseException {
        SyntaxTreeNode tn;
        final Token t;
        bpa("ID Prefix Element");
        tn = Identifier();
        addHeir(tn);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case LBR -> {
                tn = OpArgs();
                addHeir(tn);
            }
            default -> jj_la1[79] = jj_gen;
        }
        t = jj_consume_token(BANG);
        addHeir(new SyntaxTreeNode(mn, t));
        final SyntaxTreeNode[] sn = getLastHeirs();
        epa();
        {
            if (true) return new SyntaxTreeNode(mn, N_IdPrefixElement, sn);
        }
        throw new Error("Missing return statement in function");
    }

    public final SyntaxTreeNode ParenthesesExpression() throws ParseException {
        final SyntaxTreeNode tn;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case LBR -> tn = ParenExpr();
            case LBC -> tn = BraceCases();
            case LSB -> tn = SBracketCases();
            case LWB -> tn = SetExcept();
            case LAB -> tn = TupleOrAction();
            case SF, WF -> tn = FairnessExpr();
            default -> {
                jj_la1[80] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
            }
        }
        {
            if (true) return tn;
        }
        throw new Error("Missing return statement in function");
    }

    public final SyntaxTreeNode ClosedExpressionOrOp() throws ParseException {
        final SyntaxTreeNode tn;
        Token t;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case NUMBER_LITERAL, STRING_LITERAL, op_57, op_68, op_69, op_70, op_26, op_29, op_58, CASESEP, op_61, op_112, op_113, op_114, op_115, op_116, op_1, AND, op_3, op_4, OR, op_6, op_7, op_8, op_9, op_10, op_11, op_12, op_13, op_14, op_15, op_16, op_17, op_18, op_19, IN, op_21, op_22, op_23, op_24, op_25, op_27, op_30, op_31, op_32, op_33, op_34, op_35, op_36, op_37, op_38, op_39, op_40, op_41, op_42, op_43, op_44, op_45, op_46, op_47, op_48, op_49, op_50, op_51, op_52, op_53, op_54, op_55, op_56, op_59, op_62, op_63, op_64, EQUALS, op_66, op_67, op_71, op_72, op_73, op_74, op_75, op_77, op_78, op_79, op_80, op_81, op_82, op_83, op_84, op_85, op_86, op_87, op_88, op_89, op_90, op_91, op_92, op_93, op_94, op_95, op_96, op_97, op_98, op_100, op_101, op_102, op_103, op_104, op_105, op_106, op_107, op_108, op_109, op_110, op_111, op_117, op_118, op_119, IDENTIFIER ->
                    tn = ElementaryExpression();
            case SF, WF, LBR, LSB, LWB, LBC, LAB -> tn = ParenthesesExpression();
            default -> {
                jj_la1[81] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
            }
        }
        {
            if (true) return tn;
        }
        throw new Error("Missing return statement in function");
    }

    public final SyntaxTreeNode OpenExpression() throws ParseException {
        final SyntaxTreeNode tn;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case EXISTS, FORALL -> tn = SomeQuant();
            case T_EXISTS, T_FORALL -> tn = SomeTQuant();
            case IF -> tn = IfThenElse();
            case CASE -> tn = Case();
            case LET -> tn = LetIn();
            case CHOOSE -> tn = UnboundOrBoundChoose();
            default -> {
                jj_la1[82] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
            }
        }
        {
            if (true) return tn;
        }
        throw new Error("Missing return statement in function");
    }

    /*
  L.GeneralId, L.OpApplication, L.String, L.Number, L.GenOp...
*/
    public final SyntaxTreeNode ElementaryExpression() throws ParseException {
        final SyntaxTreeNode tn;
        Token t;
        bpa("Elementary expression");
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case op_57, op_68, op_69, op_70, op_26, op_29, op_58, CASESEP, op_61, op_112, op_113, op_114, op_115, op_116, op_1, AND, op_3, op_4, OR, op_6, op_7, op_8, op_9, op_10, op_11, op_12, op_13, op_14, op_15, op_16, op_17, op_18, op_19, IN, op_21, op_22, op_23, op_24, op_25, op_27, op_30, op_31, op_32, op_33, op_34, op_35, op_36, op_37, op_38, op_39, op_40, op_41, op_42, op_43, op_44, op_45, op_46, op_47, op_48, op_49, op_50, op_51, op_52, op_53, op_54, op_55, op_56, op_59, op_62, op_63, op_64, EQUALS, op_66, op_67, op_71, op_72, op_73, op_74, op_75, op_77, op_78, op_79, op_80, op_81, op_82, op_83, op_84, op_85, op_86, op_87, op_88, op_89, op_90, op_91, op_92, op_93, op_94, op_95, op_96, op_97, op_98, op_100, op_101, op_102, op_103, op_104, op_105, op_106, op_107, op_108, op_109, op_110, op_111, op_117, op_118, op_119, IDENTIFIER ->
                    tn = Extension();
            case STRING_LITERAL -> {
                tn = String();
                epa();
            }
            case NUMBER_LITERAL -> {
                tn = Number();
                epa();
            }
            default -> {
                jj_la1[83] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
            }
        }
        {
            if (true) return tn;
        }
        throw new Error("Missing return statement in function");
    }

    public final SyntaxTreeNode String() throws ParseException {
        final SyntaxTreeNode tn;
        final Token t;
        bpa("String");
        t = jj_consume_token(STRING_LITERAL);
        tn = new SyntaxTreeNode(mn, N_String, t);
        tn.image = reduceString(tn.image.toString());
        epa();
        {
            if (true) return tn;
        }
        throw new Error("Missing return statement in function");
    }

    public final SyntaxTreeNode Number() throws ParseException {
        SyntaxTreeNode tn;
        SyntaxTreeNode[] sn = null;
        Token t1;
        final Token t2;
        int kind = N_Number;
        t1 = jj_consume_token(NUMBER_LITERAL);
        if (jj_2_40(2)) {
            t2 = jj_consume_token(DOT);
            kind = N_Real;
            decimalFlag = true;
            sn = new SyntaxTreeNode[3];
            sn[0] = new SyntaxTreeNode(mn, t1);
            sn[1] = new SyntaxTreeNode(mn, t2);
            t1 = jj_consume_token(NUMBER_LITERAL);
            sn[2] = new SyntaxTreeNode(mn, t1);
        }
        if (sn == null) {
            numberFlag = true;
            sn = new SyntaxTreeNode[1];
            sn[0] = new SyntaxTreeNode(mn, t1);
        }
        {
            if (true) return new SyntaxTreeNode(mn, kind, sn);
        }
        throw new Error("Missing return statement in function");
    }

    public final SyntaxTreeNode Extension() throws ParseException {
        SyntaxTreeNode last = null, tid, top = null;
        Token t;
        SyntaxTreeNode[] heirs;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case op_26, op_29, op_58, CASESEP, op_61, op_112, op_113, op_114, op_115, op_116 -> {
                //  LOOKAHEAD( { isPrefixOp( getToken(1) )  } )
                top = PrefixOp();
                heirs = new SyntaxTreeNode[2];
                heirs[0] = new SyntaxTreeNode(mn, N_IdPrefix, getLastHeirs());
                heirs[1] = top;
                last = new SyntaxTreeNode(mn, N_GenPrefixOp, heirs);
                epa();
            }
            case op_1, AND, op_3, op_4, OR, op_6, op_7, op_8, op_9, op_10, op_11, op_12, op_13, op_14, op_15, op_16, op_17, op_18, op_19, IN, op_21, op_22, op_23, op_24, op_25, op_27, op_30, op_31, op_32, op_33, op_34, op_35, op_36, op_37, op_38, op_39, op_40, op_41, op_42, op_43, op_44, op_45, op_46, op_47, op_48, op_49, op_50, op_51, op_52, op_53, op_54, op_55, op_56, op_59, op_62, op_63, op_64, EQUALS, op_66, op_67, op_71, op_72, op_73, op_74, op_75, op_77, op_78, op_79, op_80, op_81, op_82, op_83, op_84, op_85, op_86, op_87, op_88, op_89, op_90, op_91, op_92, op_93, op_94, op_95, op_96, op_97, op_98, op_100, op_101, op_102, op_103, op_104, op_105, op_106, op_107, op_108, op_109, op_110, op_111, op_117, op_118, op_119 -> {
                // LOOKAHEAD( { isInfixOp( getToken(1) )  } )
                top = InfixOp();
                heirs = new SyntaxTreeNode[2];
                heirs[0] = new SyntaxTreeNode(mn, N_IdPrefix, getLastHeirs());
                heirs[1] = top;
                last = new SyntaxTreeNode(mn, N_GenInfixOp, heirs);
                epa();
            }
            case op_57, op_68, op_69, op_70 -> {
                // LOOKAHEAD( { isPostfixOp( getToken(1) )  } )
                top = PostfixOp();
                heirs = new SyntaxTreeNode[2];
                heirs[0] = new SyntaxTreeNode(mn, N_IdPrefix, getLastHeirs());
                heirs[1] = top;
                last = new SyntaxTreeNode(mn, N_GenPostfixOp, heirs);
                epa();
            }
            case IDENTIFIER -> {
                tid = Identifier();
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case LBR -> top = OpArgs();
                    default -> jj_la1[84] = jj_gen;
                }
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case BANG -> {
                        t = jj_consume_token(BANG);
                        if (top == null) {
                            heirs = new SyntaxTreeNode[2];
                            heirs[1] = new SyntaxTreeNode(mn, t);
                        } else {
                            heirs = new SyntaxTreeNode[3];
                            heirs[1] = top;
                            heirs[2] = new SyntaxTreeNode(mn, t);
                        }
                        heirs[0] = tid;
                        final SyntaxTreeNode current = new SyntaxTreeNode(mn, N_IdPrefixElement, heirs);
                        addHeir(current);
                        last = Extension();
                    }
                    default -> jj_la1[85] = jj_gen;
                }
                if (last == null) {
                    if (top == null) {
                        heirs = new SyntaxTreeNode[2];
                        heirs[0] = new SyntaxTreeNode(mn, N_IdPrefix, getLastHeirs());
                        heirs[1] = tid;
                        last = new SyntaxTreeNode(mn, N_GeneralId, heirs);
                    } else {
/* XXX Wrong.
           addHeir( tid );
           tid = new SyntaxTreeNode( mn, N_GeneralId, getLastHeirs() );
*/
                        heirs = new SyntaxTreeNode[2];
                        heirs[0] = new SyntaxTreeNode(mn, N_IdPrefix, getLastHeirs());
                        heirs[1] = tid;
                        tid = new SyntaxTreeNode(mn, N_GeneralId, heirs);

                        heirs = new SyntaxTreeNode[2];
                        heirs[0] = tid;
                        heirs[1] = top;
                        last = new SyntaxTreeNode(mn, N_OpApplication, heirs);
                    }
                    epa();
                }
            }
            default -> {
                jj_la1[86] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
            }
        }
        {
            if (true) return last;
        }
        throw new Error("Missing return statement in function");
    }

    public final SyntaxTreeNode OpArgs() throws ParseException {
        // OpSuite contributes to Heir list.
        SyntaxTreeNode tn;
        Token t;
        bpa("Optional Arguments");
        t = jj_consume_token(LBR);
        addHeir(new SyntaxTreeNode(mn, t));
        OpSuite();
        label_24:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case COMMA:
                    break;
                default:
                    jj_la1[87] = jj_gen;
                    break label_24;
            }
            t = jj_consume_token(COMMA);
            addHeir(new SyntaxTreeNode(mn, t));
            OpSuite();
        }
        t = jj_consume_token(RBR);
        addHeir(new SyntaxTreeNode(mn, t));
        final SyntaxTreeNode[] sn = getLastHeirs();
        epa();
        {
            if (true) return new SyntaxTreeNode(mn, N_OpArgs, sn);
        }
        throw new Error("Missing return statement in function");
    }

    /***************************************************************************
     * OpOrExpr ::=    (NonExpPrefixOp | InfixOp | PostfixOp)                   *
     *                   followed by                                            *
     *                     "," | ")" | <DEFBREAK> | "LOCAL" | "INSTANCE" |      *
     *                     "THEOREM" | "ASSUME" | "ASSUMPTION" |                *
     *                     "CONSTANT" | "VARIABLE" | "RECURSIVE" |              *
     *                    <END_MODULE> | <SEPARATOR> | <BEGIN_MODULE>           *
     *               | Lambda                                                   *
     *               | Expression                                               *
     *                                                                          *
     * This production is called where either an operator or an expression is   *
     * expected--which is either as the argument of an operator or in a         *
     * substitution.  For an expression or an operator argument that's a        *
     * LAMBDA expression, there's no problem.  However, something like Foo!Bar  *
     * could be either an expression or an operator.  In TLA+2, something like  *
     * Foo!+!Bar could only be an operator, while something like                *
     * Foo!+(a,b)!Bar could only be an expression.  However, in order to        *
     * minimize the changes from the TLA+1 parser, we represent both Foo!+!Bar  *
     * and Foo!+(a,b)!Bar as a GeneralId node and leave it to the semantic      *
     * processing to sort things out.  Thus, Foo!+(a,b)!Bar produces the        *
     * folowing tree of SyntaxTreeNode objects:                                 *
     *                                                                          *
     *    N_GeneralId                                                           *
     *    _.N_IdPrefix                                                          *
     *    _._.N_IdPrefixElement                                                 *
     *    _._._.IDENTIFIER "Foo"                                                *
     *    _._._.BANG "!"                                                        *
     *    _._.N_IdPrefixElement                                                 *
     *    _._._.N_InfixOp  +                                                    *
     *    _._._.N_OpArgs                                                        *
     *    _._._._.LBR "("                                                       *
     *    _._._._.whatever a produces                                           *
     *    _._._._.COMMA ","                                                     *
     *    _._._._.whatever b produces                                           *
     *    _._._._.RBR ")"                                                       *
     *    _._._.BANG "!"                                                        *
     *    _.IDENTIFIER "Bar"                                                    *
     *                                                                          *
     * Something like Foo!+(a,b)!Bar(x) producs an N_OpApplication node         *
     * whose first child is the N_GeneralId node above and whose second         *
     * child is an N_OpArgs node.                                               *
     *                                                                          *
     * TLA+2 adds labels and structural operators like "<<" to this kind of     *
     * operator or expression.  A label in such an expression looks just like   *
     * an ordinary identifier.  A structural operator is represented by a       *
     * token with the new kind "N_StructOp".  Such a node is created by         *
     *                                                                          *
     *   new SynaxTreeNode(moduleName, N_StructOp, node)                        *
     *                                                                          *
     * where node is created by either                                          *
     *                                                                          *
     *   new SyntaxTreeNode(moduleName, tok)                                    *
     *                                                                          *
     * where tok is "<<", ">>", "@", or ":", or by                              *
     *                                                                          *
     *    new SynaxTreeNode(moduleName, N_Number, ...)                          *
     *                                                                          *
     * for a <NUMBER_LITERAL> token.                                            *
     *                                                                          *
     * Let OpArgs = (arg_1, ...  , arg_k).  In general, there are three         *
     * interesting classes of expressions of the form e_1!e_2!...!e_n.          *
     *                                                                          *
     * Case 1: e_n = tok OpArgs,                                                *
     *           where tok is an Identifier or an In/Pre/PostfixOp.             *
     *   In this case an OpApplication node is produced with two children:      *
     *   - An N_GeneralId node with children                                    *
     *      - An N_IdPrefixNode with n-1 children consisting N_IdPRefixElement  *
     *        nodes for e_1!, ... , e_n-1!.                                     *
     *      - A node of kind IDENTIFIER, N_PrefixOp, etc. for tok               *
     *   - An N_OpArgs nodes obtained from OpArgs                               *
     *                                                                          *
     * Case 2: e_n = tok                                                        *
     *           where tok is an Identifier or an In/Pre/PostfixOp.             *
     *   In this case, it produces just the N_GeneralId node of Case 1          *
     *                                                                          *
     * Case 3: e_n = OpArgs                                                     *
     *   In this case, a GeneralId node is produced with two children:          *
     *    - The N_IdPrefixNode node produced in cases 1 and 2                   *
     *    - An N_OpArgs node for OpArgs.                                        *
     ***************************************************************************/
    public final SyntaxTreeNode OpOrExpr() throws ParseException {
        /*************************************************************************
         * Used for parsing an operator argument or the right-hand side of a      *
         * substitution, which could be either an operator (like +) or an         *
         * expression (like a+b).                                                 *
         *************************************************************************/
        SyntaxTreeNode tn;
        final int kind;
        if (jj_2_41(2) && (BStack.aboveReference(getToken(1).beginColumn))) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case op_76, op_26, op_29, op_58, CASESEP, op_61, op_112, op_113, op_114, op_115, op_116 -> {
                    tn = NonExpPrefixOp();
                    kind = N_GenNonExpPrefixOp;
                }
                case op_1, AND, op_3, op_4, OR, op_6, op_7, op_8, op_9, op_10, op_11, op_12, op_13, op_14, op_15, op_16, op_17, op_18, op_19, IN, op_21, op_22, op_23, op_24, op_25, op_27, op_30, op_31, op_32, op_33, op_34, op_35, op_36, op_37, op_38, op_39, op_40, op_41, op_42, op_43, op_44, op_45, op_46, op_47, op_48, op_49, op_50, op_51, op_52, op_53, op_54, op_55, op_56, op_59, op_62, op_63, op_64, EQUALS, op_66, op_67, op_71, op_72, op_73, op_74, op_75, op_77, op_78, op_79, op_80, op_81, op_82, op_83, op_84, op_85, op_86, op_87, op_88, op_89, op_90, op_91, op_92, op_93, op_94, op_95, op_96, op_97, op_98, op_100, op_101, op_102, op_103, op_104, op_105, op_106, op_107, op_108, op_109, op_110, op_111, op_117, op_118, op_119 -> {
                    tn = InfixOp();
                    kind = N_GenInfixOp;
                    if ((tn.image == UniqueString.uniqueStringOf("\\X"))
                            || (tn.image == UniqueString.uniqueStringOf("\\times"))) {
                        {
                            if (true) throw new ParseException(
                                    tn.getLocation() +
                                            ": \\X may not be used as an infix operator.");
                        }
                    }
                }
                case op_57, op_68, op_69, op_70 -> {
                    tn = PostfixOp();
                    kind = N_GenPostfixOp;
                }
                default -> {
                    jj_la1[88] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
                }
            }
            final SyntaxTreeNode[] heirs = new SyntaxTreeNode[2];
            heirs[0] = new SyntaxTreeNode(mn, N_IdPrefix, (SyntaxTreeNode[]) null);
            heirs[1] = tn;
            tn = new SyntaxTreeNode(mn, kind, heirs);
        } else if (jj_2_42(2147483647) && (BStack.aboveReference(getToken(1).beginColumn))) {
            /***********************************************************************
             * Need the BStack.aboveReference check to make sure that the LAMBDA    *
             * is properly indented with respect to any enclosing dis/conjunction   *
             * list.  However, without the <LAMBDA>, the lookahead would succeed    *
             * and the next production would be executed even if it shouldn't       *
             * match.                                                               *
             ***********************************************************************/
            tn = Lambda();
        } else if (jj_2_43(1)) {
            tn = Expression();
        } else {
            jj_consume_token(-1);
            throw new ParseException();
        }
        {
            if (true) return tn;
        }
        throw new Error("Missing return statement in function");
    }

    public final void OpSuite() throws ParseException {
        final SyntaxTreeNode tn;
        tn = OpOrExpr();
        addHeir(tn);
    }

    // void /* nodes are linked internally here : no value returned */
// oldOpSuite() : {
//   SyntaxTreeNode tn = null;
//   anchor = null;
//     /***********************************************************************
//     * See the comments for the declaration of anchor to see what this is   *
//     * being used for.                                                      *
//     ***********************************************************************/
//   Token t;
// } {
//   ( /***********************************************************************
//     * This handles the operator argument "-." (token op_76)                *
//     ***********************************************************************/
// // XXXXX -- this won't work with the new expression syntax.
//     t = <op_76> {
//     tn = new SyntaxTreeNode(mn, N_NonExpPrefixOp, t);
//     SyntaxTreeNode heirs[] = new SyntaxTreeNode[2];
//     heirs[0] = new SyntaxTreeNode( mn, N_IdPrefix, ( SyntaxTreeNode []) null );
//     heirs[1] = tn;
//     tn = new SyntaxTreeNode( mn, N_GenNonExpPrefixOp, heirs ); }
//   | LOOKAHEAD( (<AND> | <OR>) (<COMMA>|<RBR>) )
//       tn = InfixOp() {
//         heirs = new SyntaxTreeNode[2];
//         heirs[0] = new SyntaxTreeNode( mn, N_IdPrefix, (SyntaxTreeNode []) null );
//         heirs[1] = tn;
//         tn =  new SyntaxTreeNode( mn, N_GenInfixOp, heirs );
//      }
//   | tn = Lambda()
//   | try {
//       tn = Expression()
//     } catch ( ParseException e ) {
// // ToolIO.out.println("Caught exception (bis)");
// // first things first - restore evaluation stack
//     if ( OperatorStack.isWellReduced() )
//       OperatorStack.popStack();
//     else
//       throw e;
//     /* it wasn't an expression, what was it ? */
//     /* check the nature of the node returned. It can only be a prefixed op. */
//     if ( ( anchor != null )
//        &&(    anchor.isKind( N_GenPrefixOp )
//            || anchor.isKind( N_GenInfixOp )
//            || anchor.isKind( N_GenPostfixOp ) ) ) {tn = anchor; anchor = null;
//       } else {
// // ToolIO.out.println("anchor is " + anchor.toString());
//        throw e;
//       } // end else
//     } // end catch.
// )
//     /* it wasn't an expression, what was it ?  L.GenNonExpPrefixOp | L.GenInfixOp | L.GenPostfixOp */
//     /* check the nature of the node returned . Below Expression, it has to be a prefixed op. */
//   { addHeir( tn ); }
// }
    public final SyntaxTreeNode ParenExpr() throws ParseException {
        final SyntaxTreeNode[] zn = new SyntaxTreeNode[3];
        SyntaxTreeNode tn;
        Token t;
        t = jj_consume_token(LBR);
        zn[0] = new SyntaxTreeNode(mn, t);
        zn[1] = Expression();
        t = jj_consume_token(RBR);
        zn[2] = new SyntaxTreeNode(mn, t);
        {
            if (true) return new SyntaxTreeNode(mn, N_ParenExpr, zn);
        }
        throw new Error("Missing return statement in function");
    }

    public final SyntaxTreeNode SomeQuant() throws ParseException {
        SyntaxTreeNode tn;
        Token t;
        bpa("Quantified form");
        final int kind;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case EXISTS -> t = jj_consume_token(EXISTS);
            case FORALL -> t = jj_consume_token(FORALL);
            default -> {
                jj_la1[89] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
            }
        }
        addHeir(new SyntaxTreeNode(mn, t));
        if (jj_2_44(2147483647)) {
            tn = Identifier();
            kind = N_UnboundQuant;
            addHeir(tn);
            label_25:
            while (true) {
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case COMMA:
                        break;
                    default:
                        jj_la1[90] = jj_gen;
                        break label_25;
                }
                t = jj_consume_token(COMMA);
                addHeir(new SyntaxTreeNode(mn, t));
                tn = Identifier();
                addHeir(tn);
            }
        } else {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case LAB, IDENTIFIER -> {
                    tn = QuantBound();
                    kind = N_BoundQuant;
                    addHeir(tn);
                    label_26:
                    while (true) {
                        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                            case COMMA:
                                break;
                            default:
                                jj_la1[91] = jj_gen;
                                break label_26;
                        }
                        t = jj_consume_token(COMMA);
                        addHeir(new SyntaxTreeNode(mn, t));
                        tn = QuantBound();
                        addHeir(tn);
                    }
                }
                default -> {
                    jj_la1[92] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
                }
            }
        }
        t = jj_consume_token(COLON);
        addHeir(new SyntaxTreeNode(mn, t));
        tn = Expression();
        addHeir(tn);
        final SyntaxTreeNode[] sn = getLastHeirs();
        epa();
        {
            if (true) return new SyntaxTreeNode(mn, kind, sn);
        }
        throw new Error("Missing return statement in function");
    }

// SyntaxTreeNode
// oldExpression() : {
//   /*************************************************************************
//   * The basic production is                                                *
//   *                                                                        *
//   *    Expression ::= (  OpenExpression                                    *
//   *                     | (Junctions                                       *
//   *                         | ClosedExpressionOrOp                         *
//   *                         | <DOT> Identifier                             *
//   *                         | <COLONCOLON> Expression                      *
//   *                        )+                                              *
//   *                        ( OpenExpression )?                             *
//   *                   )                                                    *
//   *************************************************************************/
//   SyntaxTreeNode tn, tn0, tn1, tn2;
//   Token t;
//   OperatorStack.newStack();
// } {
// (
//  LOOKAHEAD(OpenStart(), {BStack.aboveReference( getToken(1).beginColumn) } )
//    tn = OpenExpression() { OperatorStack.pushOnStack( tn, null ); }
// |   (  LOOKAHEAD( /* <BAND> | <BOR> | */ <AND> | <OR>,
// // ^^^
// // Warning 4 -- Eliminated in SANY2
//          { OperatorStack.preInEmptyTop() &&
//            BStack.aboveReference( getToken(1).beginColumn) } )
//        tn = Junctions() { OperatorStack.pushOnStack( tn, null ); }
//      | LOOKAHEAD( {    ClosedStart(getToken(1))
//                    && boxDisc()
//                         /***************************************************
//                        * \equiv                                            *
//                        *   (token is "[]" => it's the temporal operator)   *
//                         ***************************************************/
//                    && BStack.aboveReference(
//                                 getToken(1).beginColumn) })
//        tn = ClosedExpressionOrOp() {
//           anchor = tn; // XXX is this correct ? Why had it disappered ?
//                        // This is the only place where anchor is set it seems.
//           /*****************************************************************
//           * If tn is an operator, push it on the stack and, if it's not    *
//           * the only thing on the stack, then reduce the stack.            *
//           * Otherwise, just push it on the stack.                          *
//           *****************************************************************/
//           if ( isGenOp( tn ) ) {
//             OperatorStack.pushOnStack( tn, lastOp );
//             if (OperatorStack.size() != 1)
//               OperatorStack.reduceStack();
// // else
// // ToolIO.out.println("size of 1");
//           } else OperatorStack.pushOnStack( tn, null );
//         }
//      |
//        t = <DOT> {
//         Token next = getToken(1);
//         if (isFieldNameToken( next )) next.kind = IDENTIFIER;
//        }
//        tn = Identifier()
//        { OperatorStack.reduceRecord(  new SyntaxTreeNode(mn, t) , tn ); }
//      |
//        t = <COLONCOLON> {
//         tn1 = new SyntaxTreeNode(mn, t) ;
//         tn0 = OperatorStack.topOfStack().getNode();
//         if (! isLabel(tn0)) {
//           throw new ParseException("`::' at " + tn1.getLocation().toString()
//                                     + " does not follow a label.") ;
//          } ;
//         OperatorStack.popCurrentTop() ;
//        } // t = <COLONCOLON>
//        tn2 = Expression() {
// // String str = "null" ;
// // if (lastOp != null) { str = lastOp.toString(); } ;
// // ToolIO.out.println("lastOp after parsing labeled expression is: " + str);
//         if (! labelDoesNotChangeParse(tn2, lastOp)) {
//           /*****************************************************************
//           * Note: if tn1 is a prefix, infix, or postfix expression, then   *
//           * I believe (perhaps naively) that lastOp will be its operator.  *
//           *****************************************************************/
//           throw new ParseException(
//              "Removing label at " + tn0.getLocation().toString() +
//              " would change expression parsing.") ;
//           } ;
//         SyntaxTreeNode labelHeirs[] = {tn0, tn1, tn2} ;
//         tn = new SyntaxTreeNode(N_Label, labelHeirs) ;
//         OperatorStack.pushOnStack( tn, null );
//       }
//   )+
//   [ LOOKAHEAD( OpenStart(), {BStack.aboveReference( getToken(1).beginColumn) } )
//     tn = OpenExpression() { OperatorStack.pushOnStack( tn, null ); } ]
// )
//  { tn = OperatorStack.finalReduce();
//    if (tn==null) throw new ParseException( " Couldn't reduce expression stack.");
//    OperatorStack.popStack();
//    return tn; }
// } // Expression()

    public final SyntaxTreeNode SomeTQuant() throws ParseException {
        SyntaxTreeNode tn;
        Token t;
        bpa("Bound Quantified Expression");
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case T_EXISTS -> t = jj_consume_token(T_EXISTS);
            case T_FORALL -> t = jj_consume_token(T_FORALL);
            default -> {
                jj_la1[93] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
            }
        }
        addHeir(new SyntaxTreeNode(mn, t));
        tn = Identifier();
        addHeir(tn);
        label_27:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case COMMA:
                    break;
                default:
                    jj_la1[94] = jj_gen;
                    break label_27;
            }
            t = jj_consume_token(COMMA);
            addHeir(new SyntaxTreeNode(mn, t));
            tn = Identifier();
            addHeir(tn);
        }
        t = jj_consume_token(COLON);
        addHeir(new SyntaxTreeNode(mn, t));
        tn = Expression();
        addHeir(tn);
        final SyntaxTreeNode[] sn = getLastHeirs();
        epa();
        {
            if (true) return new SyntaxTreeNode(mn, N_UnboundQuant, sn);
        }
        throw new Error("Missing return statement in function");
    }

    public final SyntaxTreeNode QuantBound() throws ParseException {
        SyntaxTreeNode tn;
        Token t;
        bpa("Quant Bound");
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case LAB -> {
                tn = IdentifierTuple();
                addHeir(tn);
            }
            case IDENTIFIER -> {
                tn = Identifier();
                addHeir(tn);
                label_28:
                while (true) {
                    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                        case COMMA:
                            break;
                        default:
                            jj_la1[95] = jj_gen;
                            break label_28;
                    }
                    t = jj_consume_token(COMMA);
                    addHeir(new SyntaxTreeNode(mn, t));
                    tn = Identifier();
                    addHeir(tn);
                    expecting = ", or \\in";
                }
            }
            default -> {
                jj_la1[96] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
            }
        }
        t = jj_consume_token(IN);
        tn = new SyntaxTreeNode(mn, t);
        tn.setKind(T_IN);
        addHeir(tn);
        tn = Expression();
        addHeir(tn);
        final SyntaxTreeNode[] sn = getLastHeirs();
        epa();
        {
            if (true) return new SyntaxTreeNode(mn, N_QuantBound, sn);
        }
        throw new Error("Missing return statement in function");
    }

    public final SyntaxTreeNode BraceCases() throws ParseException {
        int kind = N_SetEnumerate; // set by default.
        SyntaxTreeNode tn;
        final SyntaxTreeNode tn_0;
        final SyntaxTreeNode tn_1;
        final SyntaxTreeNode tn_2;
        SyntaxTreeNode htn = null;
        Token t;
        boolean te = false;
        /***********************************************************************
         * The value of te is set in a couple of places, but it is never        *
         * read.  J-Ch hopes it's obsolete.                                     *
         ***********************************************************************/
        bpa("Some { } form");
        t = jj_consume_token(LBC);
        addHeir(new SyntaxTreeNode(mn, t));
        if (jj_2_48(1)) {
            if (matchFcnConst()) {
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case LAB -> tn = IdentifierTuple();
                    case IDENTIFIER -> tn = Identifier();
                    default -> {
                        jj_la1[97] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                    }
                }
                tn_0 = tn;
                expecting = "\\in";
                // At this stage, we need to break since it maybe a MaybeBound or
                // a SubsetOf
                // So we'll hold to the pieces in the meantime.
                t = jj_consume_token(IN);
                tn_1 = new SyntaxTreeNode(mn, t);
                tn_1.setKind(T_IN);
                /*******************************************************************
                 * Changed from tn.setKind(T_IN) by LL on 19 Mar 2007.              *
                 *                                                                  *
                 * Appears to fix bug that caused semantic error on something like  *
                 * {<<m, n>> \in Nat \X Nat : m > 0}.                               *
                 *******************************************************************/

//      addHeir(tn);

                tn_2 = Expression();
//      addHeir( tn );
// need to create a node for a N_InfixExpr. Some reassembly required, but if course it may be for naught.
// This is in case it isn't a N_SubsetOf
                expecting = "':', ',' or '}'";
                final SyntaxTreeNode[] zn = new SyntaxTreeNode[3];
                SyntaxTreeNode[] wn = new SyntaxTreeNode[2];
                wn[0] = new SyntaxTreeNode(mn, N_IdPrefix, new SyntaxTreeNode[0]);
                wn[1] = tn_0;
                zn[0] = new SyntaxTreeNode(mn, N_GeneralId, wn);
                wn = new SyntaxTreeNode[2];
                wn[0] = new SyntaxTreeNode(mn, N_IdPrefix, new SyntaxTreeNode[0]);
                wn[1] = tn_1;
                zn[1] = new SyntaxTreeNode(mn, N_GenInfixOp, wn);
                zn[2] = tn_2;
                htn = new SyntaxTreeNode(mn, N_InfixExpr, zn);
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case COMMA:
                    case COLON:
                        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                            case COLON:
                                t = jj_consume_token(COLON);
                                htn = null; // it was for naught, ignore it later.
                                addHeir(tn_0); // ID
                                addHeir(tn_1); // \\in
                                addHeir(tn_2); // expression
                                addHeir(new SyntaxTreeNode(mn, t));
                                kind = N_SubsetOf;
                                tn = Expression();
                                addHeir(tn);
                                break;
                            case COMMA:
                                label_29:
                                while (true) {
                                    t = jj_consume_token(COMMA);
                                    if (htn != null) {
                                        addHeir(htn);
                                        htn = null;
                                    }
                                    addHeir(new SyntaxTreeNode(mn, t));
                                    tn = Expression();
                                    addHeir(tn);
                                    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                                        case COMMA:
                                            break;
                                        default:
                                            jj_la1[98] = jj_gen;
                                            break label_29;
                                    }
                                }
                                break;
                            default:
                                jj_la1[99] = jj_gen;
                                jj_consume_token(-1);
                                throw new ParseException();
                        }
                        break;
                    default:
                        jj_la1[100] = jj_gen;
                }
            } else if (jj_2_45(2147483647)) {
                tn = Expression();
                addHeir(tn);
                label_30:
                while (true) {
                    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                        case COMMA:
                            break;
                        default:
                            jj_la1[101] = jj_gen;
                            break label_30;
                    }
                    t = jj_consume_token(COMMA);
                    addHeir(new SyntaxTreeNode(mn, t));
                    tn = Expression();
                    addHeir(tn);
                }
            } else if (jj_2_46(2147483647)) {
                kind = N_SetOfAll;
                tn = Expression();
                addHeir(tn);
                t = jj_consume_token(COLON);
                addHeir(new SyntaxTreeNode(mn, t));
                tn = QuantBound();
                addHeir(tn);
                label_31:
                while (true) {
                    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                        case COMMA:
                            break;
                        default:
                            jj_la1[102] = jj_gen;
                            break label_31;
                    }
                    t = jj_consume_token(COMMA);
                    addHeir(new SyntaxTreeNode(mn, t));
                    tn = QuantBound();
                    addHeir(tn);
                }
            } else if (jj_2_47(1)) {
                tn = Expression();
                addHeir(tn);
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case COMMA:
                    case COLON:
                        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                            case COLON:
                                t = jj_consume_token(COLON);
                                kind = N_SetOfAll;
// IF tn is infix expression, with operator IN, we have a pbm for throw new ParseException( "Form {a \in b : c \in d } is forbidden" );

                                /*******************************************************************
                                 * The following code causes an incorrect error on the legal        *
                                 * expression {1 \in x : x \in T}.  It seems to me that this        *
                                 * test should simply be eliminated.  It seems to be based on the   *
                                 * mistaken belief that {x \in S : x \in T} is illegal, when it's   *
                                 * actually an expression of type N_SubsetOf.                       *
                                 *******************************************************************/
                                SyntaxTreeNode[] Hone = (SyntaxTreeNode[]) tn.heirs();
                                if (Hone.length > 1) { // better make sure it's long enough.
                                    Hone = (SyntaxTreeNode[]) Hone[1].heirs(); // second heir of second heir
                                    if (tn.isKind(N_InfixExpr) && Hone[1].getImage().equals("\\in")) {
                                        {
                                            if (true)
                                                throw new ParseException("Form {a \\in b : c \\in d }, at line " + t.beginLine + ", is not allowed");
                                        }
                                    }
                                }
                                addHeir(new SyntaxTreeNode(mn, t));
                                tn = QuantBound();
                                addHeir(tn);
                                label_32:
                                while (true) {
                                    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                                        case COMMA:
                                            break;
                                        default:
                                            jj_la1[103] = jj_gen;
                                            break label_32;
                                    }
                                    t = jj_consume_token(COMMA);
                                    addHeir(new SyntaxTreeNode(mn, t));
                                    tn = QuantBound();
                                    addHeir(tn);
                                }
                                break;
                            case COMMA:
                                label_33:
                                while (true) {
                                    t = jj_consume_token(COMMA);
                                    addHeir(new SyntaxTreeNode(mn, t));
                                    tn = Expression();
                                    addHeir(tn);
                                    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                                        case COMMA:
                                            break;
                                        default:
                                            jj_la1[104] = jj_gen;
                                            break label_33;
                                    }
                                }
                                break;
                            default:
                                jj_la1[105] = jj_gen;
                                jj_consume_token(-1);
                                throw new ParseException();
                        }
                        break;
                    default:
                        jj_la1[106] = jj_gen;
                }
            } else {
                jj_consume_token(-1);
                throw new ParseException();
            }
        }
        t = jj_consume_token(RBC);
        if (htn != null) addHeir(htn);
        addHeir(new SyntaxTreeNode(mn, t));
        final SyntaxTreeNode[] sn = getLastHeirs();
        epa();
        {
            if (true) return new SyntaxTreeNode(mn, kind, sn);
        }
        throw new Error("Missing return statement in function");
    }

    public final SyntaxTreeNode SBracketCases() throws ParseException {
        SyntaxTreeNode tn;
        Token t;
        int kind;
        bpa("Some [] Form");
        t = jj_consume_token(LSB);
        addHeir(new SyntaxTreeNode(mn, t));
        if (matchFcnConst()) {
            // FcnConst - because we use OpSymbol rather than IN, we need to use semantic detection.
            tn = QuantBound();
            kind = N_FcnConst;
            addHeir(tn);
            label_34:
            while (true) {
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case COMMA:
                        break;
                    default:
                        jj_la1[107] = jj_gen;
                        break label_34;
                }
                t = jj_consume_token(COMMA);
                addHeir(new SyntaxTreeNode(mn, t));
                tn = QuantBound();
                addHeir(tn);
            }
            t = jj_consume_token(MAPTO);
            addHeir(new SyntaxTreeNode(mn, t));
            tn = Expression();
            addHeir(tn);
            t = jj_consume_token(RSB);
            addHeir(new SyntaxTreeNode(mn, t));
        } else if (jj_2_49(2147483647)) {
            /* RcdConstructor */
            tn = FieldVal();
            kind = N_RcdConstructor;
            addHeir(tn);
            label_35:
            while (true) {
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case COMMA:
                        break;
                    default:
                        jj_la1[108] = jj_gen;
                        break label_35;
                }
                t = jj_consume_token(COMMA);
                addHeir(new SyntaxTreeNode(mn, t));
                tn = FieldVal();
                addHeir(tn);
            }
            t = jj_consume_token(RSB);
            addHeir(new SyntaxTreeNode(mn, t));
        } else if ((getToken(2).kind == MAPTO) && isFieldNameToken(getToken(1))) {
            getToken(1).kind = IDENTIFIER;
            tn = FieldVal();
            kind = N_RcdConstructor;
            addHeir(tn);
            label_36:
            while (true) {
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case COMMA:
                        break;
                    default:
                        jj_la1[109] = jj_gen;
                        break label_36;
                }
                t = jj_consume_token(COMMA);
                addHeir(new SyntaxTreeNode(mn, t));
                tn = FieldVal();
                addHeir(tn);
            }
            t = jj_consume_token(RSB);
            addHeir(new SyntaxTreeNode(mn, t));
        } else if (jj_2_50(2147483647)) {
            /* SetOfRcds */
            tn = FieldSet();
            kind = N_SetOfRcds;
            addHeir(tn);
            label_37:
            while (true) {
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case COMMA:
                        break;
                    default:
                        jj_la1[110] = jj_gen;
                        break label_37;
                }
                t = jj_consume_token(COMMA);
                addHeir(new SyntaxTreeNode(mn, t));
                tn = FieldSet();
                addHeir(tn);
            }
            t = jj_consume_token(RSB);
            addHeir(new SyntaxTreeNode(mn, t));
        } else if (jj_2_51(1)) {
            tn = Expression();
            addHeir(tn);
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case COMMA, RSB -> {
                    label_38:
                    while (true) {
                        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                            case COMMA:
                                break;
                            default:
                                jj_la1[111] = jj_gen;
                                break label_38;
                        }
                        t = jj_consume_token(COMMA);
                        addHeir(new SyntaxTreeNode(mn, t));
                        tn = Expression();
                        addHeir(tn);
                    }
                    t = jj_consume_token(RSB);
                    addHeir(new SyntaxTreeNode(mn, t));
                    kind = N_FcnAppl;
                    lastOp = FcnOp;
                }
                case ARROW -> {
                    t = jj_consume_token(ARROW);
                    // SetOfFcns
                    kind = N_SetOfFcns;
                    addHeir(new SyntaxTreeNode(mn, t));
                    tn = Expression();
                    addHeir(tn);
                    t = jj_consume_token(RSB);
                    addHeir(new SyntaxTreeNode(mn, t));
                }
                case EXCEPT -> {
                    t = jj_consume_token(EXCEPT);
                    // Except
                    kind = N_Except;
                    addHeir(new SyntaxTreeNode(mn, t));
                    tn = ExceptSpec();
                    addHeir(tn);
                    label_39:
                    while (true) {
                        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                            case COMMA:
                                break;
                            default:
                                jj_la1[112] = jj_gen;
                                break label_39;
                        }
                        t = jj_consume_token(COMMA);
                        addHeir(new SyntaxTreeNode(mn, t));
                        tn = ExceptSpec();
                        addHeir(tn);
                    }
                    t = jj_consume_token(RSB);
                    addHeir(new SyntaxTreeNode(mn, t));
                }
                case ARSB -> {
                    t = jj_consume_token(ARSB);
                    kind = N_ActionExpr;
                    addHeir(new SyntaxTreeNode(mn, t));
                    tn = ReducedExpression();
                    addHeir(tn);
                }
                default -> {
                    jj_la1[113] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
                }
            }
        } else {
            jj_consume_token(-1);
            throw new ParseException();
        }
        final SyntaxTreeNode[] sn = getLastHeirs();
        Assert.check(kind != 0, EC.SANY_PARSER_CHECK_3);
// "Assertion error in SBracketCases()"
        epa();
        {
            if (true) return new SyntaxTreeNode(mn, kind, sn);
        }
        throw new Error("Missing return statement in function");
    }

    public final SyntaxTreeNode FieldVal() throws ParseException {
        final SyntaxTreeNode[] zn = new SyntaxTreeNode[3];
        final Token t;
        bpa("Field Value");
        zn[0] = Identifier();
        t = jj_consume_token(MAPTO);
        zn[1] = new SyntaxTreeNode(mn, t);
        zn[2] = Expression();
        epa();
        {
            if (true) return new SyntaxTreeNode(mn, N_FieldVal, zn);
        }
        throw new Error("Missing return statement in function");
    }

    public final SyntaxTreeNode FieldSet() throws ParseException {
        final SyntaxTreeNode[] zn = new SyntaxTreeNode[3];
        SyntaxTreeNode tn;
        final Token t;
        bpa("Field Set");
        zn[0] = Identifier();
        t = jj_consume_token(COLON);
        zn[1] = new SyntaxTreeNode(mn, t);
        zn[2] = Expression();
        epa();
        {
            if (true) return new SyntaxTreeNode(mn, N_FieldSet, zn);
        }
        throw new Error("Missing return statement in function");
    }

    public final SyntaxTreeNode ExceptSpec() throws ParseException {
        SyntaxTreeNode tn;
        Token t;
        bpa("Except Spec");
        t = jj_consume_token(BANG);
        addHeir(new SyntaxTreeNode(mn, t));
        label_40:
        while (true) {
            tn = ExceptComponent();
            addHeir(tn);
            expecting = "= or ,";
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case DOT:
                case LSB:
                    break;
                default:
                    jj_la1[114] = jj_gen;
                    break label_40;
            }
        }
        t = jj_consume_token(EQUALS);
        tn = new SyntaxTreeNode(mn, t);
        tn.setKind(T_EQUAL);
        addHeir(tn);
        tn = Expression();
        addHeir(tn);
        final SyntaxTreeNode[] sn = getLastHeirs();
        epa();
        {
            if (true) return new SyntaxTreeNode(mn, N_ExceptSpec, sn);
        }
        throw new Error("Missing return statement in function");
    }

    public final SyntaxTreeNode ExceptComponent() throws ParseException {
        SyntaxTreeNode tn;
        Token t;
        bpa("Except Component");
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case DOT -> {
                t = jj_consume_token(DOT);
                addHeir(new SyntaxTreeNode(mn, t));
                /***********************************************************
                 * Following added by LL on 10 Oct 2007 to make something   *
                 * like "!.THEN" work right.                                *
                 ***********************************************************/
                final Token next = getToken(1);
                if (isFieldNameToken(next)) next.kind = IDENTIFIER;
                tn = Identifier();
                if (tn.getUS().equals(At)) {
                    PErrors.push(new ParseError("@ used in !.@"));
                }
                addHeir(tn);
            }
            case LSB -> {
                t = jj_consume_token(LSB);
                addHeir(new SyntaxTreeNode(mn, t));
                tn = Expression();
                addHeir(tn);
                label_41:
                while (true) {
                    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                        case COMMA:
                            break;
                        default:
                            jj_la1[115] = jj_gen;
                            break label_41;
                    }
                    t = jj_consume_token(COMMA);
                    addHeir(new SyntaxTreeNode(mn, t));
                    tn = Expression();
                    addHeir(tn);
                }
                t = jj_consume_token(RSB);
                addHeir(new SyntaxTreeNode(mn, t));
            }
            default -> {
                jj_la1[116] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
            }
        }
        final SyntaxTreeNode[] sn = getLastHeirs();
        epa();
        {
            if (true) return new SyntaxTreeNode(mn, N_ExceptComponent, sn);
        }
        throw new Error("Missing return statement in function");
    }

    /***************************************************************************
     * The SetExcept non-terminal was eliminated from the grammar, but not      *
     * from the parser.                                                         *
     ***************************************************************************/
    public final SyntaxTreeNode SetExcept() throws ParseException {
        SyntaxTreeNode tn;
        Token t;
        bpa("Set Except");
        t = jj_consume_token(LWB);
        addHeir(new SyntaxTreeNode(mn, t));
        tn = Expression();
        addHeir(tn);
        t = jj_consume_token(EXCEPT);
        addHeir(new SyntaxTreeNode(mn, t));
        tn = SExceptSpec();
        addHeir(tn);
        label_42:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case COMMA:
                    break;
                default:
                    jj_la1[117] = jj_gen;
                    break label_42;
            }
            t = jj_consume_token(COMMA);
            addHeir(new SyntaxTreeNode(mn, t));
            tn = SExceptSpec();
            addHeir(tn);
        }
        t = jj_consume_token(RWB);
        addHeir(new SyntaxTreeNode(mn, t));
        final SyntaxTreeNode[] sn = getLastHeirs();
        epa();
        {
            if (true) return new SyntaxTreeNode(mn, N_SetExcept, sn);
        }
        throw new Error("Missing return statement in function");
    }

    public final SyntaxTreeNode SExceptSpec() throws ParseException {
        final SyntaxTreeNode[] zn = new SyntaxTreeNode[4];
        SyntaxTreeNode tn;
        Token t;
        bpa("Set Expect Spec");
        t = jj_consume_token(BANG);
        zn[0] = new SyntaxTreeNode(mn, t);
        zn[1] = ExceptComponent();
        expecting = "= or \\in";
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case EQUALS -> {
                t = jj_consume_token(EQUALS);
                zn[2] = new SyntaxTreeNode(mn, t);
                zn[2].setKind(T_EQUAL);
            }
            case IN -> {
                t = jj_consume_token(IN);
                zn[2] = new SyntaxTreeNode(mn, t);
                zn[2].setKind(T_IN);
            }
            default -> {
                jj_la1[118] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
            }
        }
        zn[3] = Expression();
        epa();
        {
            if (true) return new SyntaxTreeNode(mn, N_SExceptSpec, zn);
        }
        throw new Error("Missing return statement in function");
    }

    public final SyntaxTreeNode TupleOrAction() throws ParseException {
        int kind;
        SyntaxTreeNode tn;
        Token t;
        bpa("Some << -- >> or >>_ Form");
        t = jj_consume_token(LAB);
        addHeir(new SyntaxTreeNode(mn, t));
        if (jj_2_52(1)) {
            tn = Expression();
            addHeir(tn);
            label_43:
            while (true) {
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case COMMA:
                        break;
                    default:
                        jj_la1[119] = jj_gen;
                        break label_43;
                }
                t = jj_consume_token(COMMA);
                addHeir(new SyntaxTreeNode(mn, t));
                tn = Expression();
                addHeir(tn);
            }
        }
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case RAB -> {
                t = jj_consume_token(RAB);
                kind = N_Tuple;
                addHeir(new SyntaxTreeNode(mn, t));
            }
            case ARAB -> {
                t = jj_consume_token(ARAB);
                kind = N_ActionExpr;
                addHeir(new SyntaxTreeNode(mn, t));
                tn = ReducedExpression();
                addHeir(tn);
            }
            default -> {
                jj_la1[120] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
            }
        }
        final SyntaxTreeNode[] sn = getLastHeirs();
        epa();
        {
            if (true) return new SyntaxTreeNode(mn, kind, sn);
        }
        throw new Error("Missing return statement in function");
    }

    //  new SyntaxTreeNode( N_IdPrefix )  ???
    public final SyntaxTreeNode NoOpExtension() throws ParseException {
        final SyntaxTreeNode tid;
        SyntaxTreeNode top;
        SyntaxTreeNode last;
        last = null;
        top = null;
        Token t;
        tid = Identifier();
        if (jj_2_53(2)) {
            top = OpArgs();
        }
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case BANG -> {
                t = jj_consume_token(BANG);
                final SyntaxTreeNode[] heirs;
                if (top == null) {
                    heirs = new SyntaxTreeNode[2];
                    heirs[1] = new SyntaxTreeNode(mn, t);
                } else {
                    heirs = new SyntaxTreeNode[3];
                    heirs[1] = top;
                    heirs[2] = new SyntaxTreeNode(mn, t);
                }
                heirs[0] = tid;
                final SyntaxTreeNode current = new SyntaxTreeNode(mn, N_IdPrefixElement, heirs);
                addHeir(current);
                last = NoOpExtension();
            }
            default -> jj_la1[121] = jj_gen;
        }
        if (last == null) { // means no bang, bottom of recursion
            FairnessHook = top;
            final SyntaxTreeNode[] zn = new SyntaxTreeNode[2];
            zn[0] = new SyntaxTreeNode(mn, N_IdPrefix, getLastHeirs());
            zn[1] = tid;
            last = new SyntaxTreeNode(mn, N_GeneralId, zn);
        }
        {
            if (true) return last;
        }
        throw new Error("Missing return statement in function");
    }

    public final SyntaxTreeNode ReducedExpression() throws ParseException {
        /*************************************************************************
         * This is an expression that can follow "[...]_" or "<<...>>_".          *
         *************************************************************************/
        final SyntaxTreeNode expr;
        bpa("restricted form of expression");
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case IDENTIFIER -> expr = NoOpExtension();
            case LBR -> expr = ParenExpr();
            case LBC -> expr = BraceCases();
            case LSB -> expr = SBracketCases();
            case LWB -> expr = SetExcept();
            case LAB -> expr = TupleOrAction();
            default -> {
                jj_la1[122] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
            }
        }
        epa();
        {
            if (true) return expr;
        }
        throw new Error("Missing return statement in function");
    }

    // The following cases - for the first expression - must be recognized :
// "GeneralId", "OpApplication", "RecordComponent", "FcnAppl", "ParenExpr", "SetEnumerate", "SubsetOf", "SetOfAll", "FcnConst", "SetOfFcns", "RcdConstructor", "SetOfRcds", "Except", "Tuple", "ActionExpr"
// The cases break down in two categories: two set of () or a single one.
// in general, it's going to be some () [] or {} expression, or an Identifier foollowed by . () or [].
// Note that FcnAppl may be more intricate.
    public final SyntaxTreeNode FairnessExpr() throws ParseException {
        final SyntaxTreeNode[] zn = new SyntaxTreeNode[5];
        SyntaxTreeNode tn, expr;
        Token t;
        FairnessHook = null;
        bpa("Fairness Expression");
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case WF -> t = jj_consume_token(WF);
            case SF -> t = jj_consume_token(SF);
            default -> {
                jj_la1[123] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
            }
        }
        zn[0] = new SyntaxTreeNode(mn, t);
        expr = ReducedExpression();
        if (jj_2_54(2)) {
            t = jj_consume_token(LBR);
// ^^^
// Warning 3 -- Eliminated by LOOKAHEAD
            zn[1] = expr;
            expr = null;
            zn[2] = new SyntaxTreeNode(mn, t);
            zn[3] = Expression();
            t = jj_consume_token(RBR);
            zn[4] = new SyntaxTreeNode(mn, t);
        }
        epa();
        if (expr != null) {  // no extra (), FairnessHook can't be null ** Add check.
            if (FairnessHook == null) {
                {
                    if (true)
                        throw new ParseException("Ill-structured fairness expression at line " + zn[0].location[0] + ", column " + zn[0].location[1]);
                }
            }

            final SyntaxTreeNode[] parameters = (SyntaxTreeNode[]) FairnessHook.heirs();
            if (parameters != null && parameters.length == 3) { // was FairnessHook
                zn[1] = expr;
                zn[2] = parameters[0];
                zn[3] = parameters[1];
                zn[4] = parameters[2];
            } else {
                PErrors.push(new ParseError("Error in fairness expression at " + zn[0].location[0] + ": " + zn[0].location[1] + "\n", "-- --"));
                {
                    if (true) return expr;
                }
            }
// left for level checking.
        } else { // reattach FairnessHook ! unless it is tuple
// "GeneralId", "RecordComponent", "FcnAppl",
            if (zn[1].isKind(N_GeneralId) && FairnessHook != null) {
                final SyntaxTreeNode[] ozn = new SyntaxTreeNode[2];
                ozn[0] = zn[1];
                ozn[1] = FairnessHook;
                zn[1] = new SyntaxTreeNode(mn, N_OpApplication, ozn);
            } else if (!(zn[1].isKind(N_Tuple) || zn[1].isKind(N_ParenExpr) || zn[1].isKind(N_SetEnumerate) || zn[1].isKind(N_SubsetOf) || zn[1].isKind(N_SetOfAll) || zn[1].isKind(N_SetOfFcns) || zn[1].isKind(N_RcdConstructor) || zn[1].isKind(N_SetOfRcds) || zn[1].isKind(N_Except) || zn[1].isKind(N_FcnConst) || zn[1].isKind(N_ActionExpr))) {
// "ParenExpr", "SetEnumerate", "SubsetOf", "SetOfAll", "FcnConst",
// "SetOfFcns", "RcdConstructor", "SetOfRcds", "Except",
// "Tuple", "ActionExpr"
                PErrors.push(new ParseError("Error in fairness expression at " + zn[0].location[0] + ": " + zn[0].location[1] + ": could not link arguments\n", "-- --"));
                {
                    if (true) return zn[1];
                }
            }
        }
        {
            if (true) return new SyntaxTreeNode(mn, N_FairnessExpr, zn);
        }
        throw new Error("Missing return statement in function");
    }

    public final SyntaxTreeNode IfThenElse() throws ParseException {
        final SyntaxTreeNode[] zn = new SyntaxTreeNode[6];
        Token t;
        bpa("IF THEN ELSE");
        t = jj_consume_token(IF);
        zn[0] = new SyntaxTreeNode(mn, t);
        zn[1] = Expression();
        t = jj_consume_token(THEN);
        zn[2] = new SyntaxTreeNode(mn, t);
        zn[3] = Expression();
        t = jj_consume_token(ELSE);
        zn[4] = new SyntaxTreeNode(mn, t);
        zn[5] = Expression();
        epa();
        {
            if (true) return new SyntaxTreeNode(mn, N_IfThenElse, zn);
        }
        throw new Error("Missing return statement in function");
    }

    public final SyntaxTreeNode Case() throws ParseException {
        SyntaxTreeNode tn;
        Token t;
        bpa("CASE Expression");
        t = jj_consume_token(CASE);
        addHeir(new SyntaxTreeNode(mn, t));
        tn = CaseArm();
        addHeir(tn);
        label_44:
        while (true) {
            if (caseSep() && (getToken(2).kind != OTHER)) {
            } else {
                break;
            }
            t = jj_consume_token(CASESEP);
            addHeir(new SyntaxTreeNode(mn, t));
            tn = CaseArm();
            addHeir(tn);
        }
        if (caseSep()) {
            t = jj_consume_token(CASESEP);
            addHeir(new SyntaxTreeNode(mn, t));
            tn = OtherArm();
            addHeir(tn);
        }
        final SyntaxTreeNode[] sn = getLastHeirs();
        epa();
        {
            if (true) return new SyntaxTreeNode(mn, N_Case, sn);
        }
        throw new Error("Missing return statement in function");
    }

    public final SyntaxTreeNode CaseArm() throws ParseException {
        final SyntaxTreeNode[] zn = new SyntaxTreeNode[3];
        final Token t;
        bpa("Case Arm");
        zn[0] = Expression();
        t = jj_consume_token(ARROW);
        zn[1] = new SyntaxTreeNode(mn, t);
        zn[2] = Expression();
        epa();
        {
            if (true) return new SyntaxTreeNode(mn, N_CaseArm, zn);
        }
        throw new Error("Missing return statement in function");
    }

    public final SyntaxTreeNode OtherArm() throws ParseException {
        final SyntaxTreeNode[] zn = new SyntaxTreeNode[3];
        Token t;
        bpa("Case Other Arm");
        t = jj_consume_token(OTHER);
        zn[0] = new SyntaxTreeNode(mn, t);
        t = jj_consume_token(ARROW);
        zn[1] = new SyntaxTreeNode(mn, t);
        zn[2] = Expression();
        epa();
        {
            if (true) return new SyntaxTreeNode(mn, N_OtherArm, zn);
        }
        throw new Error("Missing return statement in function");
    }

    /***************************************************************************
     * LetIn ::= <LET> LetDefinitions() <LETIN> Expression()                    *
     *                                                                          *
     * It produces a SyntaxTreeNode tn with the four heirs                      *
     *    "LET", LetDefinitions, "IN", Expression                               *
     * in tn.zero.                                                              *
     ***************************************************************************/
    public final SyntaxTreeNode LetIn() throws ParseException {
        final SyntaxTreeNode[] zn = new SyntaxTreeNode[4];
        SyntaxTreeNode tn;
        Token t;
        bpa("Case Other Arm");
        t = jj_consume_token(LET);
        zn[0] = new SyntaxTreeNode(mn, t);
        zn[1] = LetDefinitions();
        t = jj_consume_token(LETIN);
        zn[2] = new SyntaxTreeNode(mn, t);
        zn[3] = Expression();
        epa();
        {
            if (true) return new SyntaxTreeNode(mn, N_LetIn, zn);
        }
        throw new Error("Missing return statement in function");
    }

    public final SyntaxTreeNode LetDefinitions() throws ParseException {
        SyntaxTreeNode tn;
        Token t;
        bpa("Let Definitions");
        label_45:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case LOCAL, DEFBREAK -> {
                    tn = OperatorOrFunctionDefinition();
                    addHeir(tn);
                }
                case RECURSIVE -> {
                    tn = Recursive();
                    addHeir(tn);
                }
                default -> {
                    jj_la1[124] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
                }
            }
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case LOCAL:
                case RECURSIVE:
                case DEFBREAK:
                    break;
                default:
                    jj_la1[125] = jj_gen;
                    break label_45;
            }
        }
        final SyntaxTreeNode[] sn = getLastHeirs();
        epa();
        {
            if (true) return new SyntaxTreeNode(mn, N_LetDefinitions, sn);
        }
        throw new Error("Missing return statement in function");
    }

    public final SyntaxTreeNode Junctions() throws ParseException {
        BStack.newReference(getToken(1).endColumn, getToken(1).kind);
        /***********************************************************************
         * Pushes onto BStack an element of the appropriate kind with offest    *
         * equal to the column of the last character in the /\ or \/ token.     *
         ***********************************************************************/

        bpa("AND-OR Junction");
        final int kind;
        if (jj_2_55(2147483647)) {
            kind = N_DisjList;
            DisjList();
        } else if (jj_2_56(2147483647)) {
            kind = N_ConjList;
            ConjList();
        } else {
            jj_consume_token(-1);
            throw new ParseException();
        }
        BStack.popReference();
        final SyntaxTreeNode[] sn = getLastHeirs();
        epa();
        {
            if (true) return new SyntaxTreeNode(mn, kind, sn);
        }
        throw new Error("Missing return statement in function");
    }

    public final void DisjList() throws ParseException {
        SyntaxTreeNode tn;
        tn = JuncItem(N_DisjItem);
        addHeir(tn);
        label_46:
        while (true) {
            if (BStack.onReference(getToken(1).endColumn, getToken(1).kind)) {
            } else {
                break;
            }
            tn = JuncItem(N_DisjItem);
            addHeir(tn);
        }
    }

    public final void ConjList() throws ParseException {
        SyntaxTreeNode tn;
        tn = JuncItem(N_ConjItem);
        addHeir(tn);
        label_47:
        while (true) {
            if (BStack.onReference(getToken(1).endColumn, getToken(1).kind)) {
            } else {
                break;
            }
            tn = JuncItem(N_ConjItem);
            addHeir(tn);
        }
    }

    public final SyntaxTreeNode JuncItem(final int itemKind) throws ParseException {
        final SyntaxTreeNode[] zn = new SyntaxTreeNode[2];
        final SyntaxTreeNode tn;
        final Token t;
        bpa("Junction Item");
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case OR ->
                /* t = <BOR> | */ t = jj_consume_token(OR);
            case AND -> t = jj_consume_token(AND);
            default -> {
                jj_la1[126] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
            }
        }
        zn[0] = new SyntaxTreeNode(mn, t);
        zn[1] = Expression();
        epa();
        /***********************************************************************
         * Check for indentation errors.                                        *
         ***********************************************************************/
        tn = new SyntaxTreeNode(mn, itemKind, zn);
        final TreeNode[] children = tn.heirs();
        for (int i = 1; i < children.length; i++) {
            checkIndentation((SyntaxTreeNode) children[i], tn);
        }
        {
            if (true) return tn;
        }
        throw new Error("Missing return statement in function");
    }

    public final SyntaxTreeNode UnboundOrBoundChoose() throws ParseException {
        final SyntaxTreeNode[] zn = new SyntaxTreeNode[5];
        SyntaxTreeNode tn;
        Token t;
        bpa("(Un)Bounded Choose");
        t = jj_consume_token(CHOOSE);
        zn[0] = new SyntaxTreeNode(mn, t);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case IDENTIFIER -> zn[1] = Identifier();
            case LAB -> zn[1] = IdentifierTuple();
            default -> {
                jj_la1[127] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
            }
        }
        zn[2] = MaybeBound();
        t = jj_consume_token(COLON);
        zn[3] = new SyntaxTreeNode(mn, t);
        zn[4] = Expression();
        final SyntaxTreeNode[] sn = getLastHeirs();
        epa();
        {
            if (true) return new SyntaxTreeNode(mn, N_UnboundOrBoundChoose, zn);
        }
        throw new Error("Missing return statement in function");
    }

    /***************************************************************************
     * Lambda expression added by LL on 27 March 2007                           *
     *                                                                          *
     * L.Lambda ::=                                                             *
     *   <LAMBDA>                                                               *
     *   (IdentDecl | SomeFixDecl) (<COMMA> (IdentDecl | SomeFixDecl))*         *
     *   <COLON> Expression                                                     *
     ***************************************************************************/
    public final SyntaxTreeNode Lambda() throws ParseException {
        SyntaxTreeNode tn;
        Token t;
        bpa("Lambda");
        t = jj_consume_token(LAMBDA);
        addHeir(new SyntaxTreeNode(mn, t));
        expecting = "Identifier";
        tn = Identifier();
        addHeir(tn);
        expecting = "`,' or `:'";
        label_48:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case COMMA:
                    break;
                default:
                    jj_la1[128] = jj_gen;
                    break label_48;
            }
            t = jj_consume_token(COMMA);
            addHeir(new SyntaxTreeNode(mn, t));
            expecting = "Identifier";
            tn = Identifier();
            addHeir(tn);
            expecting = "`,' or `:'";
        }
        t = jj_consume_token(COLON);
        addHeir(new SyntaxTreeNode(mn, t));
        expecting = "Expression";
        tn = Expression();
        addHeir(tn);
        final SyntaxTreeNode[] sn = getLastHeirs();
        epa();
        {
            if (true) return new SyntaxTreeNode(mn, N_Lambda, sn);
        }
        throw new Error("Missing return statement in function");
    }

    // boxDisc (riminate) uses preInEmptyTop
// note that junction is processed separately.
    public final SyntaxTreeNode Expression() throws ParseException {
        SyntaxTreeNode tn, tn0, tn1, tn2;
        int kind;
        Token t;
        bpa("Expression");
        OperatorStack.newStack();
        label_49:
        while (true) {
            if (jj_2_57(2147483647) && (BStack.aboveReference(getToken(1).beginColumn))) {
            } else {
                break;
            }
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case op_26, op_29, op_58, CASESEP, op_61, op_112, op_113, op_114, op_115, op_116 -> {
                    tn = PrefixOp();
                    kind = N_GenPrefixOp;
                }
                case op_1, AND, op_3, op_4, OR, op_6, op_7, op_8, op_9, op_10, op_11, op_12, op_13, op_14, op_15, op_16, op_17, op_18, op_19, IN, op_21, op_22, op_23, op_24, op_25, op_27, op_30, op_31, op_32, op_33, op_34, op_35, op_36, op_37, op_38, op_39, op_40, op_41, op_42, op_43, op_44, op_45, op_46, op_47, op_48, op_49, op_50, op_51, op_52, op_53, op_54, op_55, op_56, op_59, op_62, op_63, op_64, EQUALS, op_66, op_67, op_71, op_72, op_73, op_74, op_75, op_77, op_78, op_79, op_80, op_81, op_82, op_83, op_84, op_85, op_86, op_87, op_88, op_89, op_90, op_91, op_92, op_93, op_94, op_95, op_96, op_97, op_98, op_100, op_101, op_102, op_103, op_104, op_105, op_106, op_107, op_108, op_109, op_110, op_111, op_117, op_118, op_119 -> {
                    tn = InfixOp();
                    kind = N_GenInfixOp;
                }
                default -> {
                    jj_la1[129] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
                }
            }
            final SyntaxTreeNode[] heirs = new SyntaxTreeNode[2];
            heirs[0] = new SyntaxTreeNode(mn, N_IdPrefix, (SyntaxTreeNode[]) null);
            heirs[1] = tn;
            OperatorStack.pushOnStack(new SyntaxTreeNode(mn, kind, heirs), lastOp);
            if (OperatorStack.size() != 1) {
                OperatorStack.reduceStack();
            }
            /*****************************************************************
             * This is probably a no-op since we can't reduce the stack at    *
             * this point.                                                    *
             *****************************************************************/

        }
        if (jj_2_58(2147483647) && (BStack.aboveReference(getToken(1).beginColumn))) {
            tn = OpenExpression();
            OperatorStack.pushOnStack(tn, null);
        } else if (BStack.aboveReference(getToken(1).beginColumn)) {
            ExtendableExpr();
        } else {
            jj_consume_token(-1);
            throw new ParseException();
        }
        epa();
        tn = OperatorStack.finalReduce();
        if (tn == null) {
            {
                if (true) throw new ParseException(" Couldn't reduce expression stack.");
            }
        }
        OperatorStack.popStack();
        {
            if (true) return tn;
        }
        throw new Error("Missing return statement in function");
    }

    // Expression
    public final void ExtendableExpr() throws ParseException {
        SyntaxTreeNode tn;
        final SyntaxTreeNode tn0;
        final SyntaxTreeNode tn1;
        final SyntaxTreeNode tn2;
        SyntaxTreeNode[] heirs;
        int kind;
        Token t;
        bpa("ExtendableExpr");
        if (jj_2_59(2147483647) && (OperatorStack.preInEmptyTop()
                // && BStack.aboveReference( getToken(1).beginColumn)
        )) {
            tn = Junctions();
            OperatorStack.pushOnStack(tn, null);
        } else {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case SF, WF, LBR, LSB, LWB, LBC, LAB -> {
                    /************************************************************************
                     * ParenthesesExpression                                                 *
                     ************************************************************************/
                    tn = ParenthesesExpression();
                    OperatorStack.pushOnStack(tn, null);
                }
                default -> {
                    jj_la1[130] = jj_gen;
                    if (jj_2_60(1)) {
                        /************************************************************************
                         * PrimitiveExpression                                                 *
                         ************************************************************************/
                        tn = PrimitiveExp();
                        OperatorStack.pushOnStack(tn, null);
                    } else {
                        jj_consume_token(-1);
                        throw new ParseException();
                    }
                }
            }
        }
        label_50:
        while (true) {
            if (jj_2_61(1)) {
            } else {
                break;
            }
            if (jj_2_62(2147483647) && (BStack.aboveReference(getToken(1).beginColumn))) {
                tn = PostfixOp();
                heirs = new SyntaxTreeNode[2];
                heirs[0] =
                        new SyntaxTreeNode(mn, N_IdPrefix, (SyntaxTreeNode[]) null);
                heirs[1] = tn;
                OperatorStack.pushOnStack(new SyntaxTreeNode(mn, N_GenPostfixOp, heirs),
                        lastOp);
                if (OperatorStack.size() != 1) {
                    OperatorStack.reduceStack();
                }
            } else if (jj_2_63(2147483647) && (BStack.aboveReference(getToken(1).beginColumn))) {
                t = jj_consume_token(DOT);
                final Token next = getToken(1);
                if (isFieldNameToken(next)) next.kind = IDENTIFIER;
                if (BStack.aboveReference(getToken(1).beginColumn)) {

                } else {
                    jj_consume_token(-1);
                    throw new ParseException();
                }
                tn = Identifier();
                OperatorStack.reduceRecord(new SyntaxTreeNode(mn, t), tn);
            } else if (jj_2_64(2147483647) && (BStack.aboveReference(getToken(1).beginColumn))) {
                expecting = "function argument";
                tn = SBracketCases();
                if (isGenOp(tn)) {
                    /*******************************************************************
                     * In the normal case, tn will be an N_FcnAppl node and             *
                     * isGenOp(tn) will be true.  In an error case, isGenOp(tn) should  *
                     * be false, and whatever is returned will presumably not be an     *
                     * operator and pushing it on the stack will produce an error       *
                     * because the stack will have two expressions with no intervening  *
                     * infix operator.                                                  *
                     *******************************************************************/
                    OperatorStack.pushOnStack(tn, lastOp);
                    if (OperatorStack.size() != 1) {
                        OperatorStack.reduceStack();
                    }
                } else {
                    OperatorStack.pushOnStack(tn, null);
                }
            } else {
                jj_consume_token(-1);
                throw new ParseException();
            }
        }
        if (jj_2_69(1)) {
            if (jj_2_67(2147483647) && (BStack.aboveReference(getToken(1).beginColumn))) {
                tn = InfixOp();
                heirs = new SyntaxTreeNode[2];
                heirs[0] = new SyntaxTreeNode(mn, N_IdPrefix, (SyntaxTreeNode[]) null);
                heirs[1] = tn;
                OperatorStack.pushOnStack(new SyntaxTreeNode(mn, N_GenInfixOp, heirs),
                        lastOp);
                if (OperatorStack.size() != 1) {
                    OperatorStack.reduceStack();
                }
                label_51:
                while (true) {
                    if (jj_2_65(2147483647) && (BStack.aboveReference(getToken(1).beginColumn))) {
                    } else {
                        break;
                    }
                    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                        case op_26, op_29, op_58, CASESEP, op_61, op_112, op_113, op_114, op_115, op_116 -> {
                            tn = PrefixOp();
                            kind = N_GenPrefixOp;
                        }
                        case op_1, AND, op_3, op_4, OR, op_6, op_7, op_8, op_9, op_10, op_11, op_12, op_13, op_14, op_15, op_16, op_17, op_18, op_19, IN, op_21, op_22, op_23, op_24, op_25, op_27, op_30, op_31, op_32, op_33, op_34, op_35, op_36, op_37, op_38, op_39, op_40, op_41, op_42, op_43, op_44, op_45, op_46, op_47, op_48, op_49, op_50, op_51, op_52, op_53, op_54, op_55, op_56, op_59, op_62, op_63, op_64, EQUALS, op_66, op_67, op_71, op_72, op_73, op_74, op_75, op_77, op_78, op_79, op_80, op_81, op_82, op_83, op_84, op_85, op_86, op_87, op_88, op_89, op_90, op_91, op_92, op_93, op_94, op_95, op_96, op_97, op_98, op_100, op_101, op_102, op_103, op_104, op_105, op_106, op_107, op_108, op_109, op_110, op_111, op_117, op_118, op_119 -> {
                            tn = InfixOp();
                            kind = N_GenInfixOp;
                        }
                        default -> {
                            jj_la1[131] = jj_gen;
                            jj_consume_token(-1);
                            throw new ParseException();
                        }
                    }
                    heirs = new SyntaxTreeNode[2];
                    heirs[0] = new SyntaxTreeNode(mn, N_IdPrefix, (SyntaxTreeNode[]) null);
                    heirs[1] = tn;
                    OperatorStack.pushOnStack(new SyntaxTreeNode(mn, kind, heirs), lastOp);
                    if (OperatorStack.size() != 1) {
                        OperatorStack.reduceStack();
                    }
                    /*****************************************************************
                     * This is probably a no-op since we can't reduce the stack at    *
                     * this point.                                                    *
                     *****************************************************************/

                }
                if (jj_2_66(2147483647) && (BStack.aboveReference(getToken(1).beginColumn))) {
                    tn = OpenExpression();
                    OperatorStack.pushOnStack(tn, null);
                } else if (BStack.aboveReference(getToken(1).beginColumn)) {
                    ExtendableExpr();
                } else {
                    jj_consume_token(-1);
                    throw new ParseException();
                }
            } else if (jj_2_68(2147483647) && (BStack.aboveReference(getToken(1).beginColumn))) {
                t = jj_consume_token(COLONCOLON);
                tn1 = new SyntaxTreeNode(mn, t);
                tn0 = Objects.requireNonNull(OperatorStack.topOfStack()).getNode();
                if (!isLabel(tn0)) {
                    {
                        if (true) throw new ParseException("`::' at " + tn1.getLocation()
                                + " does not follow a label.");
                    }
                }
                OperatorStack.popCurrentTop();
                // t = <COLONCOLON>
                tn2 = Expression();
                if (!labelDoesNotChangeParse(tn2, lastOp)) {
                    /*****************************************************************
                     * Note: if tn1 is a prefix, infix, or postfix expression, then   *
                     * I believe (perhaps naively) that lastOp will be its operator.  *
                     *****************************************************************/
                    {
                        if (true) throw new ParseException(
                                "Removing label at " + tn0.getLocation() +
                                        " would change expression parsing.");
                    }
                }
                final SyntaxTreeNode[] labelHeirs = {tn0, tn1, tn2};
                tn = new SyntaxTreeNode(N_Label, labelHeirs);
                OperatorStack.pushOnStack(tn, null);
            } else {
                jj_consume_token(-1);
                throw new ParseException();
            }
        }
        epa();
    }

    // ExtendableExpr
    public final SyntaxTreeNode PrimitiveExp() throws ParseException {
        final SyntaxTreeNode tn;
        final SyntaxTreeNode tn0;
        SyntaxTreeNode tn1;
        SyntaxTreeNode tn2;
        SyntaxTreeNode tnOpArgs = null;
        SyntaxTreeNode[] tnBangs;
        SyntaxTreeNode[] heirs;
        final Token t;
        bpa("Primitive expression");
        if (jj_2_72(2147483647) && (BStack.aboveReference(getToken(1).beginColumn))) {
            tn = String();
        } else if (jj_2_73(2147483647) && (BStack.aboveReference(getToken(1).beginColumn))) {
            tn = Number();
        } else {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case op_57, op_68, op_69, op_70, op_76, op_26, op_29, op_58, CASESEP, op_61, op_112, op_113, op_114, op_115, op_116, op_1, AND, op_3, op_4, OR, op_6, op_7, op_8, op_9, op_10, op_11, op_12, op_13, op_14, op_15, op_16, op_17, op_18, op_19, IN, op_21, op_22, op_23, op_24, op_25, op_27, op_30, op_31, op_32, op_33, op_34, op_35, op_36, op_37, op_38, op_39, op_40, op_41, op_42, op_43, op_44, op_45, op_46, op_47, op_48, op_49, op_50, op_51, op_52, op_53, op_54, op_55, op_56, op_59, op_62, op_63, op_64, EQUALS, op_66, op_67, op_71, op_72, op_73, op_74, op_75, op_77, op_78, op_79, op_80, op_81, op_82, op_83, op_84, op_85, op_86, op_87, op_88, op_89, op_90, op_91, op_92, op_93, op_94, op_95, op_96, op_97, op_98, op_100, op_101, op_102, op_103, op_104, op_105, op_106, op_107, op_108, op_109, op_110, op_111, op_117, op_118, op_119, IDENTIFIER, ProofStepLexeme, ProofImplicitStepLexeme -> {
                    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                        case IDENTIFIER -> tn0 = Identifier();
                        case ProofStepLexeme, ProofImplicitStepLexeme -> {
                            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                                case ProofStepLexeme -> t = jj_consume_token(ProofStepLexeme);
                                case ProofImplicitStepLexeme -> t = jj_consume_token(ProofImplicitStepLexeme);
                                default -> {
                                    jj_la1[132] = jj_gen;
                                    jj_consume_token(-1);
                                    throw new ParseException();
                                }
                            }
                            tn0 = new SyntaxTreeNode(mn, t);
                            if ((getProofLevel() < 0) && (proofDepth <= 0)) {
                                {
                                    if (true) throw new
                                            ParseException(tn0.getLocation() +
                                            ": Step number used outside proof.");
                                }
                            }
                            if (t.image.charAt(1) == '+') {
                                {
                                    if (true) throw new ParseException(tn0.getLocation() +
                                            ": <+> step number used in an expression.");
                                }
                            }
                            if (t.kind == ProofImplicitStepLexeme) {
                                tn0.originalImage = tn0.image;
                                tn0.image = correctedStepNum(t);
                            }
                        }
                        case op_1, AND, op_3, op_4, OR, op_6, op_7, op_8, op_9, op_10, op_11, op_12, op_13, op_14, op_15, op_16, op_17, op_18, op_19, IN, op_21, op_22, op_23, op_24, op_25, op_27, op_30, op_31, op_32, op_33, op_34, op_35, op_36, op_37, op_38, op_39, op_40, op_41, op_42, op_43, op_44, op_45, op_46, op_47, op_48, op_49, op_50, op_51, op_52, op_53, op_54, op_55, op_56, op_59, op_62, op_63, op_64, EQUALS, op_66, op_67, op_71, op_72, op_73, op_74, op_75, op_77, op_78, op_79, op_80, op_81, op_82, op_83, op_84, op_85, op_86, op_87, op_88, op_89, op_90, op_91, op_92, op_93, op_94, op_95, op_96, op_97, op_98, op_100, op_101, op_102, op_103, op_104, op_105, op_106, op_107, op_108, op_109, op_110, op_111, op_117, op_118, op_119 ->
                                tn0 = InfixOp();
                        case op_57, op_68, op_69, op_70 -> tn0 = PostfixOp();
                        default -> {
                            jj_la1[133] = jj_gen;
                            if (jj_2_70(2147483647)) {
                                tn0 = NonExpPrefixOp();
                            } else {
                                jj_consume_token(-1);
                                throw new ParseException();
                            }
                        }
                    }
                    if (jj_2_71(2)) {
                        tnOpArgs = OpArgs();
                    }
                    label_52:
                    while (true) {
                        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                            case BANG:
                                break;
                            default:
                                jj_la1[134] = jj_gen;
                                break label_52;
                        }
                        tn1 = BangExt();
                        addHeir(tn1);
                    }
                    tnBangs = getLastHeirs();
                    if (tnBangs == null) {
                        heirs = new SyntaxTreeNode[2];
                        heirs[0] = new SyntaxTreeNode(mn, N_IdPrefix,
                                new SyntaxTreeNode[0]);
                        heirs[1] = tn0;
                        tn1 = new SyntaxTreeNode(mn, N_GeneralId, heirs);
                        if (tnOpArgs == null) {
                            tn = tn1;
                        } else {
                            heirs = new SyntaxTreeNode[2];
                            heirs[0] = tn1;
                            heirs[1] = tnOpArgs;
                            tn = new SyntaxTreeNode(mn, N_OpApplication, heirs);
                        }
                    } // if (tnBangs == null)
                    else {
                        /******************************************************************
                         * There is a BangExt.  The parse tree constructed so far needs    *
                         * to be rearranged to be what is expected of the parser           *
                         * (because the parser was designed for TLA+1).  For example, if   *
                         * we're parsing                                                   *
                         *                                                                 *
                         *   foo(1)!b!c(2,3), so far we have                               *
                         *   tn0 = foo                                                     *
                         *   tnOpArgs = OpArgs[1]                                          *
                         *   tnBangs = IdPrefixElement[! b]                                *
                         *             IdPrefixElement[! c OpArgs[2, 3]]                   *
                         *                                                                 *
                         * and we must turn that into                                      *
                         *                                                                 *
                         *   OpAppl[ GeneralId[ IdPrefix[IdPrefixElement[foo OpArgs[1] !]  *
                         *                               IdPrefixElement[b !]]             *
                         *                      c]                                         *
                         *           OpArgs[2, 3]]                                         *
                         *                                                                 *
                         * Note that the result is an OpAppl node iff the last             *
                         * IdPrefixElement contains an OpArg heir, otherwise it is a       *
                         * GeneralId node.                                                 *
                         ******************************************************************/

                        /******************************************************************
                         * We set heirs to the array of IdPrefixElement nodes that are     *
                         * the heirs of the IdPrefix node that is the first heir of the    *
                         * GeneralId node.                                                 *
                         ******************************************************************/
                        heirs = new SyntaxTreeNode[tnBangs.length];

                        /******************************************************************
                         * Set eltHeirs to the heirs of heirs[0].                          *
                         ******************************************************************/
                        SyntaxTreeNode[] eltHeirs;
                        if (tnOpArgs == null) {
                            eltHeirs = new SyntaxTreeNode[2];
                            eltHeirs[0] = tn0;
                            eltHeirs[1] = (SyntaxTreeNode) tnBangs[0].heirs()[0];
                        } else {
                            eltHeirs = new SyntaxTreeNode[3];
                            eltHeirs[0] = tn0;
                            eltHeirs[1] = tnOpArgs;
                            eltHeirs[2] = (SyntaxTreeNode) tnBangs[0].heirs()[0];
                        }
                        heirs[0] =
                                new SyntaxTreeNode(mn, N_IdPrefixElement, eltHeirs);
                        for (int i = 0; i < tnBangs.length - 1; i++) {
                            eltHeirs =
                                    new SyntaxTreeNode[tnBangs[i].heirs().length];
                            for (int j = 0; j < eltHeirs.length - 1; j++) {
                                eltHeirs[j] = (SyntaxTreeNode) tnBangs[i].heirs()[j + 1];
                            }
                            eltHeirs[eltHeirs.length - 1] = (SyntaxTreeNode)
                                    tnBangs[i + 1].heirs()[0];
                            heirs[i + 1] = new SyntaxTreeNode(mn, N_IdPrefixElement, eltHeirs);
                        } // for
                        final TreeNode[] lastBang = tnBangs[tnBangs.length - 1].heirs();
                        final SyntaxTreeNode[] genIdHeirs = new SyntaxTreeNode[2];
                        genIdHeirs[0] = new SyntaxTreeNode(mn, N_IdPrefix, heirs);
                        genIdHeirs[1] = (SyntaxTreeNode) lastBang[1];
                        final SyntaxTreeNode genId =
                                new SyntaxTreeNode(mn, N_GeneralId, genIdHeirs);
                        if (lastBang.length == 2) {
                            tn = genId;
                        } else {
                            heirs = new SyntaxTreeNode[2];
                            heirs[0] = genId;
                            heirs[1] = (SyntaxTreeNode) lastBang[2];
                            tn = new SyntaxTreeNode(mn, N_OpApplication, heirs);
                        } // else
                    } // else
                }
                default -> {
                    jj_la1[135] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
                }
            }
        }
        epa();
        {
            if (true) return tn;
        }
        throw new Error("Missing return statement in function");
    }

    // PrimitiveExp
    public final SyntaxTreeNode BangExt() throws ParseException {
        /*************************************************************************
         * Returns an N_IdPrefixElement node with 2 or 3 heirs consisting of:     *
         *  - A "!" (<BANG>) token.                                               *
         *  - An Identifier(), PrefixOp(), InfixOp(), or PostfixOp() node.        *
         *  - An optional OpArgs() node.                                          *
         * Note that this is not the kind of N_IdPrefixElement that the parser    *
         * ultimately produces, which ends with a "!" rather than beginning with  *
         * one.                                                                   *
         *************************************************************************/
        SyntaxTreeNode tn;
        final Token t;
        bpa("Bang Extension");
        t = jj_consume_token(BANG);
        addHeir(new SyntaxTreeNode(mn, t));
        if (jj_2_76(1)) {
            if (jj_2_74(2147483647) && (!getToken(1).image.equals("@"))) {
                tn = Identifier();
            } else {
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case op_76, op_26, op_29, op_58, CASESEP, op_61, op_112, op_113, op_114, op_115, op_116 ->
                            tn = NonExpPrefixOp();
                    case op_1, AND, op_3, op_4, OR, op_6, op_7, op_8, op_9, op_10, op_11, op_12, op_13, op_14, op_15, op_16, op_17, op_18, op_19, IN, op_21, op_22, op_23, op_24, op_25, op_27, op_30, op_31, op_32, op_33, op_34, op_35, op_36, op_37, op_38, op_39, op_40, op_41, op_42, op_43, op_44, op_45, op_46, op_47, op_48, op_49, op_50, op_51, op_52, op_53, op_54, op_55, op_56, op_59, op_62, op_63, op_64, EQUALS, op_66, op_67, op_71, op_72, op_73, op_74, op_75, op_77, op_78, op_79, op_80, op_81, op_82, op_83, op_84, op_85, op_86, op_87, op_88, op_89, op_90, op_91, op_92, op_93, op_94, op_95, op_96, op_97, op_98, op_100, op_101, op_102, op_103, op_104, op_105, op_106, op_107, op_108, op_109, op_110, op_111, op_117, op_118, op_119 ->
                            tn = InfixOp();
                    case op_57, op_68, op_69, op_70 -> tn = PostfixOp();
                    default -> {
                        jj_la1[136] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                    }
                }
            }
            addHeir(tn);
            if (jj_2_75(2)) {
                tn = OpArgs();
                addHeir(tn);
            }
        } else {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case LBR -> {
                    tn = OpArgs();
                    addHeir(tn);
                }
                default -> {
                    jj_la1[137] = jj_gen;
                    if (jj_2_77(1)) {
                        tn = StructOp();
                        addHeir(tn);
                    } else {
                        jj_consume_token(-1);
                        throw new ParseException();
                    }
                }
            }
        }
        tn = new SyntaxTreeNode(mn, N_IdPrefixElement, getLastHeirs());
        epa();
        {
            if (true) return tn;
        }
        throw new Error("Missing return statement in function");
    }

    // BangExt
    public final SyntaxTreeNode StructOp() throws ParseException {
        SyntaxTreeNode tn = null;
        Token t = null;
        bpa("StructOp");
        expecting = "`<<' , `>>' , `:' , `@' , or number";
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case LAB -> t = jj_consume_token(LAB);
            case RAB -> t = jj_consume_token(RAB);
            case COLON -> t = jj_consume_token(COLON);
            case NUMBER_LITERAL -> tn = Number();
            default -> {
                jj_la1[138] = jj_gen;
                if (getToken(1).image.equals("@")) {
                    t = jj_consume_token(IDENTIFIER);
                } else {
                    jj_consume_token(-1);
                    throw new ParseException();
                }
            }
        }
        epa();
        if (tn == null) {
            {
                if (true) return new SyntaxTreeNode(mn, N_StructOp, t);
            }
        } else {
            if (tn.getKind() == N_Real) {
                {
                    if (true) throw new ParseException(
                            "Illegal structural term at " +
                                    tn.getLocation());
                }
            }
            final SyntaxTreeNode[] heirs = new SyntaxTreeNode[1];
            heirs[0] = tn;
            {
                if (true) return new SyntaxTreeNode(mn, N_StructOp, heirs);
            }
        }
        throw new Error("Missing return statement in function");
    }

    private boolean jj_2_1(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_1();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(0, xla);
        }
    }

    private boolean jj_2_2(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_2();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(1, xla);
        }
    }

    private boolean jj_2_3(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_3();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(2, xla);
        }
    }

    private boolean jj_2_4(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_4();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(3, xla);
        }
    }

    private boolean jj_2_5(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_5();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(4, xla);
        }
    }

    private boolean jj_2_6(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_6();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(5, xla);
        }
    }

    private boolean jj_2_7(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_7();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(6, xla);
        }
    }

    private boolean jj_2_8(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_8();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(7, xla);
        }
    }

    private boolean jj_2_9(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_9();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(8, xla);
        }
    }

    private boolean jj_2_10(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_10();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(9, xla);
        }
    }

    private boolean jj_2_11(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_11();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(10, xla);
        }
    }

    private boolean jj_2_12(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_12();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(11, xla);
        }
    }

    private boolean jj_2_13(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_13();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(12, xla);
        }
    }

    private boolean jj_2_14(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_14();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(13, xla);
        }
    }

    private boolean jj_2_15(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_15();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(14, xla);
        }
    }

    private boolean jj_2_16(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_16();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(15, xla);
        }
    }

    private boolean jj_2_17(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_17();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(16, xla);
        }
    }

    private boolean jj_2_18(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_18();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(17, xla);
        }
    }

    private boolean jj_2_19(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_19();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(18, xla);
        }
    }

    private boolean jj_2_20(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_20();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(19, xla);
        }
    }

    private boolean jj_2_21(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_21();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(20, xla);
        }
    }

    private boolean jj_2_22(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_22();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(21, xla);
        }
    }

    private boolean jj_2_23(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_23();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(22, xla);
        }
    }

    private boolean jj_2_24(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_24();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(23, xla);
        }
    }

    private boolean jj_2_25(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_25();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(24, xla);
        }
    }

    private boolean jj_2_26(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_26();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(25, xla);
        }
    }

    private boolean jj_2_27(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_27();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(26, xla);
        }
    }

    private boolean jj_2_28(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_28();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(27, xla);
        }
    }

    private boolean jj_2_29(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_29();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(28, xla);
        }
    }

    private boolean jj_2_30(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_30();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(29, xla);
        }
    }

    private boolean jj_2_31(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_31();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(30, xla);
        }
    }

    private boolean jj_2_32(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_32();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(31, xla);
        }
    }

    private boolean jj_2_33(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_33();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(32, xla);
        }
    }

    private boolean jj_2_34(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_34();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(33, xla);
        }
    }

    private boolean jj_2_35(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_35();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(34, xla);
        }
    }

    private boolean jj_2_36(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_36();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(35, xla);
        }
    }

    private boolean jj_2_37(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_37();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(36, xla);
        }
    }

    private boolean jj_2_38(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_38();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(37, xla);
        }
    }

    private boolean jj_2_39(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_39();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(38, xla);
        }
    }

    private boolean jj_2_40(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_40();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(39, xla);
        }
    }

    private boolean jj_2_41(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_41();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(40, xla);
        }
    }

    private boolean jj_2_42(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_42();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(41, xla);
        }
    }

    private boolean jj_2_43(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_43();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(42, xla);
        }
    }

    private boolean jj_2_44(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_44();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(43, xla);
        }
    }

    private boolean jj_2_45(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_45();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(44, xla);
        }
    }

    private boolean jj_2_46(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_46();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(45, xla);
        }
    }

    private boolean jj_2_47(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_47();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(46, xla);
        }
    }

    private boolean jj_2_48(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_48();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(47, xla);
        }
    }

    private boolean jj_2_49(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_49();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(48, xla);
        }
    }

    private boolean jj_2_50(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_50();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(49, xla);
        }
    }

    private boolean jj_2_51(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_51();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(50, xla);
        }
    }

    private boolean jj_2_52(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_52();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(51, xla);
        }
    }

    private boolean jj_2_53(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_53();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(52, xla);
        }
    }

    private boolean jj_2_54(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_54();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(53, xla);
        }
    }

    private boolean jj_2_55(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_55();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(54, xla);
        }
    }

    private boolean jj_2_56(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_56();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(55, xla);
        }
    }

    private boolean jj_2_57(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_57();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(56, xla);
        }
    }

    private boolean jj_2_58(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_58();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(57, xla);
        }
    }

    private boolean jj_2_59(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_59();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(58, xla);
        }
    }

    private boolean jj_2_60(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_60();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(59, xla);
        }
    }

    private boolean jj_2_61(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_61();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(60, xla);
        }
    }

    private boolean jj_2_62(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_62();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(61, xla);
        }
    }

    private boolean jj_2_63(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_63();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(62, xla);
        }
    }

    private boolean jj_2_64(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_64();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(63, xla);
        }
    }

    private boolean jj_2_65(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_65();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(64, xla);
        }
    }

    private boolean jj_2_66(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_66();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(65, xla);
        }
    }

    private boolean jj_2_67(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_67();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(66, xla);
        }
    }

    private boolean jj_2_68(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_68();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(67, xla);
        }
    }

    private boolean jj_2_69(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_69();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(68, xla);
        }
    }

    private boolean jj_2_70(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_70();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(69, xla);
        }
    }

    private boolean jj_2_71(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_71();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(70, xla);
        }
    }

    private boolean jj_2_72(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_72();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(71, xla);
        }
    }

    private boolean jj_2_73(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_73();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(72, xla);
        }
    }

    private boolean jj_2_74(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_74();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(73, xla);
        }
    }

    private boolean jj_2_75(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_75();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(74, xla);
        }
    }

    private boolean jj_2_76(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_76();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(75, xla);
        }
    }

    private boolean jj_2_77(final int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_77();
        } catch (final LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(76, xla);
        }
    }

    private boolean jj_3_64() {
        return jj_scan_token(LSB);
    }

    private boolean jj_3R_182() {
        return jj_3R_150();
    }

    private boolean jj_3R_65() {
        final Token xsp;
        xsp = jj_scanpos;
        if (jj_scan_token(129)) {
            jj_scanpos = xsp;
            if (jj_scan_token(130)) {
                jj_scanpos = xsp;
                if (jj_scan_token(131)) {
                    jj_scanpos = xsp;
                    if (jj_scan_token(132)) {
                        jj_scanpos = xsp;
                        if (jj_scan_token(133)) {
                            jj_scanpos = xsp;
                            if (jj_scan_token(134)) {
                                jj_scanpos = xsp;
                                if (jj_scan_token(135)) {
                                    jj_scanpos = xsp;
                                    if (jj_scan_token(136)) {
                                        jj_scanpos = xsp;
                                        if (jj_scan_token(137)) {
                                            jj_scanpos = xsp;
                                            if (jj_scan_token(138)) {
                                                jj_scanpos = xsp;
                                                if (jj_scan_token(139)) {
                                                    jj_scanpos = xsp;
                                                    if (jj_scan_token(140)) {
                                                        jj_scanpos = xsp;
                                                        if (jj_scan_token(141)) {
                                                            jj_scanpos = xsp;
                                                            if (jj_scan_token(142)) {
                                                                jj_scanpos = xsp;
                                                                if (jj_scan_token(143)) {
                                                                    jj_scanpos = xsp;
                                                                    if (jj_scan_token(144)) {
                                                                        jj_scanpos = xsp;
                                                                        if (jj_scan_token(145)) {
                                                                            jj_scanpos = xsp;
                                                                            if (jj_scan_token(146)) {
                                                                                jj_scanpos = xsp;
                                                                                if (jj_scan_token(147)) {
                                                                                    jj_scanpos = xsp;
                                                                                    if (jj_scan_token(148)) {
                                                                                        jj_scanpos = xsp;
                                                                                        if (jj_scan_token(149)) {
                                                                                            jj_scanpos = xsp;
                                                                                            if (jj_scan_token(150)) {
                                                                                                jj_scanpos = xsp;
                                                                                                if (jj_scan_token(151)) {
                                                                                                    jj_scanpos = xsp;
                                                                                                    if (jj_scan_token(152)) {
                                                                                                        jj_scanpos = xsp;
                                                                                                        if (jj_scan_token(153)) {
                                                                                                            jj_scanpos = xsp;
                                                                                                            if (jj_scan_token(154)) {
                                                                                                                jj_scanpos = xsp;
                                                                                                                if (jj_scan_token(155)) {
                                                                                                                    jj_scanpos = xsp;
                                                                                                                    if (jj_scan_token(156)) {
                                                                                                                        jj_scanpos = xsp;
                                                                                                                        if (jj_scan_token(157)) {
                                                                                                                            jj_scanpos = xsp;
                                                                                                                            if (jj_scan_token(158)) {
                                                                                                                                jj_scanpos = xsp;
                                                                                                                                if (jj_scan_token(159)) {
                                                                                                                                    jj_scanpos = xsp;
                                                                                                                                    if (jj_scan_token(160)) {
                                                                                                                                        jj_scanpos = xsp;
                                                                                                                                        if (jj_scan_token(161)) {
                                                                                                                                            jj_scanpos = xsp;
                                                                                                                                            if (jj_scan_token(162)) {
                                                                                                                                                jj_scanpos = xsp;
                                                                                                                                                if (jj_scan_token(163)) {
                                                                                                                                                    jj_scanpos = xsp;
                                                                                                                                                    if (jj_scan_token(164)) {
                                                                                                                                                        jj_scanpos = xsp;
                                                                                                                                                        if (jj_scan_token(165)) {
                                                                                                                                                            jj_scanpos = xsp;
                                                                                                                                                            if (jj_scan_token(166)) {
                                                                                                                                                                jj_scanpos = xsp;
                                                                                                                                                                if (jj_scan_token(167)) {
                                                                                                                                                                    jj_scanpos = xsp;
                                                                                                                                                                    if (jj_scan_token(168)) {
                                                                                                                                                                        jj_scanpos = xsp;
                                                                                                                                                                        if (jj_scan_token(169)) {
                                                                                                                                                                            jj_scanpos = xsp;
                                                                                                                                                                            if (jj_scan_token(170)) {
                                                                                                                                                                                jj_scanpos = xsp;
                                                                                                                                                                                if (jj_scan_token(171)) {
                                                                                                                                                                                    jj_scanpos = xsp;
                                                                                                                                                                                    if (jj_scan_token(172)) {
                                                                                                                                                                                        jj_scanpos = xsp;
                                                                                                                                                                                        if (jj_scan_token(173)) {
                                                                                                                                                                                            jj_scanpos = xsp;
                                                                                                                                                                                            if (jj_scan_token(174)) {
                                                                                                                                                                                                jj_scanpos = xsp;
                                                                                                                                                                                                if (jj_scan_token(175)) {
                                                                                                                                                                                                    jj_scanpos = xsp;
                                                                                                                                                                                                    if (jj_scan_token(176)) {
                                                                                                                                                                                                        jj_scanpos = xsp;
                                                                                                                                                                                                        if (jj_scan_token(177)) {
                                                                                                                                                                                                            jj_scanpos = xsp;
                                                                                                                                                                                                            if (jj_scan_token(178)) {
                                                                                                                                                                                                                jj_scanpos = xsp;
                                                                                                                                                                                                                if (jj_scan_token(179)) {
                                                                                                                                                                                                                    jj_scanpos = xsp;
                                                                                                                                                                                                                    if (jj_scan_token(180)) {
                                                                                                                                                                                                                        jj_scanpos = xsp;
                                                                                                                                                                                                                        if (jj_scan_token(181)) {
                                                                                                                                                                                                                            jj_scanpos = xsp;
                                                                                                                                                                                                                            if (jj_scan_token(182)) {
                                                                                                                                                                                                                                jj_scanpos = xsp;
                                                                                                                                                                                                                                if (jj_scan_token(183)) {
                                                                                                                                                                                                                                    jj_scanpos = xsp;
                                                                                                                                                                                                                                    if (jj_scan_token(184)) {
                                                                                                                                                                                                                                        jj_scanpos = xsp;
                                                                                                                                                                                                                                        if (jj_scan_token(185)) {
                                                                                                                                                                                                                                            jj_scanpos = xsp;
                                                                                                                                                                                                                                            if (jj_scan_token(186)) {
                                                                                                                                                                                                                                                jj_scanpos = xsp;
                                                                                                                                                                                                                                                if (jj_scan_token(187)) {
                                                                                                                                                                                                                                                    jj_scanpos = xsp;
                                                                                                                                                                                                                                                    if (jj_scan_token(188)) {
                                                                                                                                                                                                                                                        jj_scanpos = xsp;
                                                                                                                                                                                                                                                        if (jj_scan_token(189)) {
                                                                                                                                                                                                                                                            jj_scanpos = xsp;
                                                                                                                                                                                                                                                            if (jj_scan_token(190)) {
                                                                                                                                                                                                                                                                jj_scanpos = xsp;
                                                                                                                                                                                                                                                                if (jj_scan_token(191)) {
                                                                                                                                                                                                                                                                    jj_scanpos = xsp;
                                                                                                                                                                                                                                                                    if (jj_scan_token(192)) {
                                                                                                                                                                                                                                                                        jj_scanpos = xsp;
                                                                                                                                                                                                                                                                        if (jj_scan_token(193)) {
                                                                                                                                                                                                                                                                            jj_scanpos = xsp;
                                                                                                                                                                                                                                                                            if (jj_scan_token(194)) {
                                                                                                                                                                                                                                                                                jj_scanpos = xsp;
                                                                                                                                                                                                                                                                                if (jj_scan_token(195)) {
                                                                                                                                                                                                                                                                                    jj_scanpos = xsp;
                                                                                                                                                                                                                                                                                    if (jj_scan_token(196)) {
                                                                                                                                                                                                                                                                                        jj_scanpos = xsp;
                                                                                                                                                                                                                                                                                        if (jj_scan_token(197)) {
                                                                                                                                                                                                                                                                                            jj_scanpos = xsp;
                                                                                                                                                                                                                                                                                            if (jj_scan_token(198)) {
                                                                                                                                                                                                                                                                                                jj_scanpos = xsp;
                                                                                                                                                                                                                                                                                                if (jj_scan_token(199)) {
                                                                                                                                                                                                                                                                                                    jj_scanpos = xsp;
                                                                                                                                                                                                                                                                                                    if (jj_scan_token(200)) {
                                                                                                                                                                                                                                                                                                        jj_scanpos = xsp;
                                                                                                                                                                                                                                                                                                        if (jj_scan_token(201)) {
                                                                                                                                                                                                                                                                                                            jj_scanpos = xsp;
                                                                                                                                                                                                                                                                                                            if (jj_scan_token(202)) {
                                                                                                                                                                                                                                                                                                                jj_scanpos = xsp;
                                                                                                                                                                                                                                                                                                                if (jj_scan_token(203)) {
                                                                                                                                                                                                                                                                                                                    jj_scanpos = xsp;
                                                                                                                                                                                                                                                                                                                    if (jj_scan_token(204)) {
                                                                                                                                                                                                                                                                                                                        jj_scanpos = xsp;
                                                                                                                                                                                                                                                                                                                        if (jj_scan_token(205)) {
                                                                                                                                                                                                                                                                                                                            jj_scanpos = xsp;
                                                                                                                                                                                                                                                                                                                            if (jj_scan_token(206)) {
                                                                                                                                                                                                                                                                                                                                jj_scanpos = xsp;
                                                                                                                                                                                                                                                                                                                                if (jj_scan_token(207)) {
                                                                                                                                                                                                                                                                                                                                    jj_scanpos = xsp;
                                                                                                                                                                                                                                                                                                                                    if (jj_scan_token(208)) {
                                                                                                                                                                                                                                                                                                                                        jj_scanpos = xsp;
                                                                                                                                                                                                                                                                                                                                        if (jj_scan_token(209)) {
                                                                                                                                                                                                                                                                                                                                            jj_scanpos = xsp;
                                                                                                                                                                                                                                                                                                                                            if (jj_scan_token(210)) {
                                                                                                                                                                                                                                                                                                                                                jj_scanpos = xsp;
                                                                                                                                                                                                                                                                                                                                                if (jj_scan_token(211)) {
                                                                                                                                                                                                                                                                                                                                                    jj_scanpos = xsp;
                                                                                                                                                                                                                                                                                                                                                    if (jj_scan_token(212)) {
                                                                                                                                                                                                                                                                                                                                                        jj_scanpos = xsp;
                                                                                                                                                                                                                                                                                                                                                        if (jj_scan_token(213)) {
                                                                                                                                                                                                                                                                                                                                                            jj_scanpos = xsp;
                                                                                                                                                                                                                                                                                                                                                            if (jj_scan_token(214)) {
                                                                                                                                                                                                                                                                                                                                                                jj_scanpos = xsp;
                                                                                                                                                                                                                                                                                                                                                                if (jj_scan_token(215)) {
                                                                                                                                                                                                                                                                                                                                                                    jj_scanpos = xsp;
                                                                                                                                                                                                                                                                                                                                                                    if (jj_scan_token(216)) {
                                                                                                                                                                                                                                                                                                                                                                        jj_scanpos = xsp;
                                                                                                                                                                                                                                                                                                                                                                        if (jj_scan_token(217)) {
                                                                                                                                                                                                                                                                                                                                                                            jj_scanpos = xsp;
                                                                                                                                                                                                                                                                                                                                                                            if (jj_scan_token(218)) {
                                                                                                                                                                                                                                                                                                                                                                                jj_scanpos = xsp;
                                                                                                                                                                                                                                                                                                                                                                                if (jj_scan_token(219)) {
                                                                                                                                                                                                                                                                                                                                                                                    jj_scanpos = xsp;
                                                                                                                                                                                                                                                                                                                                                                                    if (jj_scan_token(220)) {
                                                                                                                                                                                                                                                                                                                                                                                        jj_scanpos = xsp;
                                                                                                                                                                                                                                                                                                                                                                                        if (jj_scan_token(221)) {
                                                                                                                                                                                                                                                                                                                                                                                            jj_scanpos = xsp;
                                                                                                                                                                                                                                                                                                                                                                                            if (jj_scan_token(222)) {
                                                                                                                                                                                                                                                                                                                                                                                                jj_scanpos = xsp;
                                                                                                                                                                                                                                                                                                                                                                                                if (jj_scan_token(223)) {
                                                                                                                                                                                                                                                                                                                                                                                                    jj_scanpos = xsp;
                                                                                                                                                                                                                                                                                                                                                                                                    if (jj_scan_token(224)) {
                                                                                                                                                                                                                                                                                                                                                                                                        jj_scanpos = xsp;
                                                                                                                                                                                                                                                                                                                                                                                                        if (jj_scan_token(225)) {
                                                                                                                                                                                                                                                                                                                                                                                                            jj_scanpos = xsp;
                                                                                                                                                                                                                                                                                                                                                                                                            if (jj_scan_token(226)) {
                                                                                                                                                                                                                                                                                                                                                                                                                jj_scanpos = xsp;
                                                                                                                                                                                                                                                                                                                                                                                                                if (jj_scan_token(227)) {
                                                                                                                                                                                                                                                                                                                                                                                                                    jj_scanpos = xsp;
                                                                                                                                                                                                                                                                                                                                                                                                                    if (jj_scan_token(228)) {
                                                                                                                                                                                                                                                                                                                                                                                                                        jj_scanpos = xsp;
                                                                                                                                                                                                                                                                                                                                                                                                                        if (jj_scan_token(229)) {
                                                                                                                                                                                                                                                                                                                                                                                                                            jj_scanpos = xsp;
                                                                                                                                                                                                                                                                                                                                                                                                                            return jj_scan_token(230);
                                                                                                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                }
                                                                                                                                                                                                                            }
                                                                                                                                                                                                                        }
                                                                                                                                                                                                                    }
                                                                                                                                                                                                                }
                                                                                                                                                                                                            }
                                                                                                                                                                                                        }
                                                                                                                                                                                                    }
                                                                                                                                                                                                }
                                                                                                                                                                                            }
                                                                                                                                                                                        }
                                                                                                                                                                                    }
                                                                                                                                                                                }
                                                                                                                                                                            }
                                                                                                                                                                        }
                                                                                                                                                                    }
                                                                                                                                                                }
                                                                                                                                                            }
                                                                                                                                                        }
                                                                                                                                                    }
                                                                                                                                                }
                                                                                                                                            }
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                }
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        return false;
    }

    private boolean jj_3R_280() {
        if (jj_scan_token(COMMA)) return true;
        return jj_3R_67();
    }

    private boolean jj_3_63() {
        return jj_scan_token(DOT);
    }

    private boolean jj_3R_143() {
        if (jj_scan_token(COMMA)) return true;
        return jj_scan_token(IDENTIFIER);
    }

    private boolean jj_3R_101() {
        return jj_3R_154();
    }

    private boolean jj_3R_258() {
        return false;
    }

    private boolean jj_3R_234() {
        if (jj_3R_67()) return true;
        Token xsp;
        while (true) {
            xsp = jj_scanpos;
            if (jj_3R_280()) {
                jj_scanpos = xsp;
                break;
            }
        }
        return false;
    }

    private boolean jj_3R_233() {
        return jj_3R_146();
    }

    private boolean jj_3_62() {
        return jj_3R_102();
    }

    private boolean jj_3R_230() {
        final Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_233()) {
            jj_scanpos = xsp;
            if (jj_3R_234()) return true;
        }
        if (jj_scan_token(IN)) return true;
        return jj_3R_63();
    }

    private boolean jj_3R_100() {
        if (jj_scan_token(DOT)) return true;
        final Token xsp;
        lookingAhead = true;
        jj_semLA = BStack.aboveReference(getToken(1).beginColumn);
        lookingAhead = false;
        if (!jj_semLA || jj_3R_258()) return true;
        return jj_3R_67();
    }

    private boolean jj_3_13() {
        return jj_scan_token(op_76);
    }

    private boolean jj_3R_145() {
        final Token xsp;
        xsp = jj_scanpos;
        if (jj_scan_token(119)) {
            jj_scanpos = xsp;
            if (jj_scan_token(120)) {
                jj_scanpos = xsp;
                if (jj_scan_token(121)) {
                    jj_scanpos = xsp;
                    if (jj_scan_token(122)) {
                        jj_scanpos = xsp;
                        if (jj_scan_token(123)) {
                            jj_scanpos = xsp;
                            if (jj_scan_token(118)) {
                                jj_scanpos = xsp;
                                if (jj_scan_token(124)) {
                                    jj_scanpos = xsp;
                                    if (jj_scan_token(125)) {
                                        jj_scanpos = xsp;
                                        if (jj_scan_token(126)) {
                                            jj_scanpos = xsp;
                                            if (jj_scan_token(127)) {
                                                jj_scanpos = xsp;
                                                return jj_scan_token(128);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        return false;
    }

    private boolean jj_3R_83() {
        if (jj_scan_token(IDENTIFIER)) return true;
        Token xsp;
        while (true) {
            xsp = jj_scanpos;
            if (jj_3R_143()) {
                jj_scanpos = xsp;
                break;
            }
        }
        return jj_scan_token(IN);
    }

    private boolean jj_3_36() {
        final Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_83()) {
            jj_scanpos = xsp;
            return jj_scan_token(103);
        }
        return false;
    }

    private boolean jj_3_14() {
        return jj_3R_63();
    }

    private boolean jj_3R_99() {
        return jj_3R_102();
    }

    private boolean jj_3_61() {
        final Token xsp;
        xsp = jj_scanpos;
        lookingAhead = true;
        jj_semLA = BStack.aboveReference(getToken(1).beginColumn);
        lookingAhead = false;
        if (!jj_semLA || jj_3R_99()) {
            jj_scanpos = xsp;
            lookingAhead = true;
            jj_semLA = BStack.aboveReference(getToken(1).beginColumn);
            lookingAhead = false;
            if (!jj_semLA || jj_3R_100()) {
                jj_scanpos = xsp;
                lookingAhead = true;
                jj_semLA = BStack.aboveReference(getToken(1).beginColumn);
                lookingAhead = false;
                return !jj_semLA || jj_3R_101();
            }
        }
        return false;
    }

    private boolean jj_3_60() {
        return jj_3R_98();
    }

    private boolean jj_3R_254() {
        if (jj_scan_token(COMMA)) return true;
        return jj_3R_67();
    }

    private boolean jj_3R_89() {
        if (jj_scan_token(COMMA)) return true;
        return jj_scan_token(IDENTIFIER);
    }

    private boolean jj_3R_190() {
        return jj_3R_202();
    }

    private boolean jj_3_59() {
        final Token xsp;
        xsp = jj_scanpos;
        if (jj_scan_token(130)) {
            jj_scanpos = xsp;
            return jj_scan_token(133);
        }
        return false;
    }

    private boolean jj_3R_196() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_scan_token(59)) {
            jj_scanpos = xsp;
            if (jj_scan_token(60)) return true;
        }
        if (jj_3R_67()) return true;
        while (true) {
            xsp = jj_scanpos;
            if (jj_3R_254()) {
                jj_scanpos = xsp;
                break;
            }
        }
        if (jj_scan_token(COLON)) return true;
        return jj_3R_63();
    }

    private boolean jj_3R_189() {
        return jj_3R_201();
    }

    private boolean jj_3R_150() {
        final Token xsp;
        xsp = jj_scanpos;
        if (jj_scan_token(119)) {
            jj_scanpos = xsp;
            if (jj_scan_token(120)) {
                jj_scanpos = xsp;
                if (jj_scan_token(121)) {
                    jj_scanpos = xsp;
                    if (jj_scan_token(122)) {
                        jj_scanpos = xsp;
                        if (jj_scan_token(123)) {
                            jj_scanpos = xsp;
                            if (jj_scan_token(124)) {
                                jj_scanpos = xsp;
                                if (jj_scan_token(125)) {
                                    jj_scanpos = xsp;
                                    if (jj_scan_token(126)) {
                                        jj_scanpos = xsp;
                                        if (jj_scan_token(127)) {
                                            jj_scanpos = xsp;
                                            return jj_scan_token(128);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        return false;
    }

    private boolean jj_3R_263() {
        if (jj_scan_token(COMMA)) return true;
        return jj_3R_230();
    }

    private boolean jj_3_44() {
        if (jj_scan_token(IDENTIFIER)) return true;
        Token xsp;
        while (true) {
            xsp = jj_scanpos;
            if (jj_3R_89()) {
                jj_scanpos = xsp;
                break;
            }
        }
        return jj_scan_token(COLON);
    }

    private boolean jj_3R_169() {
        Token xsp;
        xsp = jj_scanpos;
        lookingAhead = true;
        jj_semLA = OperatorStack.preInEmptyTop();
        lookingAhead = false;
        if (!jj_semLA || jj_3R_189()) {
            jj_scanpos = xsp;
            if (jj_3R_190()) {
                jj_scanpos = xsp;
                if (jj_3_60()) return true;
            }
        }
        while (true) {
            xsp = jj_scanpos;
            if (jj_3_61()) {
                jj_scanpos = xsp;
                break;
            }
        }
        if (jj_3_69()) jj_scanpos = xsp;
        return false;
    }

    private boolean jj_3R_262() {
        if (jj_scan_token(COMMA)) return true;
        return jj_3R_67();
    }

    private boolean jj_3R_224() {
        if (jj_3R_230()) return true;
        Token xsp;
        while (true) {
            xsp = jj_scanpos;
            if (jj_3R_263()) {
                jj_scanpos = xsp;
                break;
            }
        }
        return false;
    }

    private boolean jj_3R_223() {
        if (jj_3R_67()) return true;
        Token xsp;
        while (true) {
            xsp = jj_scanpos;
            if (jj_3R_262()) {
                jj_scanpos = xsp;
                break;
            }
        }
        return false;
    }

    private boolean jj_3R_195() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_scan_token(46)) {
            jj_scanpos = xsp;
            if (jj_scan_token(48)) return true;
        }
        xsp = jj_scanpos;
        if (jj_3R_223()) {
            jj_scanpos = xsp;
            if (jj_3R_224()) return true;
        }
        if (jj_scan_token(COLON)) return true;
        return jj_3R_63();
    }

    private boolean jj_3_58() {
        return jj_3R_97();
    }

    private boolean jj_3R_128() {
        return jj_3R_169();
    }

    private boolean jj_3R_127() {
        return jj_3R_168();
    }

    private boolean jj_3_35() {
        return jj_3R_59();
    }

    private boolean jj_3R_217() {
        if (jj_scan_token(LBR)) return true;
        if (jj_3R_63()) return true;
        return jj_scan_token(RBR);
    }

    private boolean jj_3R_132() {
        return jj_3R_102();
    }

    private boolean jj_3R_131() {
        return jj_3R_104();
    }

    private boolean jj_3R_130() {
        return jj_3R_155();
    }

    private boolean jj_3R_96() {
        return jj_3R_150();
    }

    private boolean jj_3_57() {
        final Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_96()) {
            jj_scanpos = xsp;
            return jj_scan_token(194);
        }
        return false;
    }

    private boolean jj_3R_129() {
        return jj_3R_67();
    }

    private boolean jj_3R_167() {
        return jj_3R_104();
    }

    private boolean jj_3R_66() {
        final Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_129()) {
            jj_scanpos = xsp;
            if (jj_3R_130()) {
                jj_scanpos = xsp;
                if (jj_3R_131()) {
                    jj_scanpos = xsp;
                    if (jj_3R_132()) return true;
                }
            }
        }
        if (jj_scan_token(SUBSTITUTE)) return true;
        return jj_3R_174();
    }

    private boolean jj_3R_166() {
        return jj_3R_182();
    }

    private boolean jj_3R_126() {
        final Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_166()) {
            jj_scanpos = xsp;
            return jj_3R_167();
        }
        return false;
    }

    private boolean jj_3R_63() {
        Token xsp;
        while (true) {
            xsp = jj_scanpos;
            if (jj_3R_126()) {
                jj_scanpos = xsp;
                break;
            }
        }
        lookingAhead = true;
        jj_semLA = BStack.aboveReference(getToken(1).beginColumn);
        lookingAhead = false;
        if (!jj_semLA || jj_3R_127()) {
            jj_scanpos = xsp;
            lookingAhead = true;
            jj_semLA = BStack.aboveReference(getToken(1).beginColumn);
            lookingAhead = false;
            return !jj_semLA || jj_3R_128();
        }
        return false;
    }

    private boolean jj_3_34() {
        return jj_3R_82();
    }

    private boolean jj_3R_229() {
        if (jj_scan_token(COMMA)) return true;
        return jj_3R_67();
    }

    private boolean jj_3_12() {
        if (jj_scan_token(COMMA)) return true;
        return jj_3R_66();
    }

    private boolean jj_3R_206() {
        if (jj_scan_token(LAMBDA)) return true;
        if (jj_3R_67()) return true;
        Token xsp;
        while (true) {
            xsp = jj_scanpos;
            if (jj_3R_229()) {
                jj_scanpos = xsp;
                break;
            }
        }
        if (jj_scan_token(COLON)) return true;
        return jj_3R_63();
    }

    private boolean jj_3R_318() {
        if (jj_scan_token(WITH)) return true;
        if (jj_3R_66()) return true;
        Token xsp;
        while (true) {
            xsp = jj_scanpos;
            if (jj_3_12()) {
                jj_scanpos = xsp;
                break;
            }
        }
        return false;
    }

    private boolean jj_3R_88() {
        return jj_3R_64();
    }

    private boolean jj_3R_125() {
        if (jj_scan_token(INSTANCE)) return true;
        if (jj_3R_67()) return true;
        final Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_318()) jj_scanpos = xsp;
        return false;
    }

    private boolean jj_3R_149() {
        return jj_3R_174();
    }

    private boolean jj_3R_228() {
        return jj_3R_146();
    }

    private boolean jj_3R_227() {
        return jj_3R_67();
    }

    private boolean jj_3R_124() {
        return jj_scan_token(LOCAL);
    }

    private boolean jj_3R_200() {
        if (jj_scan_token(CHOOSE)) return true;
        final Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_227()) {
            jj_scanpos = xsp;
            if (jj_3R_228()) return true;
        }
        if (jj_3R_257()) return true;
        if (jj_scan_token(COLON)) return true;
        return jj_3R_63();
    }

    private boolean jj_3R_60() {
        final Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_124()) jj_scanpos = xsp;
        return jj_3R_125();
    }

    private boolean jj_3R_87() {
        return jj_3R_65();
    }

    private boolean jj_3_42() {
        return jj_scan_token(LAMBDA);
    }

    private boolean jj_3_43() {
        return jj_3R_63();
    }

    private boolean jj_3R_139() {
        return jj_3R_140();
    }

    private boolean jj_3R_324() {
        return jj_3R_102();
    }

    private boolean jj_3R_194() {
        return jj_3R_206();
    }

    private boolean jj_3R_205() {
        return jj_3R_102();
    }

    private boolean jj_3R_323() {
        if (jj_3R_104()) return true;
        return jj_scan_token(US);
    }

    private boolean jj_3R_86() {
        return jj_3R_145();
    }

    private boolean jj_3_41() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_86()) {
            jj_scanpos = xsp;
            if (jj_3R_87()) {
                jj_scanpos = xsp;
                if (jj_3R_88()) return true;
            }
        }
        xsp = jj_scanpos;
        if (jj_scan_token(87)) {
            jj_scanpos = xsp;
            if (jj_scan_token(94)) {
                jj_scanpos = xsp;
                if (jj_scan_token(95)) {
                    jj_scanpos = xsp;
                    if (jj_scan_token(53)) {
                        jj_scanpos = xsp;
                        if (jj_scan_token(50)) {
                            jj_scanpos = xsp;
                            if (jj_scan_token(66)) {
                                jj_scanpos = xsp;
                                if (jj_scan_token(38)) {
                                    jj_scanpos = xsp;
                                    if (jj_scan_token(36)) {
                                        jj_scanpos = xsp;
                                        if (jj_scan_token(35)) {
                                            jj_scanpos = xsp;
                                            if (jj_scan_token(34)) {
                                                jj_scanpos = xsp;
                                                if (jj_scan_token(40)) {
                                                    jj_scanpos = xsp;
                                                    if (jj_scan_token(43)) {
                                                        jj_scanpos = xsp;
                                                        if (jj_scan_token(84)) {
                                                            jj_scanpos = xsp;
                                                            return jj_scan_token(78);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        return false;
    }

    private boolean jj_3R_222() {
        final Token xsp;
        xsp = jj_scanpos;
        if (jj_scan_token(133)) {
            jj_scanpos = xsp;
            if (jj_scan_token(130)) return true;
        }
        return jj_3R_63();
    }

    private boolean jj_3R_204() {
        return jj_3R_104();
    }

    private boolean jj_3R_203() {
        return jj_3R_155();
    }

    private boolean jj_3R_171() {
        if (jj_scan_token(US)) return true;
        final Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_323()) {
            jj_scanpos = xsp;
            return jj_3R_324();
        }
        return false;
    }

    private boolean jj_3R_170() {
        if (jj_3R_155()) return true;
        return jj_scan_token(US);
    }

    private boolean jj_3_56() {
        return jj_scan_token(AND);
    }

    private boolean jj_3R_269() {
        return jj_3R_222();
    }

    private boolean jj_3R_193() {
        final Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_203()) {
            jj_scanpos = xsp;
            if (jj_3R_204()) {
                jj_scanpos = xsp;
                return jj_3R_205();
            }
        }
        return false;
    }

    private boolean jj_3R_134() {
        final Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_170()) {
            jj_scanpos = xsp;
            return jj_3R_171();
        }
        return false;
    }

    private boolean jj_3_55() {
        return jj_scan_token(OR);
    }

    private boolean jj_3R_174() {
        final Token xsp;
        xsp = jj_scanpos;
        lookingAhead = true;
        jj_semLA = BStack.aboveReference(getToken(1).beginColumn);
        lookingAhead = false;
        if (!jj_semLA || jj_3R_193()) {
            jj_scanpos = xsp;
            lookingAhead = true;
            jj_semLA = BStack.aboveReference(getToken(1).beginColumn);
            lookingAhead = false;
            if (!jj_semLA || jj_3R_194()) {
                jj_scanpos = xsp;
                return jj_3_43();
            }
        }
        return false;
    }

    private boolean jj_3R_216() {
        if (jj_3R_222()) return true;
        Token xsp;
        while (true) {
            xsp = jj_scanpos;
            if (jj_3R_269()) {
                jj_scanpos = xsp;
                break;
            }
        }
        return false;
    }

    private boolean jj_3R_268() {
        return jj_3R_222();
    }

    private boolean jj_3R_215() {
        if (jj_3R_222()) return true;
        Token xsp;
        while (true) {
            xsp = jj_scanpos;
            if (jj_3R_268()) {
                jj_scanpos = xsp;
                break;
            }
        }
        return false;
    }

    private boolean jj_3R_322() {
        if (jj_scan_token(COMMA)) return true;
        return jj_scan_token(US);
    }

    private boolean jj_3R_208() {
        return jj_3R_216();
    }

    private boolean jj_3R_133() {
        if (jj_scan_token(LBR)) return true;
        if (jj_scan_token(US)) return true;
        Token xsp;
        while (true) {
            xsp = jj_scanpos;
            if (jj_3R_322()) {
                jj_scanpos = xsp;
                break;
            }
        }
        return jj_scan_token(RBR);
    }

    private boolean jj_3R_207() {
        return jj_3R_215();
    }

    private boolean jj_3R_201() {
        final Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_207()) {
            jj_scanpos = xsp;
            return jj_3R_208();
        }
        return false;
    }

    private boolean jj_3R_68() {
        if (jj_3R_67()) return true;
        final Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_133()) jj_scanpos = xsp;
        return false;
    }

    private boolean jj_3R_80() {
        return jj_3R_140();
    }

    private boolean jj_3R_162() {
        if (jj_3R_67()) return true;
        return jj_3R_64();
    }

    private boolean jj_3R_236() {
        return jj_3R_115();
    }

    private boolean jj_3R_235() {
        return jj_3R_59();
    }

    private boolean jj_3R_231() {
        final Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_235()) {
            jj_scanpos = xsp;
            return jj_3R_236();
        }
        return false;
    }

    private boolean jj_3R_226() {
        Token xsp;
        if (jj_3R_231()) return true;
        while (true) {
            xsp = jj_scanpos;
            if (jj_3R_231()) {
                jj_scanpos = xsp;
                break;
            }
        }
        return false;
    }

    private boolean jj_3R_140() {
        final Token xsp;
        xsp = jj_scanpos;
        if (jj_scan_token(232)) {
            jj_scanpos = xsp;
            if (jj_scan_token(233)) {
                jj_scanpos = xsp;
                if (jj_scan_token(234)) {
                    jj_scanpos = xsp;
                    if (jj_scan_token(235)) {
                        jj_scanpos = xsp;
                        return jj_scan_token(236);
                    }
                }
            }
        }
        return false;
    }

    private boolean jj_3R_163() {
        if (jj_3R_67()) return true;
        if (jj_3R_65()) return true;
        return jj_3R_67();
    }

    private boolean jj_3R_321() {
        return jj_3R_134();
    }

    private boolean jj_3R_199() {
        if (jj_scan_token(LET)) return true;
        if (jj_3R_226()) return true;
        if (jj_scan_token(LETIN)) return true;
        return jj_3R_63();
    }

    private boolean jj_3R_316() {
        return jj_3R_134();
    }

    private boolean jj_3_33() {
        return jj_3R_63();
    }

    private boolean jj_3R_165() {
        if (jj_3R_145()) return true;
        return jj_3R_67();
    }

    private boolean jj_3_32() {
        return jj_3R_63();
    }

    private boolean jj_3R_320() {
        return jj_3R_68();
    }

    private boolean jj_3R_317() {
        if (jj_scan_token(COMMA)) return true;
        final Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_320()) {
            jj_scanpos = xsp;
            return jj_3R_321();
        }
        return false;
    }

    private boolean jj_3R_264() {
        if (jj_scan_token(OTHER)) return true;
        if (jj_scan_token(ARROW)) return true;
        return jj_3R_63();
    }

    private boolean jj_3R_315() {
        return jj_3R_68();
    }

    private boolean jj_3_30() {
        return jj_3R_63();
    }

    private boolean jj_3R_309() {
        if (jj_scan_token(LBR)) return true;
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_315()) {
            jj_scanpos = xsp;
            if (jj_3R_316()) return true;
        }
        while (true) {
            xsp = jj_scanpos;
            if (jj_3R_317()) {
                jj_scanpos = xsp;
                break;
            }
        }
        return jj_scan_token(RBR);
    }

    private boolean jj_3R_225() {
        if (jj_3R_63()) return true;
        if (jj_scan_token(ARROW)) return true;
        return jj_3R_63();
    }

    private boolean jj_3R_164() {
        if (jj_3R_67()) return true;
        final Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_309()) jj_scanpos = xsp;
        return false;
    }

    private boolean jj_3_29() {
        return jj_3R_63();
    }

    private boolean jj_3R_81() {
        return jj_scan_token(MODULE);
    }

    private boolean jj_3R_191() {
        if (jj_scan_token(COMMA)) return true;
        return jj_3R_149();
    }

    private boolean jj_3_31() {
        final Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_81()) {
            jj_scanpos = xsp;
            return jj_3_29();
        }
        return false;
    }

    private boolean jj_3R_95() {
        if (jj_scan_token(LBR)) return true;
        if (jj_3R_149()) return true;
        Token xsp;
        while (true) {
            xsp = jj_scanpos;
            if (jj_3R_191()) {
                jj_scanpos = xsp;
                break;
            }
        }
        return jj_scan_token(RBR);
    }

    private boolean jj_3R_256() {
        if (jj_scan_token(CASESEP)) return true;
        return jj_3R_264();
    }

    private boolean jj_3R_161() {
        return jj_scan_token(HIDE);
    }

    private boolean jj_3R_192() {
        if (jj_scan_token(COMMA)) return true;
        return jj_3R_67();
    }

    private boolean jj_3R_255() {
        if (jj_scan_token(CASESEP)) return true;
        return jj_3R_225();
    }

    private boolean jj_3R_160() {
        return jj_scan_token(USE);
    }

    private boolean jj_3R_173() {
        if (jj_3R_67()) return true;
        Token xsp;
        while (true) {
            xsp = jj_scanpos;
            if (jj_3R_192()) {
                jj_scanpos = xsp;
                break;
            }
        }
        return false;
    }

    private boolean jj_3R_198() {
        if (jj_scan_token(CASE)) return true;
        if (jj_3R_225()) return true;
        Token xsp;
        while (true) {
            xsp = jj_scanpos;
            if (jj_3R_255()) {
                jj_scanpos = xsp;
                break;
            }
        }
        if (jj_3R_256()) jj_scanpos = xsp;
        return false;
    }

    private boolean jj_3R_181() {
        return jj_scan_token(PROOF);
    }

    private boolean jj_3R_159() {
        final Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_181()) jj_scanpos = xsp;
        return jj_scan_token(BY);
    }

    private boolean jj_3R_146() {
        if (jj_scan_token(LAB)) return true;
        final Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_173()) jj_scanpos = xsp;
        return jj_scan_token(RAB);
    }

    private boolean jj_3R_117() {
        final Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_159()) {
            jj_scanpos = xsp;
            if (jj_3R_160()) {
                jj_scanpos = xsp;
                return jj_3R_161();
            }
        }
        return false;
    }

    private boolean jj_3R_197() {
        if (jj_scan_token(IF)) return true;
        if (jj_3R_63()) return true;
        if (jj_scan_token(THEN)) return true;
        if (jj_3R_63()) return true;
        if (jj_scan_token(ELSE)) return true;
        return jj_3R_63();
    }

    private boolean jj_3_11() {
        if (jj_scan_token(IDENTIFIER)) return true;
        final Token xsp;
        xsp = jj_scanpos;
        if (jj_scan_token(93)) {
            jj_scanpos = xsp;
            return jj_scan_token(92);
        }
        return false;
    }

    private boolean jj_3R_299() {
        return jj_3R_125();
    }

    private boolean jj_3_7() {
        return jj_3R_63();
    }

    private boolean jj_3R_123() {
        if (jj_3R_165()) return true;
        if (jj_scan_token(DEF)) return true;
        return jj_3R_63();
    }

    private boolean jj_3_10() {
        if (jj_scan_token(IDENTIFIER)) return true;
        return jj_3R_65();
    }

    private boolean jj_3R_122() {
        if (jj_3R_164()) return true;
        if (jj_scan_token(DEF)) return true;
        final Token xsp;
        xsp = jj_scanpos;
        if (jj_3_7()) {
            jj_scanpos = xsp;
            return jj_3R_299();
        }
        return false;
    }

    private boolean jj_3_9() {
        if (jj_scan_token(IDENTIFIER)) return true;
        return jj_3R_64();
    }

    private boolean jj_3R_79() {
        return jj_3R_139();
    }

    private boolean jj_3_26() {
        return jj_scan_token(PROOF);
    }

    private boolean jj_3R_121() {
        if (jj_3R_163()) return true;
        if (jj_scan_token(DEF)) return true;
        return jj_3R_63();
    }

    private boolean jj_3_28() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3_26()) jj_scanpos = xsp;
        while (true) {
            xsp = jj_scanpos;
            if (jj_3R_79()) {
                jj_scanpos = xsp;
                break;
            }
        }
        return jj_3R_80();
    }

    private boolean jj_3R_120() {
        if (jj_3R_162()) return true;
        if (jj_scan_token(DEF)) return true;
        return jj_3R_63();
    }

    private boolean jj_3_27() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_scan_token(74)) jj_scanpos = xsp;
        xsp = jj_scanpos;
        if (jj_scan_token(70)) {
            jj_scanpos = xsp;
            return jj_scan_token(71);
        }
        return false;
    }

    private boolean jj_3R_298() {
        if (jj_scan_token(COMMA)) return true;
        return jj_3R_230();
    }

    private boolean jj_3_8() {
        if (jj_scan_token(IDENTIFIER)) return true;
        return jj_scan_token(LSB);
    }

    private boolean jj_3_54() {
        if (jj_scan_token(LBR)) return true;
        if (jj_3R_63()) return true;
        return jj_scan_token(RBR);
    }

    private boolean jj_3R_119() {
        if (jj_3R_67()) return true;
        if (jj_scan_token(LSB)) return true;
        if (jj_3R_230()) return true;
        Token xsp;
        while (true) {
            xsp = jj_scanpos;
            if (jj_3R_298()) {
                jj_scanpos = xsp;
                break;
            }
        }
        if (jj_scan_token(RSB)) return true;
        if (jj_scan_token(DEF)) return true;
        return jj_3R_63();
    }

    private boolean jj_3R_118() {
        return jj_scan_token(LOCAL);
    }

    private boolean jj_3R_221() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_scan_token(85)) {
            jj_scanpos = xsp;
            if (jj_scan_token(58)) return true;
        }
        if (jj_3R_243()) return true;
        xsp = jj_scanpos;
        if (jj_3_54()) jj_scanpos = xsp;
        return false;
    }

    private boolean jj_3R_59() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_118()) jj_scanpos = xsp;
        if (jj_scan_token(DEFBREAK)) return true;
        xsp = jj_scanpos;
        if (jj_3R_119()) {
            jj_scanpos = xsp;
            if (jj_3R_120()) {
                jj_scanpos = xsp;
                if (jj_3R_121()) {
                    jj_scanpos = xsp;
                    if (jj_3R_122()) {
                        jj_scanpos = xsp;
                        return jj_3R_123();
                    }
                }
            }
        }
        return false;
    }

    private boolean jj_3R_97() {
        final Token xsp;
        xsp = jj_scanpos;
        if (jj_scan_token(41)) {
            jj_scanpos = xsp;
            if (jj_scan_token(42)) {
                jj_scanpos = xsp;
                if (jj_scan_token(46)) {
                    jj_scanpos = xsp;
                    if (jj_scan_token(48)) {
                        jj_scanpos = xsp;
                        if (jj_scan_token(49)) {
                            jj_scanpos = xsp;
                            if (jj_scan_token(51)) {
                                jj_scanpos = xsp;
                                if (jj_scan_token(59)) {
                                    jj_scanpos = xsp;
                                    return jj_scan_token(60);
                                }
                            }
                        }
                    }
                }
            }
        }
        return false;
    }

    private boolean jj_3R_252() {
        return jj_3R_220();
    }

    private boolean jj_3_40() {
        if (jj_scan_token(DOT)) return true;
        return jj_scan_token(NUMBER_LITERAL);
    }

    private boolean jj_3R_251() {
        return jj_3R_219();
    }

    private boolean jj_3R_250() {
        return jj_3R_154();
    }

    private boolean jj_3R_249() {
        return jj_3R_218();
    }

    private boolean jj_3R_185() {
        return jj_3R_197();
    }

    private boolean jj_3R_175() {
        if (jj_scan_token(NUMBER_LITERAL)) return true;
        final Token xsp;
        xsp = jj_scanpos;
        if (jj_3_40()) jj_scanpos = xsp;
        return false;
    }

    private boolean jj_3R_248() {
        return jj_3R_217();
    }

    private boolean jj_3R_247() {
        return jj_3R_253();
    }

    private boolean jj_3R_311() {
        return jj_3R_102();
    }

    private boolean jj_3R_243() {
        final Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_247()) {
            jj_scanpos = xsp;
            if (jj_3R_248()) {
                jj_scanpos = xsp;
                if (jj_3R_249()) {
                    jj_scanpos = xsp;
                    if (jj_3R_250()) {
                        jj_scanpos = xsp;
                        if (jj_3R_251()) {
                            jj_scanpos = xsp;
                            return jj_3R_252();
                        }
                    }
                }
            }
        }
        return false;
    }

    private boolean jj_3R_310() {
        if (jj_3R_104()) return true;
        return jj_scan_token(US);
    }

    private boolean jj_3R_188() {
        return jj_3R_200();
    }

    private boolean jj_3R_107() {
        return jj_scan_token(STRING_LITERAL);
    }

    private boolean jj_3R_302() {
        if (jj_scan_token(US)) return true;
        final Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_310()) {
            jj_scanpos = xsp;
            return jj_3R_311();
        }
        return false;
    }

    private boolean jj_3R_301() {
        if (jj_3R_155()) return true;
        return jj_scan_token(US);
    }

    private boolean jj_3R_184() {
        return jj_3R_196();
    }

    private boolean jj_3R_319() {
        if (jj_scan_token(COMMA)) return true;
        return jj_scan_token(US);
    }

    private boolean jj_3R_187() {
        return jj_3R_199();
    }

    private boolean jj_3R_214() {
        return jj_3R_221();
    }

    private boolean jj_3R_211() {
        return jj_3R_154();
    }

    private boolean jj_3R_308() {
        if (jj_scan_token(BANG)) return true;
        return jj_3R_253();
    }

    private boolean jj_3R_186() {
        return jj_3R_198();
    }

    private boolean jj_3R_183() {
        return jj_3R_195();
    }

    private boolean jj_3R_168() {
        final Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_183()) {
            jj_scanpos = xsp;
            if (jj_3R_184()) {
                jj_scanpos = xsp;
                if (jj_3R_185()) {
                    jj_scanpos = xsp;
                    if (jj_3R_186()) {
                        jj_scanpos = xsp;
                        if (jj_3R_187()) {
                            jj_scanpos = xsp;
                            return jj_3R_188();
                        }
                    }
                }
            }
        }
        return false;
    }

    private boolean jj_3_6() {
        if (jj_scan_token(LBR)) return true;
        if (jj_scan_token(US)) return true;
        Token xsp;
        while (true) {
            xsp = jj_scanpos;
            if (jj_3R_319()) {
                jj_scanpos = xsp;
                break;
            }
        }
        return jj_scan_token(RBR);
    }

    private boolean jj_3_53() {
        return jj_3R_95();
    }

    private boolean jj_3R_253() {
        if (jj_3R_67()) return true;
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3_53()) jj_scanpos = xsp;
        xsp = jj_scanpos;
        if (jj_3R_308()) jj_scanpos = xsp;
        return false;
    }

    private boolean jj_3R_300() {
        if (jj_3R_67()) return true;
        final Token xsp;
        xsp = jj_scanpos;
        if (jj_3_6()) jj_scanpos = xsp;
        return false;
    }

    private boolean jj_3R_289() {
        final Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_300()) {
            jj_scanpos = xsp;
            if (jj_3R_301()) {
                jj_scanpos = xsp;
                return jj_3R_302();
            }
        }
        return false;
    }

    private boolean jj_3R_213() {
        return jj_3R_220();
    }

    private boolean jj_3_25() {
        return jj_3R_63();
    }

    private boolean jj_3R_210() {
        return jj_3R_218();
    }

    private boolean jj_3R_77() {
        return false;
    }

    private boolean jj_3_24() {
        final Token xsp;
        lookingAhead = true;
        jj_semLA = getToken(1).kind == ASSUME || getToken(1).kind == BOXASSUME;
        lookingAhead = false;
        if (!jj_semLA || jj_3R_77()) return true;
        return jj_3R_78();
    }

    private boolean jj_3R_242() {
        if (jj_scan_token(ARAB)) return true;
        return jj_3R_243();
    }

    private boolean jj_3R_241() {
        return jj_scan_token(RAB);
    }

    private boolean jj_3R_284() {
        if (jj_scan_token(COMMA)) return true;
        return jj_3R_63();
    }

    private boolean jj_3_23() {
        if (jj_3R_67()) return true;
        return jj_scan_token(DEF);
    }

    private boolean jj_3R_290() {
        if (jj_scan_token(COMMA)) return true;
        return jj_3R_289();
    }

    private boolean jj_3_52() {
        if (jj_3R_63()) return true;
        Token xsp;
        while (true) {
            xsp = jj_scanpos;
            if (jj_3R_284()) {
                jj_scanpos = xsp;
                break;
            }
        }
        return false;
    }

    private boolean jj_3R_62() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_scan_token(66)) {
            jj_scanpos = xsp;
            if (jj_scan_token(57)) return true;
        }
        xsp = jj_scanpos;
        if (jj_3_23()) jj_scanpos = xsp;
        xsp = jj_scanpos;
        if (jj_3_24()) {
            jj_scanpos = xsp;
            return jj_3_25();
        }
        return false;
    }

    private boolean jj_3R_220() {
        if (jj_scan_token(LAB)) return true;
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3_52()) jj_scanpos = xsp;
        xsp = jj_scanpos;
        if (jj_3R_241()) {
            jj_scanpos = xsp;
            return jj_3R_242();
        }
        return false;
    }

    private boolean jj_3R_212() {
        return jj_3R_219();
    }

    private boolean jj_3R_115() {
        if (jj_scan_token(RECURSIVE)) return true;
        if (jj_3R_289()) return true;
        Token xsp;
        while (true) {
            xsp = jj_scanpos;
            if (jj_3R_290()) {
                jj_scanpos = xsp;
                break;
            }
        }
        return false;
    }

    private boolean jj_3R_209() {
        return jj_3R_217();
    }

    private boolean jj_3R_202() {
        final Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_209()) {
            jj_scanpos = xsp;
            if (jj_3R_210()) {
                jj_scanpos = xsp;
                if (jj_3R_211()) {
                    jj_scanpos = xsp;
                    if (jj_3R_212()) {
                        jj_scanpos = xsp;
                        if (jj_3R_213()) {
                            jj_scanpos = xsp;
                            return jj_3R_214();
                        }
                    }
                }
            }
        }
        return false;
    }

    private boolean jj_3R_283() {
        return jj_scan_token(IN);
    }

    private boolean jj_3R_156() {
        return jj_3R_175();
    }

    private boolean jj_3R_282() {
        return jj_scan_token(EQUALS);
    }

    private boolean jj_3R_144() {
        return jj_3R_95();
    }

    private boolean jj_3_39() {
        return jj_3R_85();
    }

    private boolean jj_3R_85() {
        if (jj_3R_67()) return true;
        final Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_144()) jj_scanpos = xsp;
        return jj_scan_token(BANG);
    }

    private boolean jj_3R_270() {
        if (jj_scan_token(BANG)) return true;
        if (jj_3R_281()) return true;
        final Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_282()) {
            jj_scanpos = xsp;
            if (jj_3R_283()) return true;
        }
        return jj_3R_63();
    }

    private boolean jj_3R_157() {
        return jj_scan_token(CONSTANT);
    }

    private boolean jj_3R_265() {
        if (jj_scan_token(IN)) return true;
        return jj_3R_63();
    }

    private boolean jj_3R_257() {
        final Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_265()) jj_scanpos = xsp;
        return false;
    }

    private boolean jj_3R_271() {
        if (jj_scan_token(COMMA)) return true;
        return jj_3R_270();
    }

    private boolean jj_3R_219() {
        if (jj_scan_token(LWB)) return true;
        if (jj_3R_63()) return true;
        if (jj_scan_token(EXCEPT)) return true;
        if (jj_3R_270()) return true;
        Token xsp;
        while (true) {
            xsp = jj_scanpos;
            if (jj_3R_271()) {
                jj_scanpos = xsp;
                break;
            }
        }
        return jj_scan_token(RWB);
    }

    private boolean jj_3R_114() {
        return jj_3R_157();
    }

    private boolean jj_3R_307() {
        if (jj_scan_token(COMMA)) return true;
        return jj_3R_63();
    }

    private boolean jj_3R_112() {
        final Token xsp;
        xsp = jj_scanpos;
        if (jj_scan_token(103)) {
            jj_scanpos = xsp;
            if (jj_scan_token(105)) {
                jj_scanpos = xsp;
                if (jj_scan_token(88)) {
                    jj_scanpos = xsp;
                    if (jj_3R_156()) {
                        jj_scanpos = xsp;
                        lookingAhead = true;
                        jj_semLA = getToken(1).image.equals("@");
                        lookingAhead = false;
                        return !jj_semLA || jj_scan_token(231);
                    }
                }
            }
        }
        return false;
    }

    private boolean jj_3R_296() {
        if (jj_scan_token(LSB)) return true;
        if (jj_3R_63()) return true;
        Token xsp;
        while (true) {
            xsp = jj_scanpos;
            if (jj_3R_307()) {
                jj_scanpos = xsp;
                break;
            }
        }
        return jj_scan_token(RSB);
    }

    private boolean jj_3_77() {
        return jj_3R_112();
    }

    private boolean jj_3R_285() {
        return jj_3R_95();
    }

    private boolean jj_3_75() {
        return jj_3R_95();
    }

    private boolean jj_3_74() {
        return jj_3R_67();
    }

    private boolean jj_3R_113() {
        return jj_scan_token(VARIABLE);
    }

    private boolean jj_3R_56() {
        return jj_3R_115();
    }

    private boolean jj_3R_111() {
        return jj_3R_102();
    }

    private boolean jj_3R_110() {
        return jj_3R_104();
    }

    private boolean jj_3R_295() {
        if (jj_scan_token(DOT)) return true;
        return jj_3R_67();
    }

    private boolean jj_3R_109() {
        return jj_3R_155();
    }

    private boolean jj_3R_281() {
        final Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_295()) {
            jj_scanpos = xsp;
            return jj_3R_296();
        }
        return false;
    }

    private boolean jj_3R_108() {
        return jj_3R_67();
    }

    private boolean jj_3R_58() {
        return jj_3R_117();
    }

    private boolean jj_3R_57() {
        return jj_3R_116();
    }

    private boolean jj_3_5() {
        return jj_3R_62();
    }

    private boolean jj_3_76() {
        Token xsp;
        xsp = jj_scanpos;
        lookingAhead = true;
        jj_semLA = !getToken(1).image.equals("@");
        lookingAhead = false;
        if (!jj_semLA || jj_3R_108()) {
            jj_scanpos = xsp;
            if (jj_3R_109()) {
                jj_scanpos = xsp;
                if (jj_3R_110()) {
                    jj_scanpos = xsp;
                    if (jj_3R_111()) return true;
                }
            }
        }
        xsp = jj_scanpos;
        if (jj_3_75()) jj_scanpos = xsp;
        return false;
    }

    private boolean jj_3_4() {
        return jj_3R_61();
    }

    private boolean jj_3_3() {
        return jj_3R_60();
    }

    private boolean jj_3R_244() {
        if (jj_scan_token(BANG)) return true;
        final Token xsp;
        xsp = jj_scanpos;
        if (jj_3_76()) {
            jj_scanpos = xsp;
            if (jj_3R_285()) {
                jj_scanpos = xsp;
                return jj_3_77();
            }
        }
        return false;
    }

    private boolean jj_3R_76() {
        return jj_3R_134();
    }

    private boolean jj_3R_75() {
        return jj_3R_68();
    }

    private boolean jj_3_2() {
        return jj_3R_59();
    }

    private boolean jj_3R_55() {
        return jj_3R_114();
    }

    private boolean jj_3R_54() {
        return jj_3R_113();
    }

    private boolean jj_3R_53() {
        return jj_scan_token(SEPARATOR);
    }

    private boolean jj_3R_74() {
        return jj_scan_token(NEW);
    }

    private boolean jj_3_1() {
        final Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_53()) {
            jj_scanpos = xsp;
            if (jj_3R_54()) {
                jj_scanpos = xsp;
                if (jj_3R_55()) {
                    jj_scanpos = xsp;
                    if (jj_3_2()) {
                        jj_scanpos = xsp;
                        if (jj_3R_56()) {
                            jj_scanpos = xsp;
                            if (jj_3_3()) {
                                jj_scanpos = xsp;
                                if (jj_3_4()) {
                                    jj_scanpos = xsp;
                                    if (jj_3_5()) {
                                        jj_scanpos = xsp;
                                        if (jj_3R_57()) {
                                            jj_scanpos = xsp;
                                            lookingAhead = true;
                                            jj_semLA = (getToken(1).kind == USE && getToken(2).kind != ONLY)
                                                    || (getToken(1).kind == HIDE);
                                            lookingAhead = false;
                                            return !jj_semLA || jj_3R_58();
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        return false;
    }

    private boolean jj_3R_297() {
        return jj_3R_281();
    }

    private boolean jj_3_22() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_74()) jj_scanpos = xsp;
        xsp = jj_scanpos;
        if (jj_scan_token(79)) {
            jj_scanpos = xsp;
            if (jj_scan_token(37)) {
                jj_scanpos = xsp;
                if (jj_scan_token(80)) return true;
            }
        }
        xsp = jj_scanpos;
        if (jj_3R_75()) {
            jj_scanpos = xsp;
            return jj_3R_76();
        }
        return false;
    }

    private boolean jj_3R_287() {
        if (jj_scan_token(BANG)) return true;
        Token xsp;
        if (jj_3R_297()) return true;
        while (true) {
            xsp = jj_scanpos;
            if (jj_3R_297()) {
                jj_scanpos = xsp;
                break;
            }
        }
        if (jj_scan_token(EQUALS)) return true;
        return jj_3R_63();
    }

    private boolean jj_3R_73() {
        return jj_scan_token(NEW);
    }

    private boolean jj_3R_72() {
        return jj_3R_134();
    }

    private boolean jj_3_21() {
        final Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_73()) jj_scanpos = xsp;
        if (jj_scan_token(VARIABLE)) return true;
        return jj_3R_67();
    }

    private boolean jj_3R_246() {
        if (jj_3R_67()) return true;
        if (jj_scan_token(COLON)) return true;
        return jj_3R_63();
    }

    private boolean jj_3R_69() {
        return jj_scan_token(IN);
    }

    private boolean jj_3_19() {
        if (jj_3R_68()) return true;
        final Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_69()) jj_scanpos = xsp;
        return false;
    }

    private boolean jj_3R_245() {
        if (jj_3R_67()) return true;
        if (jj_scan_token(MAPTO)) return true;
        return jj_3R_63();
    }

    private boolean jj_3R_71() {
        return jj_scan_token(CONSTANT);
    }

    private boolean jj_3R_70() {
        return jj_scan_token(NEW);
    }

    private boolean jj_3_18() {
        if (jj_scan_token(NEW)) return true;
        return jj_scan_token(CONSTANT);
    }

    private boolean jj_3_20() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3_18()) {
            jj_scanpos = xsp;
            if (jj_3R_70()) {
                jj_scanpos = xsp;
                if (jj_3R_71()) return true;
            }
        }
        xsp = jj_scanpos;
        if (jj_3_19()) {
            jj_scanpos = xsp;
            return jj_3R_72();
        }
        return false;
    }

    private boolean jj_3R_279() {
        if (jj_scan_token(ARSB)) return true;
        return jj_3R_243();
    }

    private boolean jj_3R_172() {
        final Token xsp;
        xsp = jj_scanpos;
        if (jj_3_20()) {
            jj_scanpos = xsp;
            if (jj_3_21()) {
                jj_scanpos = xsp;
                return jj_3_22();
            }
        }
        return false;
    }

    private boolean jj_3R_288() {
        if (jj_scan_token(COMMA)) return true;
        return jj_3R_287();
    }

    private boolean jj_3R_278() {
        if (jj_scan_token(EXCEPT)) return true;
        if (jj_3R_287()) return true;
        Token xsp;
        while (true) {
            xsp = jj_scanpos;
            if (jj_3R_288()) {
                jj_scanpos = xsp;
                break;
            }
        }
        return jj_scan_token(RSB);
    }

    private boolean jj_3R_277() {
        if (jj_scan_token(ARROW)) return true;
        if (jj_3R_63()) return true;
        return jj_scan_token(RSB);
    }

    private boolean jj_3R_158() {
        final Token xsp;
        xsp = jj_scanpos;
        if (jj_scan_token(34)) {
            jj_scanpos = xsp;
            if (jj_scan_token(3)) {
                jj_scanpos = xsp;
                return jj_scan_token(20);
            }
        }
        return false;
    }

    private boolean jj_3R_286() {
        if (jj_scan_token(COMMA)) return true;
        return jj_3R_63();
    }

    private boolean jj_3_50() {
        if (jj_scan_token(IDENTIFIER)) return true;
        return jj_scan_token(COLON);
    }

    private boolean jj_3R_276() {
        Token xsp;
        while (true) {
            xsp = jj_scanpos;
            if (jj_3R_286()) {
                jj_scanpos = xsp;
                break;
            }
        }
        return jj_scan_token(RSB);
    }

    private boolean jj_3_51() {
        if (jj_3R_63()) return true;
        final Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_276()) {
            jj_scanpos = xsp;
            if (jj_3R_277()) {
                jj_scanpos = xsp;
                if (jj_3R_278()) {
                    jj_scanpos = xsp;
                    return jj_3R_279();
                }
            }
        }
        return false;
    }

    private boolean jj_3R_275() {
        if (jj_scan_token(COMMA)) return true;
        return jj_3R_246();
    }

    private boolean jj_3_17() {
        return jj_3R_63();
    }

    private boolean jj_3R_240() {
        if (jj_3R_246()) return true;
        Token xsp;
        while (true) {
            xsp = jj_scanpos;
            if (jj_3R_275()) {
                jj_scanpos = xsp;
                break;
            }
        }
        return jj_scan_token(RSB);
    }

    private boolean jj_3R_274() {
        if (jj_scan_token(COMMA)) return true;
        return jj_3R_245();
    }

    private boolean jj_3_49() {
        if (jj_scan_token(IDENTIFIER)) return true;
        return jj_scan_token(MAPTO);
    }

    private boolean jj_3R_116() {
        return jj_3R_158();
    }

    private boolean jj_3R_239() {
        if (jj_3R_245()) return true;
        Token xsp;
        while (true) {
            xsp = jj_scanpos;
            if (jj_3R_274()) {
                jj_scanpos = xsp;
                break;
            }
        }
        return jj_scan_token(RSB);
    }

    private boolean jj_3R_273() {
        if (jj_scan_token(COMMA)) return true;
        return jj_3R_245();
    }

    private boolean jj_3R_138() {
        return jj_scan_token(COMMA);
    }

    private boolean jj_3_16() {
        return jj_3R_63();
    }

    private boolean jj_3R_137() {
        return jj_3R_172();
    }

    private boolean jj_3R_238() {
        if (jj_3R_245()) return true;
        Token xsp;
        while (true) {
            xsp = jj_scanpos;
            if (jj_3R_273()) {
                jj_scanpos = xsp;
                break;
            }
        }
        return jj_scan_token(RSB);
    }

    private boolean jj_3R_272() {
        if (jj_scan_token(COMMA)) return true;
        return jj_3R_230();
    }

    private boolean jj_3R_136() {
        return jj_3R_78();
    }

    private boolean jj_3R_237() {
        if (jj_3R_230()) return true;
        Token xsp;
        while (true) {
            xsp = jj_scanpos;
            if (jj_3R_272()) {
                jj_scanpos = xsp;
                break;
            }
        }
        if (jj_scan_token(MAPTO)) return true;
        if (jj_3R_63()) return true;
        return jj_scan_token(RSB);
    }

    private boolean jj_3_70() {
        return jj_scan_token(op_76);
    }

    private boolean jj_3R_232() {
        return jj_3R_244();
    }

    private boolean jj_3R_154() {
        if (jj_scan_token(LSB)) return true;
        final Token xsp;
        xsp = jj_scanpos;
        lookingAhead = true;
        jj_semLA = matchFcnConst();
        lookingAhead = false;
        if (!jj_semLA || jj_3R_237()) {
            jj_scanpos = xsp;
            if (jj_3R_238()) {
                jj_scanpos = xsp;
                lookingAhead = true;
                jj_semLA = (getToken(2).kind == MAPTO) && isFieldNameToken(getToken(1));
                lookingAhead = false;
                if (!jj_semLA || jj_3R_239()) {
                    jj_scanpos = xsp;
                    if (jj_3R_240()) {
                        jj_scanpos = xsp;
                        return jj_3_51();
                    }
                }
            }
        }
        return false;
    }

    private boolean jj_3_71() {
        return jj_3R_95();
    }

    private boolean jj_3R_180() {
        return jj_3R_155();
    }

    private boolean jj_3R_179() {
        return jj_3R_102();
    }

    private boolean jj_3R_178() {
        return jj_3R_104();
    }

    private boolean jj_3R_314() {
        if (jj_scan_token(COMMA)) return true;
        return jj_3R_63();
    }

    private boolean jj_3R_313() {
        if (jj_scan_token(COMMA)) return true;
        return jj_3R_230();
    }

    private boolean jj_3R_306() {
        Token xsp;
        if (jj_3R_314()) return true;
        while (true) {
            xsp = jj_scanpos;
            if (jj_3R_314()) {
                jj_scanpos = xsp;
                break;
            }
        }
        return false;
    }

    private boolean jj_3R_64() {
        final Token xsp;
        xsp = jj_scanpos;
        if (jj_scan_token(114)) {
            jj_scanpos = xsp;
            if (jj_scan_token(115)) {
                jj_scanpos = xsp;
                if (jj_scan_token(116)) {
                    jj_scanpos = xsp;
                    return jj_scan_token(117);
                }
            }
        }
        return false;
    }

    private boolean jj_3R_135() {
        if (jj_3R_67()) return true;
        if (jj_scan_token(COLONCOLON)) return true;
        return jj_3R_78();
    }

    private boolean jj_3R_78() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_135()) jj_scanpos = xsp;
        xsp = jj_scanpos;
        if (jj_scan_token(38)) {
            jj_scanpos = xsp;
            if (jj_scan_token(39)) return true;
        }
        xsp = jj_scanpos;
        lookingAhead = true;
        jj_semLA = (getToken(1).kind == ASSUME || getToken(1).kind == BOXASSUME)
                || ((getToken(2).kind == COLONCOLON) &&
                (getToken(3).kind == ASSUME || getToken(3).kind == BOXASSUME));
        lookingAhead = false;
        if (!jj_semLA || jj_3R_136()) {
            jj_scanpos = xsp;
            if (jj_3R_137()) {
                jj_scanpos = xsp;
                if (jj_3_16()) return true;
            }
        }
        while (true) {
            xsp = jj_scanpos;
            if (jj_3R_138()) {
                jj_scanpos = xsp;
                break;
            }
        }
        if (jj_scan_token(75)) {
            jj_scanpos = xsp;
            return jj_scan_token(76);
        }
        return false;
    }

    private boolean jj_3_73() {
        return jj_scan_token(NUMBER_LITERAL);
    }

    private boolean jj_3R_177() {
        final Token xsp;
        xsp = jj_scanpos;
        if (jj_scan_token(232)) {
            jj_scanpos = xsp;
            return jj_scan_token(233);
        }
        return false;
    }

    private boolean jj_3_72() {
        return jj_3R_107();
    }

    private boolean jj_3R_176() {
        return jj_3R_67();
    }

    private boolean jj_3R_153() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_176()) {
            jj_scanpos = xsp;
            if (jj_3R_177()) {
                jj_scanpos = xsp;
                if (jj_3R_178()) {
                    jj_scanpos = xsp;
                    if (jj_3R_179()) {
                        jj_scanpos = xsp;
                        if (jj_3R_180()) return true;
                    }
                }
            }
        }
        xsp = jj_scanpos;
        if (jj_3_71()) jj_scanpos = xsp;
        while (true) {
            xsp = jj_scanpos;
            if (jj_3R_232()) {
                jj_scanpos = xsp;
                break;
            }
        }
        return false;
    }

    private boolean jj_3R_91() {
        return jj_3R_146();
    }

    private boolean jj_3R_152() {
        return jj_3R_175();
    }

    private boolean jj_3R_142() {
        return jj_3R_78();
    }

    private boolean jj_3R_305() {
        if (jj_scan_token(COLON)) return true;
        if (jj_3R_230()) return true;
        Token xsp;
        while (true) {
            xsp = jj_scanpos;
            if (jj_3R_313()) {
                jj_scanpos = xsp;
                break;
            }
        }
        return false;
    }

    private boolean jj_3R_294() {
        final Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_305()) {
            jj_scanpos = xsp;
            return jj_3R_306();
        }
        return false;
    }

    private boolean jj_3_46() {
        final Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_91()) {
            jj_scanpos = xsp;
            if (jj_scan_token(231)) return true;
        }
        return jj_scan_token(COLON);
    }

    private boolean jj_3R_151() {
        return jj_3R_107();
    }

    private boolean jj_3_38() {
        return jj_3R_63();
    }

    private boolean jj_3R_293() {
        if (jj_scan_token(COMMA)) return true;
        return jj_3R_230();
    }

    private boolean jj_3_47() {
        if (jj_3R_63()) return true;
        final Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_294()) jj_scanpos = xsp;
        return false;
    }

    private boolean jj_3R_98() {
        final Token xsp;
        xsp = jj_scanpos;
        lookingAhead = true;
        jj_semLA = BStack.aboveReference(getToken(1).beginColumn);
        lookingAhead = false;
        if (!jj_semLA || jj_3R_151()) {
            jj_scanpos = xsp;
            lookingAhead = true;
            jj_semLA = BStack.aboveReference(getToken(1).beginColumn);
            lookingAhead = false;
            if (!jj_semLA || jj_3R_152()) {
                jj_scanpos = xsp;
                return jj_3R_153();
            }
        }
        return false;
    }

    private boolean jj_3R_90() {
        return jj_3R_146();
    }

    private boolean jj_3R_141() {
        return jj_scan_token(SUFFICES);
    }

    private boolean jj_3_45() {
        final Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_90()) {
            jj_scanpos = xsp;
            if (jj_scan_token(231)) return true;
        }
        return jj_scan_token(COMMA);
    }

    private boolean jj_3R_82() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_141()) jj_scanpos = xsp;
        xsp = jj_scanpos;
        if (jj_3_38()) {
            jj_scanpos = xsp;
            lookingAhead = true;
            jj_semLA = getToken(1).kind == ASSUME || getToken(1).kind == BOXASSUME;
            lookingAhead = false;
            return !jj_semLA || jj_3R_142();
        }
        return false;
    }

    private boolean jj_3R_94() {
        if (jj_3R_63()) return true;
        if (jj_scan_token(COLON)) return true;
        if (jj_3R_230()) return true;
        Token xsp;
        while (true) {
            xsp = jj_scanpos;
            if (jj_3R_293()) {
                jj_scanpos = xsp;
                break;
            }
        }
        return false;
    }

    private boolean jj_3R_292() {
        if (jj_scan_token(COMMA)) return true;
        return jj_3R_63();
    }

    private boolean jj_3R_93() {
        if (jj_3R_63()) return true;
        Token xsp;
        while (true) {
            xsp = jj_scanpos;
            if (jj_3R_292()) {
                jj_scanpos = xsp;
                break;
            }
        }
        return false;
    }

    private boolean jj_3R_312() {
        if (jj_scan_token(COMMA)) return true;
        return jj_3R_63();
    }

    private boolean jj_3R_304() {
        Token xsp;
        if (jj_3R_312()) return true;
        while (true) {
            xsp = jj_scanpos;
            if (jj_3R_312()) {
                jj_scanpos = xsp;
                break;
            }
        }
        return false;
    }

    private boolean jj_3_68() {
        return jj_scan_token(COLONCOLON);
    }

    private boolean jj_3_15() {
        final Token xsp;
        xsp = jj_scanpos;
        if (jj_scan_token(95)) jj_scanpos = xsp;
        if (jj_3R_67()) return true;
        return jj_scan_token(DEF);
    }

    private boolean jj_3R_303() {
        if (jj_scan_token(COLON)) return true;
        return jj_3R_63();
    }

    private boolean jj_3R_291() {
        final Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_303()) {
            jj_scanpos = xsp;
            return jj_3R_304();
        }
        return false;
    }

    private boolean jj_3R_61() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_scan_token(40)) {
            jj_scanpos = xsp;
            if (jj_scan_token(38)) return true;
        }
        xsp = jj_scanpos;
        if (jj_3_15()) jj_scanpos = xsp;
        return jj_3R_63();
    }

    private boolean jj_3R_84() {
        if (jj_scan_token(COMMA)) return true;
        return jj_scan_token(IDENTIFIER);
    }

    private boolean jj_3_66() {
        return jj_3R_97();
    }

    private boolean jj_3R_106() {
        if (jj_scan_token(COLONCOLON)) return true;
        return jj_3R_63();
    }

    private boolean jj_3R_148() {
        return jj_3R_67();
    }

    private boolean jj_3R_261() {
        return jj_3R_169();
    }

    private boolean jj_3R_260() {
        return jj_3R_168();
    }

    private boolean jj_3_37() {
        if (jj_scan_token(IDENTIFIER)) return true;
        Token xsp;
        while (true) {
            xsp = jj_scanpos;
            if (jj_3R_84()) {
                jj_scanpos = xsp;
                break;
            }
        }
        return jj_scan_token(COLON);
    }

    private boolean jj_3R_67() {
        return jj_scan_token(IDENTIFIER);
    }

    private boolean jj_3R_103() {
        return jj_3R_150();
    }

    private boolean jj_3_65() {
        final Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_103()) {
            jj_scanpos = xsp;
            return jj_scan_token(194);
        }
        return false;
    }

    private boolean jj_3R_267() {
        return jj_3R_104();
    }

    private boolean jj_3R_266() {
        return jj_3R_182();
    }

    private boolean jj_3R_102() {
        return jj_3R_64();
    }

    private boolean jj_3_67() {
        return jj_3R_104();
    }

    private boolean jj_3R_259() {
        final Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_266()) {
            jj_scanpos = xsp;
            return jj_3R_267();
        }
        return false;
    }

    private boolean jj_3R_147() {
        return jj_3R_146();
    }

    private boolean jj_3R_92() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_147()) {
            jj_scanpos = xsp;
            if (jj_3R_148()) return true;
        }
        if (jj_scan_token(IN)) return true;
        if (jj_3R_63()) return true;
        xsp = jj_scanpos;
        if (jj_3R_291()) jj_scanpos = xsp;
        return false;
    }

    private boolean jj_3_48() {
        final Token xsp;
        xsp = jj_scanpos;
        lookingAhead = true;
        jj_semLA = matchFcnConst();
        lookingAhead = false;
        if (!jj_semLA || jj_3R_92()) {
            jj_scanpos = xsp;
            if (jj_3R_93()) {
                jj_scanpos = xsp;
                if (jj_3R_94()) {
                    jj_scanpos = xsp;
                    return jj_3_47();
                }
            }
        }
        return false;
    }

    private boolean jj_3R_104() {
        return jj_3R_65();
    }

    private boolean jj_3R_218() {
        if (jj_scan_token(LBC)) return true;
        final Token xsp;
        xsp = jj_scanpos;
        if (jj_3_48()) jj_scanpos = xsp;
        return jj_scan_token(RBC);
    }

    private boolean jj_3R_105() {
        if (jj_3R_104()) return true;
        Token xsp;
        while (true) {
            xsp = jj_scanpos;
            if (jj_3R_259()) {
                jj_scanpos = xsp;
                break;
            }
        }
        lookingAhead = true;
        jj_semLA = BStack.aboveReference(getToken(1).beginColumn);
        lookingAhead = false;
        if (!jj_semLA || jj_3R_260()) {
            jj_scanpos = xsp;
            lookingAhead = true;
            jj_semLA = BStack.aboveReference(getToken(1).beginColumn);
            lookingAhead = false;
            return !jj_semLA || jj_3R_261();
        }
        return false;
    }

    private boolean jj_3_69() {
        final Token xsp;
        xsp = jj_scanpos;
        lookingAhead = true;
        jj_semLA = BStack.aboveReference(getToken(1).beginColumn);
        lookingAhead = false;
        if (!jj_semLA || jj_3R_105()) {
            jj_scanpos = xsp;
            lookingAhead = true;
            jj_semLA = BStack.aboveReference(getToken(1).beginColumn);
            lookingAhead = false;
            return !jj_semLA || jj_3R_106();
        }
        return false;
    }

    private boolean jj_3R_155() {
        return jj_3R_145();
    }

    public void ReInit(final java.io.InputStream stream, final String encoding) {
        try {
            jj_input_stream.ReInit(stream, encoding, 1, 1);
        } catch (final java.io.UnsupportedEncodingException e) {
            throw new RuntimeException(e);
        }
        token_source.ReInit(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 140; i++) jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
    }

    public void ReInit(final java.io.Reader stream) {
        jj_input_stream.ReInit(stream, 1, 1);
        token_source.ReInit(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 140; i++) jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
    }

    public void ReInit(final TLAplusParserTokenManager tm) {
        token_source = tm;
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 140; i++) jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
    }

    private Token jj_consume_token(final int kind) throws ParseException {
        final Token oldToken;
        if ((oldToken = token).next != null) token = token.next;
        else token = token.next = token_source.getNextToken();
        jj_ntk = -1;
        if (token.kind == kind) {
            jj_gen++;
            if (++jj_gc > 100) {
                jj_gc = 0;
                for (final JJCalls jj_2_rtn : jj_2_rtns) {
                    JJCalls c = jj_2_rtn;
                    while (c != null) {
                        if (c.gen < jj_gen) c.first = null;
                        c = c.next;
                    }
                }
            }
            return token;
        }
        token = oldToken;
        jj_kind = kind;
        throw generateParseException();
    }

    private boolean jj_scan_token(final int kind) {
        if (jj_scanpos == jj_lastpos) {
            jj_la--;
            if (jj_scanpos.next == null) {
                jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
            } else {
                jj_lastpos = jj_scanpos = jj_scanpos.next;
            }
        } else {
            jj_scanpos = jj_scanpos.next;
        }
        if (jj_rescan) {
            int i = 0;
            Token tok = token;
            while (tok != null && tok != jj_scanpos) {
                i++;
                tok = tok.next;
            }
            if (tok != null) jj_add_error_token(kind, i);
        }
        if (jj_scanpos.kind != kind) return true;
        if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
        return false;
    }

    public final Token getNextToken() {
        if (token.next != null) token = token.next;
        else token = token.next = token_source.getNextToken();
        jj_ntk = -1;
        jj_gen++;
        return token;
    }

    public final Token getToken(final int index) {
        Token t = lookingAhead ? jj_scanpos : token;
        for (int i = 0; i < index; i++) {
            if (t.next != null) t = t.next;
            else t = t.next = token_source.getNextToken();
        }
        return t;
    }

    private int jj_ntk() {
        if ((jj_nt = token.next) == null)
            return (jj_ntk = (token.next = token_source.getNextToken()).kind);
        else
            return (jj_ntk = jj_nt.kind);
    }

    private void jj_add_error_token(final int kind, final int pos) {
        if (pos >= 100) return;
        if (pos == jj_endpos + 1) {
            jj_lasttokens[jj_endpos++] = kind;
        } else if (jj_endpos != 0) {
            jj_expentry = new int[jj_endpos];
            System.arraycopy(jj_lasttokens, 0, jj_expentry, 0, jj_endpos);
            boolean exists = false;
            for (final int[] oldentry : jj_expentries) {
                if (oldentry.length == jj_expentry.length) {
                    exists = true;
                    for (int i = 0; i < jj_expentry.length; i++) {
                        if (oldentry[i] != jj_expentry[i]) {
                            exists = false;
                            break;
                        }
                    }
                    if (exists) break;
                }
            }
            if (!exists) jj_expentries.add(jj_expentry);
            if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
        }
    }

    public ParseException generateParseException() {
        jj_expentries.clear();
        final boolean[] la1tokens = new boolean[237];
        for (int i = 0; i < 237; i++) {
            la1tokens[i] = false;
        }
        if (jj_kind >= 0) {
            la1tokens[jj_kind] = true;
            jj_kind = -1;
        }
        for (int i = 0; i < 140; i++) {
            if (jj_la1[i] == jj_gen) {
                for (int j = 0; j < 32; j++) {
                    if ((jj_la1_0[i] & (1 << j)) != 0) {
                        la1tokens[j] = true;
                    }
                    if ((jj_la1_1[i] & (1 << j)) != 0) {
                        la1tokens[32 + j] = true;
                    }
                    if ((jj_la1_2[i] & (1 << j)) != 0) {
                        la1tokens[64 + j] = true;
                    }
                    if ((jj_la1_3[i] & (1 << j)) != 0) {
                        la1tokens[96 + j] = true;
                    }
                    if ((jj_la1_4[i] & (1 << j)) != 0) {
                        la1tokens[128 + j] = true;
                    }
                    if ((jj_la1_5[i] & (1 << j)) != 0) {
                        la1tokens[160 + j] = true;
                    }
                    if ((jj_la1_6[i] & (1 << j)) != 0) {
                        la1tokens[192 + j] = true;
                    }
                    if ((jj_la1_7[i] & (1 << j)) != 0) {
                        la1tokens[224 + j] = true;
                    }
                }
            }
        }
        for (int i = 0; i < 237; i++) {
            if (la1tokens[i]) {
                jj_expentry = new int[1];
                jj_expentry[0] = i;
                jj_expentries.add(jj_expentry);
            }
        }
        jj_endpos = 0;
        jj_rescan_token();
        jj_add_error_token(0, 0);
        final int[][] exptokseq = new int[jj_expentries.size()][];
        for (int i = 0; i < jj_expentries.size(); i++) {
            exptokseq[i] = jj_expentries.get(i);
        }
        return new ParseException(token, exptokseq, tokenImage);
    }

    public final void enable_tracing() {
    }

    public final void disable_tracing() {
    }

    private void jj_rescan_token() {
        jj_rescan = true;
        for (int i = 0; i < 77; i++) {
            try {
                JJCalls p = jj_2_rtns[i];
                do {
                    if (p.gen > jj_gen) {
                        jj_la = p.arg;
                        jj_lastpos = jj_scanpos = p.first;
                        switch (i) {
                            case 0 -> jj_3_1();
                            case 1 -> jj_3_2();
                            case 2 -> jj_3_3();
                            case 3 -> jj_3_4();
                            case 4 -> jj_3_5();
                            case 5 -> jj_3_6();
                            case 6 -> jj_3_7();
                            case 7 -> jj_3_8();
                            case 8 -> jj_3_9();
                            case 9 -> jj_3_10();
                            case 10 -> jj_3_11();
                            case 11 -> jj_3_12();
                            case 12 -> jj_3_13();
                            case 13 -> jj_3_14();
                            case 14 -> jj_3_15();
                            case 15 -> jj_3_16();
                            case 16 -> jj_3_17();
                            case 17 -> jj_3_18();
                            case 18 -> jj_3_19();
                            case 19 -> jj_3_20();
                            case 20 -> jj_3_21();
                            case 21 -> jj_3_22();
                            case 22 -> jj_3_23();
                            case 23 -> jj_3_24();
                            case 24 -> jj_3_25();
                            case 25 -> jj_3_26();
                            case 26 -> jj_3_27();
                            case 27 -> jj_3_28();
                            case 28 -> jj_3_29();
                            case 29 -> jj_3_30();
                            case 30 -> jj_3_31();
                            case 31 -> jj_3_32();
                            case 32 -> jj_3_33();
                            case 33 -> jj_3_34();
                            case 34 -> jj_3_35();
                            case 35 -> jj_3_36();
                            case 36 -> jj_3_37();
                            case 37 -> jj_3_38();
                            case 38 -> jj_3_39();
                            case 39 -> jj_3_40();
                            case 40 -> jj_3_41();
                            case 41 -> jj_3_42();
                            case 42 -> jj_3_43();
                            case 43 -> jj_3_44();
                            case 44 -> jj_3_45();
                            case 45 -> jj_3_46();
                            case 46 -> jj_3_47();
                            case 47 -> jj_3_48();
                            case 48 -> jj_3_49();
                            case 49 -> jj_3_50();
                            case 50 -> jj_3_51();
                            case 51 -> jj_3_52();
                            case 52 -> jj_3_53();
                            case 53 -> jj_3_54();
                            case 54 -> jj_3_55();
                            case 55 -> jj_3_56();
                            case 56 -> jj_3_57();
                            case 57 -> jj_3_58();
                            case 58 -> jj_3_59();
                            case 59 -> jj_3_60();
                            case 60 -> jj_3_61();
                            case 61 -> jj_3_62();
                            case 62 -> jj_3_63();
                            case 63 -> jj_3_64();
                            case 64 -> jj_3_65();
                            case 65 -> jj_3_66();
                            case 66 -> jj_3_67();
                            case 67 -> jj_3_68();
                            case 68 -> jj_3_69();
                            case 69 -> jj_3_70();
                            case 70 -> jj_3_71();
                            case 71 -> jj_3_72();
                            case 72 -> jj_3_73();
                            case 73 -> jj_3_74();
                            case 74 -> jj_3_75();
                            case 75 -> jj_3_76();
                            case 76 -> jj_3_77();
                        }
                    }
                    p = p.next;
                } while (p != null);
            } catch (final LookaheadSuccess ls) {
            }
        }
        jj_rescan = false;
    }

    private void jj_save(final int index, final int xla) {
        JJCalls p = jj_2_rtns[index];
        while (p.gen > jj_gen) {
            if (p.next == null) {
                p = p.next = new JJCalls();
                break;
            }
            p = p.next;
        }
        p.gen = jj_gen + xla - jj_la;
        p.first = token;
        p.arg = xla;
    }

    private static final class LookaheadSuccess extends java.lang.Error {

        /**
         *
         */
        private static final long serialVersionUID = 761892822322674364L;
    }

    static final class JJCalls {
        int gen;
        Token first;
        int arg;
        JJCalls next;
    }

}
