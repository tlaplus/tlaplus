/* Generated By:55&JavaCC: Do not edit this line. TLAplusParser.java */
package tla2sany.parser;

import tla2sany.st.ParseTree;
import tla2sany.st.TreeNode;

import tla2sany.utilities.Vector;
import tla2sany.utilities.Stack;
import tla2sany.utilities.Assert;
import util.UniqueString;
import util.ToolIO;

public class TLAplusParser implements tla2sany.st.SyntaxTreeConstants, ParseTree, TLAplusParserConstants {

  public String[] dependencies() {
    /***********************************************************************
    * This method is used in modanalyzer/{SyntaxTreePrinter,ParserUnit}.   *
    ***********************************************************************/
    String[]deps = new String[ dependencyList.size() ];
    for (int lvi =0; lvi < deps.length; lvi++)
      deps[lvi] = ((UniqueString)dependencyList.elementAt(lvi)).toString();
    return deps;
  }
  public TreeNode rootNode() { return ParseTree; }
  public String moduleName() { return mn.toString(); }
//  public tla2sany.st.ParseErrors getErrors() { return PErrors; } Unused, apparently
// The front end can simply read the public PErrors.

  public SyntaxTreeNode ParseTree;
    /***********************************************************************
    * The root node.                                                       *
    ***********************************************************************/

  public Vector dependencyList = new Vector( 20 );

  private UniqueString mn = null;
     /**********************************************************************
     * The module name.                                                    *
     **********************************************************************/

  private boolean numberFlag = false;
  private boolean decimalFlag = false;

  private Operator FcnOp = Operators.getOperator( UniqueString.uniqueStringOf("[" ));
  private SyntaxTreeNode FairnessHook;

  private UniqueString At = UniqueString.uniqueStringOf("@");

  ParseErrors PErrors = new ParseErrors();

  private tla2sany.parser.OperatorStack OperatorStack = new tla2sany.parser.OperatorStack( PErrors );

  private BracketStack BStack;
    /***********************************************************************
    * This is a stack of the kinds and offsets of the tokens that start a  *
    * bulleted list within which the parser is currently grabbing tokens.  *
    ***********************************************************************/

  public boolean parse() {
    /***********************************************************************
    * This is a wrapper for actual parsing procedure CompilationUnit().    *
    * If an exception occurs, or if an error was pushed onto PErrors,      *
    * then an error message is printed and it returns false.  Otherwise,   *
    * it returns true.  Note that if we want to be able to parse an        *
    * expression, we need to implement a similar wrapper for               *
    * Expression().                                                        *
    ***********************************************************************/

    /***********************************************************************
    * The following code sets BStack to a new BracketStack object and      *
    * initializes its classes field as described in BracketStack.java.     *
    ***********************************************************************/
    BStack = new BracketStack();
    BStack.newClass();
//    BStack.registerInCurrentClass( BAND );
    BStack.registerInCurrentClass( AND );
    BStack.newClass();
//    BStack.registerInCurrentClass( BOR );
    BStack.registerInCurrentClass( OR );
    BStack.newClass();
    BStack.registerInCurrentClass( PROOF );
    BStack.newClass();
    BStack.registerInCurrentClass( LBR );
    BStack.newClass();
    BStack.registerInCurrentClass( ASSUME );

    try { ParseTree = CompilationUnit(); }
    catch( ParseException e ) {
         PErrors.push( new ParseError( msgStackToString(e) ) ); }
    catch( TokenMgrError tme ) {
      // lexical error.
      String msg = tme.getMessage();
      int bl = jj_input_stream.getBeginLine() + 1;
      int el = jj_input_stream.getEndLine() + 1;
      // lexical error.
      if ( (msg.indexOf("EOF") != -1) && (bl != el) )  {
        PErrors.push(new ParseError(
                  "Lexical {error: EOF reached, " +
                  "possibly open comment starting around line " +
                  (bl-1) )) ;
      } else  PErrors.push( new ParseError( msg  )) ;
//      PErrors.push( new ParseError( tme.getMessage() )) ;
    } /*** end catch(TokenMgrError) ****/
    if ( PErrors.empty() ) Assert.assertion( heirsIndex == 0 );
      /*********************************************************************
      * This is a sanity check.  The assertion should never be false.      *
      *********************************************************************/
    else {
      /*********************************************************************
      * An error has been pushed onto PErrors.  It might have been done    *
      * when an exception was caught, or by detecting an error during the  *
      * parsing without throwing an exception.  This happens in            *
      * ExceptComponent() if it finds "!.@", and in FairnessExpr().        *
      *********************************************************************/
      tla2sany.st.ParseError  list[] = PErrors.errors();
      for (int i = 0; i < list.length; i++ ) {
        ToolIO.out.println( list[i].reportedError() );
//        ToolIO.out.println( "+ " + list[i].defaultError() );
      }
    }
//   ParseTree.setNumberFlags( numberFlag, decimalFlag );
    return PErrors.empty();
  }

/*
  this is required to store temporarily information required by
  the semantic lookahead, as it doesn't have access to the variables
  of the production
*/
  private SyntaxTreeNode local;

  void registerTN( SyntaxTreeNode some) { local = some ; }

  boolean testTN() {
    /***********************************************************************
    * THIS METHOD IS APPARENTLY NOT USED.                                  *
    ***********************************************************************/
    return local.isKind(N_IdPrefix)
        && BStack.aboveReference( local.first().first().location[0] ) ;
  }

  private SyntaxTreeNode anchor = null;
    /***********************************************************************
    * This is set to a non-null value only in Expression().  If a          *
    * ClosedExpressionOrOp node is found when parsing an expression,       *
    * anchor is set to that node.  It is set to null in the following      *
    * places:                                                              *
    *                                                                      *
    *  - When beginning to parse a Substitution()                          *
    *                                                                      *
    *  - When OpSuite() or Substitution() finds that anchor equals an      *
    *    Op Symbol, as described below.                                    *
    *                                                                      *
    * The Substitution() and OpSuite() procedures look for an              *
    * Expression or Op Symbol by calling Expression() and, if that throws  *
    * an exception, catching the expression and checking if anchor is the  *
    * desired Op Symbol.                                                   *
    ***********************************************************************/

// Lookahead mechanisms for definitions
  /*************************************************************************
  * The following code is lifted directly from the getToken method         *
  * created by JavaCC in the file TLAplusParser.java.                      *
  *                                                                        *
  * J-Ch doesn't remember why he defined this method instead of just       *
  * using the GetToken method.  He thinks that it was to make sure         *
  * it would always return a token rather than null.                       *
  *************************************************************************/
  final private Token getNextPreviewToken(Token t) {
    if (t.next == null) t.next = token_source.getNextToken();
       /********************************************************************
       * token_source is declared in configuration/Configuration.java to   *
       * be a ConfigurationTokenManager.                                   *
       ********************************************************************/
    return t.next;
  }

// borrowed from code generated by JavaCC.
  final private Token initPreviewToken() {
    return lookingAhead ? jj_scanpos : token;
      /*********************************************************************
      * `lookingAhead', `token', and `jj_scanpos' are declared in          *
      * TLAplusParser (created by javacc from this file).  The javacc      *
      * documentation says that token is the value returned by             *
      * getToken(0).  God only knows what lookingAhead and jj_scanpos      *
      * are.                                                               *
      *********************************************************************/
  }

  private final void belchDEF() {
    /***********************************************************************
    * The purpose of this method seems to be to introduce a dummy          *
    * <DEFBREAK> token into the token stream, which is used in parsing     *
    * the OperatorOrFunctionDefinition non-terminal.                       *
    ***********************************************************************/
    Token previousT = initPreviewToken();
    Token currentT = getNextPreviewToken( previousT );
    previousT.next = null;  // <-- to break recursion 
    Token nextT = getNextPreviewToken( currentT );
    currentT.next = previousT;
    while (   nextT.kind != EOF
           && nextT.kind != THEOREM
//           && nextT.kind != ASSUME
           /****************************************************************
           * This test for ASSUME removed on 26 June 2007.                 *
           * It made belchDEF get hung up on nested ASSUME/PROVEs.         *
           * However, this permitted extra DEFBREAK tokens to be inserted. *
           * Those extra tokens were eliminated by the change on the same  *
           * date described below.                                         *
           ****************************************************************/
           && nextT.kind != ASSUMPTION
           && nextT.kind != END_MODULE) {
      /*********************************************************************
      * As long as we have not yet reached the end of the stream or a      *
      * THEOREM, ASSUME, or END_MODULE token, move forward through the     *
      * token stream looking for a "==" token.  Maintain a chain of the    *
      * tokens passed over, with t.next equal to the previous token, and   *
      * t.next = null for the first token.                                 *
      *                                                                    *
      * At this point, the last three tokens obtained are previoustT,      *
      * currentT, and nextT, where currentT.next = previousT and           *
      * nextT.next points to the first unexamined token.                   *
      *********************************************************************/
      if ( currentT.kind == DEF ) {
        /*******************************************************************
        * currentT is a "==" token.                                        *
        *******************************************************************/
        Token t = previousT;
        if        ( t.kind == RBR || t.kind == RSB ) {
          /*****************************************************************
          * t = previousT is a ")" or "]" token.                           *
          *****************************************************************/
          // the following code assumes that parentheses are evenly balanced.
          // something could be added to reinforce the test.
          // they do not have to be on the same line either, btw.
          int depth = 1;
          while (t.next != null) {
            t = t.next;
            if ( (t.kind == LBR || t.kind == LSB) && depth == 1 ) break;
            if ( (t.kind == LBR || t.kind == LSB) && depth >  1 ) depth--;
            if ( (t.kind == RBR || t.kind == RSB) ) depth++;
           }
          if (t.next == null ) break;
          else if (t.next.kind == IDENTIFIER)
            t = t.next;
          // we are positioned at first symbol before "[" or "(" : must be an identifier
        } else
          /*****************************************************************
          * t = previousT is not a ")" or "]" token.                       *
          *****************************************************************/
           if ( t.kind == IDENTIFIER ) {
             /**************************************************************
             * t is an IDENTIFIER token.                                   *
             *                                                             *
             * If t.next [the previous token in the input stream] is a     *
             * non-prefix operator and is not preceded in the stream by    *
             * "<-" [so it belongs to a preceding substitution], then set  *
             * t to t.next if it is a prefix operator and to t.next.next   *
             * if it is an infix operator.                                 *
             *                                                             *
             * Note: If belchDef is called with the input stream at        *
             * something like "++ a ==", then evaluating t.next.next       *
             * dereferences null.  This should happen only if the user     *
             * has left off the first parameter of the definitiion and     *
             * the resulting exception seems to be caught, but it          *
             * produces a misleading error message.  This type of rare     *
             * error is hardly worth worrying about, but it would be easy  *
             * enough to add a test and might be worth doing if it's easy  *
             * to produce the right error message.                         *
             **************************************************************/
             Token identifier = t;
             if ( isOp( t.next )  && ! isPostfixOp( t.next ) ) {
               t = t.next;
               if ( t.next.kind == SUBSTITUTE )
                  t = identifier; // skip back
                else if ( isInfixOp( t ) ) t = t.next;
                // else assume prefix
              }
           } else {
             /**************************************************************
             * t is not an IDENTIFIER token.                               *
             *                                                             *
             * If it is an operator token, set t to t.next.  (It will be   *
             * a postfix operator unless the user made an error.)          *
             **************************************************************/
               if (  isOp(t) ) { // assume postfix op, the parser will catch the error
                  t = t.next;
                   }
              }
        /*******************************************************************
        * Insert a DEFBREAK token into the input stream right before       *
        * token t, and exit the while loop.                                *
        *                                                                  *
        * Changed by LL on 26 June 2007 so it doesn't add the DEFBREAK     *
        * token if there's already one there.  (This could happen because  *
        * of the change to pass over ASSUMEs described above.)             *
        *******************************************************************/
        if (   (t.next == null)
            || (t.next.kind != DEFBREAK)) {
          Token i = new Token();
          i.kind = DEFBREAK;
          i.image = "Beginning of definition";
          i.beginLine = t.beginLine;
          i.beginColumn = t.beginColumn;
          i.endLine = t.endLine;
          i.endColumn = t.endColumn;
          i.next = t.next;
          t.next = i;
         } ;
        break;  /* EXIT while */
      } else {
        /*******************************************************************
        * currentT is not a "==" token.                                    *
        *******************************************************************/
        previousT = currentT;
        currentT = nextT;
        nextT = getNextPreviewToken( currentT );
        currentT.next = previousT;
        }
    }  /* END while */
    // reverse pointers.
    /***********************************************************************
    * Go back through the examined tokens, making t.next point to the      *
    * next one for each token t.                                           *
    ***********************************************************************/
    while (previousT != null ) {
      currentT.next = nextT;
      nextT = currentT;
      currentT = previousT;
      previousT = currentT.next;
    }
    // relink firstT
    currentT.next = nextT;
  }

//
  void skipOver( int l ) {
    while ( true ) {
      Token t = getToken(1);
      int k = t.kind;
      if ( (k == EOF) || (t.beginColumn < l ) ) return;
      t = getNextToken();
    }
  }

/***************************************************************************
* Note: the non-terminal ClosedStart was commented out, apparently to be   *
* replaced by this boolean-valued method.                                  *
***************************************************************************/
boolean
ClosedStart( Token t ) {
  return   t.kind == IDENTIFIER
        || (t.kind >= op_57 && t.kind <= op_119)
           /****************************************************************
           * These are all prefix, infix, and postfix operators.           *
           ****************************************************************/
        || t.kind == NUMBER_LITERAL
        || t.kind == LBR
        || t.kind == LSB
        || t.kind == LAB
        || t.kind == LBC
        || t.kind == LWB
        || t.kind == STRING_LITERAL
        || t.kind == WF
        || t.kind == SF;
}

boolean
isOp( Token t ) {
  return t.kind >= op_57 && t.kind <= op_119;
}

boolean isInfixOp( Token t ) {
  return t.kind >= op_1 && t.kind <= op_119;
}

boolean isPostfixOp( Token t ) {
  return t.kind >= op_57 && t.kind <= op_70;
}

boolean isPrefixOp( Token t ) {
  return t.kind >= op_26 && t.kind <= op_116;
}

// global variable follows !!! Make sure it is set everywhere as required
Operator lastOp;
  /*************************************************************************
  * This seems to equal the last Prefix, Infix, PostFix, or NonExpPrefix   *
  * op that was parsed.                                                    *
  *************************************************************************/

  boolean isGenOp(SyntaxTreeNode tn) { /* has to be of the form prefix, opsym */
    int kind = tn.getKind();
    if ( kind == N_GenPrefixOp
      || kind == N_GenNonExpPrefixOp
      || kind == N_GenInfixOp
      || kind == N_GenPostfixOp
      || kind == N_FcnAppl )
       return true;
    else
      return false;
  }

//  boolean IsNotExpression () {
//    /***********************************************************************
//    * This method is called only in NumberedAssumeProve.                   *
//    ***********************************************************************/
//    Token t = initPreviewToken();
//          t = getNextPreviewToken(t);
//      /*********************************************************************
//      * Previous statement added on 1 Mar 2007 by J-Ch and LL to fix bug.  *
//      *********************************************************************/
//    int k = t.kind;
//    if ( k == US || k == LOCAL || k == VARIABLE || k == PARAMETER || k == INSTANCE || k == CONSTANT || k == STATE || k == ACTION || k == TEMPORAL ) return true;
//    else {
//      t = getNextPreviewToken(t); k = t.kind;
//      if ( k == US || k == DEF || k  == LSB )
//        return true;
//      else if (k == LBR) {
//        int depth = 1;
//        Token nt = getNextPreviewToken(t);
//        while (true) {
//          t = nt; nt = getNextPreviewToken(t); k = t.kind;
//          if ( k == RBR ) {
//             if ( depth == 1 )
//               if ( nt.kind == DEF ) return true;
//               else return false;
//             else
//                depth--;
//          } else
//          if ( k == LBR ) { depth++;
//          } else
//          if ( k == EOF ) return false;
//        }
//      }
//    }
//    return false;
//  }
//
  boolean isFieldNameToken( Token t ) {
    /***********************************************************************
    * Modified by LL on 10 Oct 2007 because of new keywords added and      *
    * obsolete ones removed.                                               *
    ***********************************************************************/
    if ( (t.kind >= ACTION && t.kind <= EXCEPT)
       ||(t.kind == EXTENDS)
       ||(t.kind >= IF && t.kind <= SF)
       ||(t.kind == STATE)
       ||(t.kind >= THEN && t.kind <= WITH)
       ||(t.kind == US)
       ||(t.kind >= op_112 && t.kind <= op_116)
       )
       return true;
     else
       return false;
  }

  boolean isLabel(SyntaxTreeNode node) {
    /***********************************************************************
    * Checks that node is a label, meaning that it is either an            *
    * identifier token or else an OpApplication node each of whose         *
    * arguments is an OpArgs node whose child is a GeneralId node with an  *
    * empty IdPrefix.                                                      *
    ***********************************************************************/
    if (node == null) {return false;} ;
    if (node.isKind(N_GeneralId)) {
        return (node.heirs()[0].heirs().length == 0) ;
       } ;
    if (! node.isKind(N_OpApplication)) {return false;} ;
    SyntaxTreeNode opArgs = (SyntaxTreeNode) node.heirs()[1] ;
if (opArgs.kind != N_OpArgs) { ToolIO.out.println("Bug: not N_OpArgs node"); };
        /*******************************************************************
        * Sanity check--can be removed after debugging.                    *
        *******************************************************************/
    for (int i = 1; i < opArgs.heirs().length; i = i+2) {
      /*********************************************************************
      * THe OpArg node for Op(arg_1, ... , arg_N) has the 2N+1 heirs       *
      *                                                                    *
      *     "("   arg_1   ","  ...  ","   arg_N   ")"                      *
      *********************************************************************/
      SyntaxTreeNode genId = (SyntaxTreeNode) opArgs.heirs()[i] ;
      if (genId.kind != N_GeneralId) {return false;} ;
      if (genId.heirs()[0].heirs().length != 0){return false;}
     } // for
    return true;
   }

  boolean labelDoesNotChangeParse(SyntaxTreeNode labeledExpr,
                                  Operator labelOp) {
    /***********************************************************************
    * Checks if preceding the expression labeledExpr with a label has not  *
    * changed the parsing of the enclosing expression.  It has changed     *
    * the parsing iff                                                      *
    *   /\ labeledExpr is an infix or postfix expression with operator     *
    *      labelOp                                                         *
    *   /\ the top of OperatorStack is an infix or prefix operator stackOp *
    *   /\ it is not the case that stackOp \prec labelOp.                  *
    ***********************************************************************/
    if ( ! (   labeledExpr.isKind(N_InfixExpr)
            || labeledExpr.isKind(N_PostfixExpr) ) ) {return true;} ;

    OSelement topNode = OperatorStack.topOfStack();
    if (topNode == null) {return true;} ;
    Operator stackOp = topNode.getOperator() ;
    return (stackOp == null) || Operator.prec(stackOp, labelOp) ;
  }

  void checkIndentation(SyntaxTreeNode nd, SyntaxTreeNode junct)
     throws ParseException {
    /***********************************************************************
    * Goes through the descendants of node nd, stopping at an N_DisjList   *
    * or N_ConjList node.  For each node it finds, if checks whether it    *
    * is properly indented with respect to the current N_DisjItem or       *
    * N_ConjItem junct.  If not, it reports an error by throwing an        *
    * exception.                                                           *
    ***********************************************************************/
    TreeNode[] children = nd.heirs() ;
    for (int i = 0; i < children.length; i++) {
      SyntaxTreeNode child = (SyntaxTreeNode) children[i] ;
      if (! (   child.isKind(N_ConjList)
             || child.isKind(N_DisjList))) {
         if (!BStack.aboveReference(child.location[1])) {
           throw new ParseException(
              "Item at " + child.getLocation().toString() +
              " is not properly indented inside conjunction or " +
              " disjunction list item at " + junct.getLocation().toString()) ;
          } ;
         checkIndentation(child, junct) ;
       } ;
     } ;
    }

// predicate used in lookahead to discriminate between the Case Separator and
// the box operator. Returns true if it is most likely not the separator.
// This is a weak mechanism.
  boolean boxDisc() {
    Token t = getToken(1);
    if ( t.kind == CASESEP )
      return OperatorStack.preInEmptyTop();
    else
      return true;
  }

  boolean caseSep() {
    Token t = getToken(1);
    return ( t.kind == CASESEP );
  }

  boolean matchFcnConst () {
    /***********************************************************************
    * Seems to return true iff the next current token sequence begins      *
    * with "<< ...  >> \in" or "Identifier [, Identifier] \in".  It is     *
    * used after a "{" to see if this is a subset expression such as "{x   *
    * \in S : exp}" and after a "[" to see if it is a function expression  *
    * such as "[x \in S |-> exp]".  This leads to the bug that it starts   *
    * incorrectly interpreting the expressions "{x \in S}" and             *
    * "{<<1, 2>> \in {}}" as a subset expression and reports an error.     *
    ***********************************************************************/
    Token t = initPreviewToken();
    t = getNextPreviewToken( t );
   if (t.kind == LAB) {
      int count = 1;
      while (count != 0 ) {
        t = getNextPreviewToken( t );
        if (t.kind == LAB) count++;
        if (t.kind == RAB) count--;
        if (t.kind == EOF) return false;
      }
      t = getNextPreviewToken( t );
      return (t.kind == IN );
    } else
    if (t.kind == IDENTIFIER) {
      t = getNextPreviewToken( t );
      while ( t.kind == COMMA ) {
        t = getNextPreviewToken( t );
        if (t.kind != IDENTIFIER) return false;
        t = getNextPreviewToken( t );
      }
      return (t.kind == IN );
    } else
      return false;
  }

//  int numberFromStep( String step ) {
//    int top = step.indexOf('>');
//    return Integer.parseInt( step.substring( 1, top ) );
//  }
//
  Object msgStack[] = new Object[ 512 ];
  int msgStackMaxSize = 512;
  int msgStackCurrentSize = 0;

  private final void pushMsg( String s, Token t ) {
    if ( msgStackCurrentSize == msgStackMaxSize) {
      Object neo[] = new Object[ 2 * msgStackMaxSize ];
      System.arraycopy(msgStack, 0, neo, 0, msgStackMaxSize);
      msgStack = neo;
      msgStackMaxSize *= 2;
    }
    msgStack [ msgStackCurrentSize   ] = s;
    msgStack [ msgStackCurrentSize+1 ] = t;
    msgStackCurrentSize +=2;
  }

  private final void popMsg() {
    msgStackCurrentSize -=2;
  }

  private String expecting = "nothing";
    /***********************************************************************
    * It appears that the value of expecting is what is printed out in     *
    * error messages as what the parser was expecting when it encountered  *
    * an error.                                                            *
    ***********************************************************************/

  private final String msgStackToString(ParseException e) {
    StringBuffer msg;
    String name = " *unknown* (error occurred before module header)";
    if (mn != null) name = mn.toString();

    msg = new StringBuffer("***Parse Error***\n");
    if ( expecting != emptyString ) {
      msg.append("Was expecting \"");
      msg.append( expecting );
      msg.append("\"\n");
    }

    msg.append(e.getShortMessage());
//    msg.append(" while parsing ");
//    msg.append(name);
//
//    msg.append(".\nResidual stack trace follows:\n");

    msg.append("\n\nResidual stack trace follows:\n");
    int last = msgStackCurrentSize - 10;
    if (last < 0 ) last = 0;
    for ( int lvi = msgStackCurrentSize; lvi > last; lvi -=2 ) {
      msg.append( (String) msgStack[lvi -2 ] );
      msg.append(" starting at line ");
      Token t =  (Token) msgStack[lvi - 1 ];
      msg.append( t.beginLine );
      msg.append(", column ");
      msg.append( t.beginColumn );
      msg.append(".\n");
    }
    return msg.toString();
  }

//

  /*************************************************************************
  * heirsTable is an array of physical length heirsSize that implements a  *
  * dynamic array of length heirsIndex, where heirsIndex <= heirsSize.     *
  * Elements are added to heirsTable by the addHeir method, which          *
  * increments heirsSize if needed.  Elements are removed from the array   *
  * by the getLastHeirs() and popHeir() methods.                           *
  *                                                                        *
  * It appears that the heirsTable is used as a stack of sequences of      *
  * syntax tree nodes, each being the sequence of heirs (children) of a    *
  * node that is currently being parsed.  The top of the stack is the      *
  * sequence at the end of the heirsTable array.  Each sequence is begun   *
  * by a null entry.  The bpa() method is called when about to push such   *
  * a sequence onto the stack; it adds the null element that marks the     *
  * beginning of the sequence.  Similarly, the epa() method is called      *
  * after popping a sequence off the top of the stack; it removes the      *
  * null element.                                                          *
  *************************************************************************/
  private SyntaxTreeNode heirsTable[] = new SyntaxTreeNode[ 512 ];
  private int heirsSize = 512;
  private int heirsIndex = 0;

  private final void addHeir( SyntaxTreeNode sn ) {
    /***********************************************************************
    * Appends the syntax tree sn to the end of the dynamic array           *
    * implemented by heirsTable.                                           *
    ***********************************************************************/
    if ( heirsIndex == heirsSize ) {
      SyntaxTreeNode nh[] = new SyntaxTreeNode[ heirsSize + 512 ];
      System.arraycopy( heirsTable, 0, nh, 0, heirsSize );
      heirsSize += 512;
      heirsTable = nh;
    }
    heirsTable[ heirsIndex ] = sn; heirsIndex++;
  }

  private final SyntaxTreeNode[] getLastHeirs() {
    /***********************************************************************
    * This method will throw an array-out-of-bounds exception if called    *
    * when heirsIndex = 0 (so the dynamic array implemented by heirsTable  *
    * is empty) or if that dynamic array contains no null entry.           *
    *                                                                      *
    * If the last element of the dynamic heirsTable array is null, then    *
    * it returns null.  Otherwise, it returns an array equal to the        *
    * sequence of non-null elements at the end of the dynamic heirsTable   *
    * array and removes them from that array.                              *
    ***********************************************************************/
    int lvi = heirsIndex - 1;
    while (heirsTable[ lvi ] != null ) lvi--;
    /***********************************************************************
    * Assert: /\ lvi < heirsIndex                                          *
    *         /\ heirsTable[lvi] = null                                    *
    *         /\ \A i \in lvi+1 .. heirsIndex-1 : heirsTable[i] # null     *
    ***********************************************************************/
    int as = heirsIndex - lvi - 1;
    if (as == 0)
      return null;
    else {
      SyntaxTreeNode ts[] = new SyntaxTreeNode[ as ];
      System.arraycopy( heirsTable, lvi + 1, ts, 0, as);
      heirsIndex = lvi + 1;
      /*********************************************************************
      * Assert /\ as > 0                                                   *
      *        /\ \A i \in 0..as-1 : ts[i] = heirsTable[lvi + i + 1]       *
      *        /\ heirsIndex = lvi + 1                                     *
      *********************************************************************/
      return ts;
    }
  }

  private final boolean popHeir() {
   /************************************************************************
   * Throws an array-out-of-bounds exception if heirsIndex = 0 (meaning    *
   * that the dynamic array implemented by heirsTable is empty).           *
   *                                                                       *
   * It removes the last element from the heirsTable array and returns     *
   * true iff the new last element is null.                                *
   ************************************************************************/
    return heirsTable[ --heirsIndex ] == null;
  }

  private String emptyString = "";

  private final void bpa( String s) { // Beginning of Production Actions 
    addHeir( null );
if (System.getProperty("TLA-StackTrace", "off").equals("on")) ToolIO.out.println("Beginning " + s);
    pushMsg( s, getToken(1) );
    expecting = emptyString;
  }

  private final void epa() {
    popMsg();
if (System.getProperty("TLA-StackTrace", "off").equals("on")) ToolIO.out.println("Ending " + msgStack [ msgStackCurrentSize   ]);
    Assert.assertion( popHeir() );
    expecting = emptyString;
  }
//

  Stack internals = new Stack();

  private final void addDependency( UniqueString s ) {
    int lvi = internals.search( s );
    if ( lvi < 0 )
      dependencyList.addElement( s );
  }

  private final UniqueString reduceString( String s ) {
    int l = s.length();
    StringBuffer copy = new StringBuffer( l );
    int i = 0;
    int j = 0;
    while ( i!= l ) {
      if (s.charAt(i) == '\\' ) {
        i++; char c = s.charAt(i);
             if (c == '\\') copy.append( '\\');
        else if (c == 'n')  copy.append( '\n');
        else if (c == 'r')  copy.append( '\r');
        else if (c == 'f')  copy.append( '\f');
        else if (c == 't')  copy.append( '\t');
        else if (c == '"')  copy.append( '"');
      } else
         copy.append( s.charAt(i));
      i++; j++;
    }
    copy.setLength(j);
    return UniqueString.uniqueStringOf(copy.toString());
  }

/***************************************************************************
* Fields and methods for parsing proofs.                                   *
***************************************************************************/
private int proofDepth = -1 ;
  /*************************************************************************
  * The nesting level of the proof we're currently processing, counting    *
  * from 0 a la Java.                                                      *
  *************************************************************************/

private final int MaxProofDepth = 100 ;
private int[] proofLevelStack = new int[MaxProofDepth] ;
  /*************************************************************************
  * The level number of a proof with steps numbered <n>x is n.  The value  *
  * of proofLevelStack[proofDepth] is the level number of the current      *
  * proof.  If we have started processing a proof haven't yet determined   *
  * its level, then proofLevelStack[proofDepth] equals -1.                 *
  *************************************************************************/

private int levelOfProofStepLexeme(Token tok){
  /*************************************************************************
  * The level of a ProofStepLexeme or ProofStepDotLexeme.  It returns -1   *
  * for "*" and -2 for "*".                                                *
  *************************************************************************/
  String im = tok.image ;
  if (im.substring(1,2).equals("*")) {return -1;} ;
  if (im.substring(1,2).equals("+")) {return -2;} ;
  return new Integer(im.substring(1, im.indexOf('>'))).intValue() ;
    /***********************************************************************
    * The ".intValue()" added by SZ because Java 1.4 doesn't support       *
    * auto-boxing.                                                         *
    ***********************************************************************/
 }

/***************************************************************************
* The following method returns the canonical form of the step number       *
* contained in token t.  This means that a "+" or "*" is replaced by the   *
* appropriate level number, and leading zeros are removed from a regular   *
* level number.                                                            *
***************************************************************************/
private UniqueString correctedStepNum(Token t) {
  String str = t.image ;
  if (   str.substring(1,2).equals("*")
      || str.substring(1,2).equals("+") ) {
    int level = getProofLevel() ;
    if ((level < 0) && (proofDepth > 0)) {
      /*********************************************************************
      * We've started a proof without yet determining the level number.    *
      * Since this method is being called when encountering a step number  *
      * token, this means we've encountered a step number inside a BY. So  *
      * the actual level number to use here is the "previous" level        *
      * number.                                                            *
      *********************************************************************/
      level = proofLevelStack[proofDepth-1] ;
     }
    str = "<" + level + str.substring(2) ;
   }
  else {str = "<" + levelOfProofStepLexeme(t) + str.substring(str.indexOf('>'));
   } ;
  return UniqueString.uniqueStringOf(str) ;
  } ;

private void pushProofLevel() throws ParseException {
  /*************************************************************************
  * Called to begin the processing of a new proof level.  It increments    *
  * proofDepth and sets the proofLevelStack entry to -1.                   *
  *************************************************************************/
  proofDepth++ ;
  if (proofDepth >= MaxProofDepth) {
    throw new ParseException("Proofs nested more than " +
                             MaxProofDepth + "deep.") ;
   } ;
  proofLevelStack[proofDepth] = -1 ;
 }

private void popProofLevel() throws ParseException {
  if (proofDepth < 0) {
    throw new ParseException("Parser bug: an extra QED step found." ) ;
   } ;
  proofDepth-- ;
 }

private void setProofLevel(int val) throws ParseException {
  if (proofDepth < 0) {
    throw new ParseException("Parser bug: proof step found outside proof." ) ;
   } ;
  proofLevelStack[proofDepth] = val;
 }

private int getProofLevel() {
  if (proofDepth < 0) { return proofDepth; } ;
  return proofLevelStack[proofDepth]; }

private boolean beginsProof(Token tok) {
  /*************************************************************************
  * True iff the token tok begins a new proof--that is, iff it is either   *
  * "BY", "PROOF", a step number that has a higher level than the current  *
  * level, begins "<+>", or begins "<*>" and we are not inside a proof.    *
  *************************************************************************/
  String im = tok.image ;
  if (im.length() < 2) {return false;}
    /***********************************************************************
    * This can happen if the user makes a weird error.                     *
    ***********************************************************************/
  if (im.substring(1,2).equals("*")) {return (proofDepth < 0);} ;

  if (im.substring(1,2).equals("+")) {return true ;} ;
  switch (tok.kind) {
    case ProofStepLexeme :
    case BareLevelLexeme :
    case UnnumberedStepLexeme :
    case ProofStepDotLexeme :
      if (proofDepth < 0) {return true ;} ;
      int tokLevel = levelOfProofStepLexeme(tok) ;
      return    (proofLevelStack[proofDepth] >= 0)
             && (tokLevel > proofLevelStack[proofDepth]) ;
    case BY :
    case PROOF :
    case OBVIOUS :
    case OMITTED :
      return true ;
   }; // switch
  return false ;
 }

private boolean correctLevel(Token tok) {
  /*************************************************************************
  * True iff tok is a correct proof step token for the current level of    *
  * proof, where precedeByPROOF is true iff the proof is preceded by a     *
  * "PROOF" token (needed in case this is the first step of the proof).    *
  * If this is the first step being processed for current proof, then it   *
  * sets the current proof level.                                          *
  *************************************************************************/
  int tokLevel = levelOfProofStepLexeme(tok) ;

  /*************************************************************************
  * Set lastDepth to the level of the containing proof, or -1 if this is   *
  * the top-level proof.                                                   *
  *************************************************************************/
  int lastLevel = -1 ;
  if (proofDepth > 0) {lastLevel = proofLevelStack[proofDepth-1] ;}
  switch (tokLevel) {
    case -1 :
      /*********************************************************************
      * tok is <*>...  This is always legal because it can begin a proof   *
      * iff it was preceded by a "PROOF".                                  *
      *********************************************************************/
      if (proofLevelStack[proofDepth] < 0) {
        proofLevelStack[proofDepth] = lastLevel + 1 ;
       } ;
      return true ;

    case -2 :
      /*********************************************************************
      * tok is <+>...  This is legal iff it begins a proof.                *
      *********************************************************************/
      if (proofLevelStack[proofDepth] < 0) {
        proofLevelStack[proofDepth] = lastLevel + 1 ;
        return true ;
       }
      else return false ;

    default :
      if (proofLevelStack[proofDepth] < 0) {
        proofLevelStack[proofDepth] = tokLevel;
        return   (tokLevel > lastLevel) ;
       }
      else return (proofLevelStack[proofDepth] == tokLevel) ;
   }
 }

/* beginning of the grammar productions */
  final public Token PrefixOpToken() throws ParseException {
  Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case op_26:
      t = jj_consume_token(op_26);
      break;
    case op_29:
      t = jj_consume_token(op_29);
      break;
    case op_58:
      t = jj_consume_token(op_58);
      break;
    case CASESEP:
      t = jj_consume_token(CASESEP);
      break;
    case op_61:
      t = jj_consume_token(op_61);
      break;
    case op_112:
      t = jj_consume_token(op_112);
      break;
    case op_113:
      t = jj_consume_token(op_113);
      break;
    case op_114:
      t = jj_consume_token(op_114);
      break;
    case op_115:
      t = jj_consume_token(op_115);
      break;
    case op_116:
      t = jj_consume_token(op_116);
      break;
    default:
      jj_la1[0] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return t;}
    throw new Error("Missing return statement in function");
  }

/***************************************************************************
* NEPrefixOpToken and PrefixOpToken differ because the first includes      *
* "-." while the second contains does not.  Neither includes "-".          *
***************************************************************************/
  final public Token NEPrefixOpToken() throws ParseException {
  Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case op_26:
      t = jj_consume_token(op_26);
      break;
    case op_29:
      t = jj_consume_token(op_29);
      break;
    case op_58:
      t = jj_consume_token(op_58);
      break;
    case CASESEP:
      t = jj_consume_token(CASESEP);
      break;
    case op_61:
      t = jj_consume_token(op_61);
      break;
    case op_76:
      t = jj_consume_token(op_76);
      break;
    case op_112:
      t = jj_consume_token(op_112);
      break;
    case op_113:
      t = jj_consume_token(op_113);
      break;
    case op_114:
      t = jj_consume_token(op_114);
      break;
    case op_115:
      t = jj_consume_token(op_115);
      break;
    case op_116:
      t = jj_consume_token(op_116);
      break;
    default:
      jj_la1[1] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return t;}
    throw new Error("Missing return statement in function");
  }

  final public Token InfixOpToken() throws ParseException {
  Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case op_1:
      t = jj_consume_token(op_1);
      break;
    case AND:
      t = jj_consume_token(AND);
      break;
    case op_3:
      t = jj_consume_token(op_3);
      break;
    case op_4:
      t = jj_consume_token(op_4);
      break;
    case OR:
      t = jj_consume_token(OR);
      break;
    case op_6:
      t = jj_consume_token(op_6);
      break;
    case op_7:
      t = jj_consume_token(op_7);
      break;
    case op_8:
      t = jj_consume_token(op_8);
      break;
    case op_9:
      t = jj_consume_token(op_9);
      break;
    case op_10:
      t = jj_consume_token(op_10);
      break;
    case op_11:
      t = jj_consume_token(op_11);
      break;
    case op_12:
      t = jj_consume_token(op_12);
      break;
    case op_13:
      t = jj_consume_token(op_13);
      break;
    case op_14:
      t = jj_consume_token(op_14);
      break;
    case op_15:
      t = jj_consume_token(op_15);
      break;
    case op_16:
      t = jj_consume_token(op_16);
      break;
    case op_17:
      t = jj_consume_token(op_17);
      break;
    case op_18:
      t = jj_consume_token(op_18);
      break;
    case op_19:
      t = jj_consume_token(op_19);
      break;
    case IN:
      t = jj_consume_token(IN);
      break;
    case op_21:
      t = jj_consume_token(op_21);
      break;
    case op_22:
      t = jj_consume_token(op_22);
      break;
    case op_23:
      t = jj_consume_token(op_23);
      break;
    case op_24:
      t = jj_consume_token(op_24);
      break;
    case op_25:
      t = jj_consume_token(op_25);
      break;
    case op_27:
      t = jj_consume_token(op_27);
      break;
    case op_30:
      t = jj_consume_token(op_30);
      break;
    case op_31:
      t = jj_consume_token(op_31);
      break;
    case op_32:
      t = jj_consume_token(op_32);
      break;
    case op_33:
      t = jj_consume_token(op_33);
      break;
    case op_34:
      t = jj_consume_token(op_34);
      break;
    case op_35:
      t = jj_consume_token(op_35);
      break;
    case op_36:
      t = jj_consume_token(op_36);
      break;
    case op_37:
      t = jj_consume_token(op_37);
      break;
    case op_38:
      t = jj_consume_token(op_38);
      break;
    case op_39:
      t = jj_consume_token(op_39);
      break;
    case op_40:
      t = jj_consume_token(op_40);
      break;
    case op_41:
      t = jj_consume_token(op_41);
      break;
    case op_42:
      t = jj_consume_token(op_42);
      break;
    case op_43:
      t = jj_consume_token(op_43);
      break;
    case op_44:
      t = jj_consume_token(op_44);
      break;
    case op_45:
      t = jj_consume_token(op_45);
      break;
    case op_46:
      t = jj_consume_token(op_46);
      break;
    case op_47:
      t = jj_consume_token(op_47);
      break;
    case op_48:
      t = jj_consume_token(op_48);
      break;
    case op_49:
      t = jj_consume_token(op_49);
      break;
    case op_50:
      t = jj_consume_token(op_50);
      break;
    case op_51:
      t = jj_consume_token(op_51);
      break;
    case op_52:
      t = jj_consume_token(op_52);
      break;
    case op_53:
      t = jj_consume_token(op_53);
      break;
    case op_54:
      t = jj_consume_token(op_54);
      break;
    case op_55:
      t = jj_consume_token(op_55);
      break;
    case op_56:
      t = jj_consume_token(op_56);
      break;
    case op_59:
      t = jj_consume_token(op_59);
      break;
    case op_62:
      t = jj_consume_token(op_62);
      break;
    case op_63:
      t = jj_consume_token(op_63);
      break;
    case op_64:
      t = jj_consume_token(op_64);
      break;
    case EQUALS:
      t = jj_consume_token(EQUALS);
      break;
    case op_66:
      t = jj_consume_token(op_66);
      break;
    case op_67:
      t = jj_consume_token(op_67);
      break;
    case op_71:
      t = jj_consume_token(op_71);
      break;
    case op_72:
      t = jj_consume_token(op_72);
      break;
    case op_73:
      t = jj_consume_token(op_73);
      break;
    case op_74:
      t = jj_consume_token(op_74);
      break;
    case op_75:
      t = jj_consume_token(op_75);
      break;
    case op_77:
      t = jj_consume_token(op_77);
      break;
    case op_78:
      t = jj_consume_token(op_78);
      break;
    case op_79:
      t = jj_consume_token(op_79);
      break;
    case op_80:
      t = jj_consume_token(op_80);
      break;
    case op_81:
      t = jj_consume_token(op_81);
      break;
    case op_82:
      t = jj_consume_token(op_82);
      break;
    case op_83:
      t = jj_consume_token(op_83);
      break;
    case op_84:
      t = jj_consume_token(op_84);
      break;
    case op_85:
      t = jj_consume_token(op_85);
      break;
    case op_86:
      t = jj_consume_token(op_86);
      break;
    case op_87:
      t = jj_consume_token(op_87);
      break;
    case op_88:
      t = jj_consume_token(op_88);
      break;
    case op_89:
      t = jj_consume_token(op_89);
      break;
    case op_90:
      t = jj_consume_token(op_90);
      break;
    case op_91:
      t = jj_consume_token(op_91);
      break;
    case op_92:
      t = jj_consume_token(op_92);
      break;
    case op_93:
      t = jj_consume_token(op_93);
      break;
    case op_94:
      t = jj_consume_token(op_94);
      break;
    case op_95:
      t = jj_consume_token(op_95);
      break;
    case op_96:
      t = jj_consume_token(op_96);
      break;
    case op_97:
      t = jj_consume_token(op_97);
      break;
    case op_98:
      t = jj_consume_token(op_98);
      break;
    case op_100:
      t = jj_consume_token(op_100);
      break;
    case op_101:
      t = jj_consume_token(op_101);
      break;
    case op_102:
      t = jj_consume_token(op_102);
      break;
    case op_103:
      t = jj_consume_token(op_103);
      break;
    case op_104:
      t = jj_consume_token(op_104);
      break;
    case op_105:
      t = jj_consume_token(op_105);
      break;
    case op_106:
      t = jj_consume_token(op_106);
      break;
    case op_107:
      t = jj_consume_token(op_107);
      break;
    case op_108:
      t = jj_consume_token(op_108);
      break;
    case op_109:
      t = jj_consume_token(op_109);
      break;
    case op_110:
      t = jj_consume_token(op_110);
      break;
    case op_111:
      t = jj_consume_token(op_111);
      break;
    case op_117:
      t = jj_consume_token(op_117);
      break;
    case op_118:
      t = jj_consume_token(op_118);
      break;
    case op_119:
      t = jj_consume_token(op_119);
      break;
    default:
      jj_la1[2] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return t;}
    throw new Error("Missing return statement in function");
  }

  final public Token PostfixOpToken() throws ParseException {
Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case op_57:
      t = jj_consume_token(op_57);
      break;
    case op_68:
      t = jj_consume_token(op_68);
      break;
    case op_69:
      t = jj_consume_token(op_69);
      break;
    case op_70:
      t = jj_consume_token(op_70);
      break;
    default:
      jj_la1[3] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return t;}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode CompilationUnit() throws ParseException {
  SyntaxTreeNode tempASTN;
  belchDEF();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BEGIN_PRAGMA:
      Prelude();
      break;
    default:
      jj_la1[4] = jj_gen;
      ;
    }
    tempASTN = Module();
                        token_source.SwitchTo(0);
    {if (true) return tempASTN;}
    throw new Error("Missing return statement in function");
  }

/* SwitchTo is used to reset the state of the tokenizer */
  final public void Prelude() throws ParseException {
    jj_consume_token(BEGIN_PRAGMA);
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NUMBER:
      case IDENTIFIER:
        ;
        break;
      default:
        jj_la1[5] = jj_gen;
        break label_1;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NUMBER:
        jj_consume_token(NUMBER);
        break;
      case IDENTIFIER:
        jj_consume_token(IDENTIFIER);
        break;
      default:
        jj_la1[6] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  final public SyntaxTreeNode Module() throws ParseException {
  Token t;
  SyntaxTreeNode lSTN[] = new SyntaxTreeNode[ 4 ];
  bpa( "Module definition" );
  internals.push( null );
  Object pop = null;
  expecting = "---- MODULE";
    lSTN[0] = BeginModule();
  expecting = "EXTENDS clause or module body";
    lSTN[1] = Extends();
  expecting = "Module body";
    lSTN[2] = Body();
  expecting = "==== or more Module body";
    lSTN[3] = EndModule();
  do { pop = internals.pop(); } while (pop != null );
  internals.push( lSTN[0].zero[1].image );
  epa(); {if (true) return new SyntaxTreeNode( mn, N_Module, lSTN );}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode BeginModule() throws ParseException {
  SyntaxTreeNode lSTN[] = new SyntaxTreeNode[3];
  Token t;
  bpa( "Begin module" );
  expecting = "---- MODULE (beginning of module)";
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case _BM0:
      t = jj_consume_token(_BM0);
      break;
    case _BM1:
      t = jj_consume_token(_BM1);
      break;
    case _BM2:
      t = jj_consume_token(_BM2);
      break;
    default:
      jj_la1[7] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      lSTN[0] =  new SyntaxTreeNode(mn, t);
  expecting = "Identifier";
  t = getToken(1);
  if (isFieldNameToken( t )) t.kind = IDENTIFIER;
    lSTN[1] = Identifier();
    if ( mn == null ) mn = lSTN[1].image;
    expecting = "----";
    t = jj_consume_token(SEPARATOR);
                      lSTN[2] =  new SyntaxTreeNode(mn, t );
    epa(); {if (true) return new SyntaxTreeNode( mn, N_BeginModule, lSTN );}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode EndModule() throws ParseException {
  SyntaxTreeNode lSTN[] = new SyntaxTreeNode[1];
  Token t;
    t = jj_consume_token(END_MODULE);
    lSTN[0] = new SyntaxTreeNode(mn, t);
    {if (true) return new SyntaxTreeNode(mn, N_EndModule, lSTN );}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode Extends() throws ParseException {
  SyntaxTreeNode tn;
  Token t;
  bpa( "Extends" );
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EXTENDS:
      t = jj_consume_token(EXTENDS);
                        addHeir( new SyntaxTreeNode(mn, t));
  expecting = "Identifier";
  t = getToken(1);
  if (isFieldNameToken( t )) t.kind = IDENTIFIER;
      tn = Identifier();
                      addDependency( tn.image ); addHeir( tn );
  expecting = "comma or module body";
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[8] = jj_gen;
          break label_2;
        }
        t = jj_consume_token(COMMA);
                       addHeir( new SyntaxTreeNode(mn, t) );
  expecting = "Identifier";
  t = getToken(1);
  if (isFieldNameToken( t )) t.kind = IDENTIFIER;
        tn = Identifier();
                        addDependency( tn.image ); addHeir( tn );
      }
      break;
    default:
      jj_la1[9] = jj_gen;
      ;
    }
    SyntaxTreeNode sn[] = getLastHeirs();
    epa(); {if (true) return new SyntaxTreeNode( mn, N_Extends, sn );}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode Body() throws ParseException {
  SyntaxTreeNode tn, sn[];
  Token t;
  bpa("Module body");
  expecting = "LOCAL, INSTANCE, PROOF, ASSUMPTION, THEOREM, " +
              "RECURSIVE, declaration, or definition";
    label_3:
    while (true) {
      if (jj_2_1(1)) {
        ;
      } else {
        break label_3;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SEPARATOR:
        t = jj_consume_token(SEPARATOR);
                        tn = new SyntaxTreeNode(mn, t);
        break;
      case VARIABLE:
        tn = VariableDeclaration();
        break;
      case CONSTANT:
        tn = ParamDeclaration();
        break;
      default:
        jj_la1[10] = jj_gen;
        if (jj_2_2(2)) {
          tn = OperatorOrFunctionDefinition();
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case RECURSIVE:
            tn = Recursive();
            break;
          default:
            jj_la1[11] = jj_gen;
            if (jj_2_3(2)) {
              tn = Instance();
            } else if (jj_2_4(2)) {
              tn = Assumption();
            } else if (jj_2_5(2)) {
              tn = Theorem();
            } else {
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case _BM1:
              case _BM2:
              case _BM0:
                tn = Module();
                                      belchDEF();
                break;
              default:
                jj_la1[12] = jj_gen;
                if ((getToken(1).kind == USE) || (getToken(1).kind == HIDE)) {
                  tn = UseOrHideOrBy();
                } else {
                  jj_consume_token(-1);
                  throw new ParseException();
                }
              }
            }
          }
        }
      }
                                addHeir(tn);
    }
    sn = getLastHeirs(); epa();
    {if (true) return new SyntaxTreeNode(mn, N_Body, sn );}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode VariableDeclaration() throws ParseException {
  SyntaxTreeNode tn, sn[];
  Token t;
  SyntaxTreeNode lSTN[] = new SyntaxTreeNode[1];
  bpa( "variable declaration" );
    t = jj_consume_token(VARIABLE);
                       lSTN[0] = new SyntaxTreeNode( mn, t);
  expecting = "Identifier";
    tn = Identifier();
                      addHeir( tn );
  expecting = "comma or module body";
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[13] = jj_gen;
        break label_4;
      }
      t = jj_consume_token(COMMA);
                       addHeir( new SyntaxTreeNode( mn, t) ) ;
  expecting = "Identifier";
      tn = Identifier();
                        addHeir( tn );
    }
    sn = getLastHeirs();
    epa(); {if (true) return new SyntaxTreeNode(mn, N_VariableDeclaration, lSTN, sn );}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode ParamDeclaration() throws ParseException {
  SyntaxTreeNode tn, sn[];
  Token t;
  bpa("Parameter declaration");
  expecting = "CONSTANT";
    tn = ParamSubDecl();
                         addHeir(tn);
 expecting = "Identifier, operator or _";
    tn = ConstantDeclarationItems();
                                    addHeir(tn);
 expecting = ",";
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[14] = jj_gen;
        break label_5;
      }
      t = jj_consume_token(COMMA);
                       addHeir( new SyntaxTreeNode(mn, t) ) ;
 expecting = "Identifier, operator or _";
      tn = ConstantDeclarationItems();
                                      addHeir(tn);
    }
    sn = getLastHeirs();
    epa(); {if (true) return new SyntaxTreeNode(mn, N_ParamDeclaration, sn );}
    throw new Error("Missing return statement in function");
  }

/***************************************************************************
* Used to allow "STATE FUNCTION", "TEMPORAL", etc.                         *
***************************************************************************/
  final public SyntaxTreeNode ParamSubDecl() throws ParseException {
  SyntaxTreeNode tn, sn[];
  Token t, u;
  bpa("Parameter declaration item");
    t = jj_consume_token(CONSTANT);
     sn = new SyntaxTreeNode[1]; sn[0] = new SyntaxTreeNode(mn, t);
     tn = new SyntaxTreeNode(mn, N_ConsDecl, sn );
    epa();
    {if (true) return tn;}
    throw new Error("Missing return statement in function");
  }

/***************************************************************************
* Recursive ::= <CONSTANT> ConstantDeclarationItems                        *
*                 ( <COMMA> ConstantDeclarationItems )*                    *
*                                                                          *
* Produces an N_Recursive node.                                            *
***************************************************************************/
  final public SyntaxTreeNode Recursive() throws ParseException {
  SyntaxTreeNode tn, sn[];
  Token t;
  bpa("Recursive");
  expecting = "RECURSIVE";
    t = jj_consume_token(RECURSIVE);
                    addHeir(new SyntaxTreeNode(mn, t));
                    expecting = "Identifier, operator or _";
    tn = ConstantDeclarationItems();
                                    addHeir(tn);
                                    expecting = ",";
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[15] = jj_gen;
        break label_6;
      }
      t = jj_consume_token(COMMA);
                       addHeir( new SyntaxTreeNode(mn, t) ) ;
                       expecting = "Identifier, operator or _";
      tn = ConstantDeclarationItems();
                                      addHeir(tn);
                                      expecting = "`,' or `)'";
    }
    sn = getLastHeirs();
    epa(); {if (true) return new SyntaxTreeNode(mn, N_Recursive, sn );}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode ConstantDeclarationItems() throws ParseException {
  SyntaxTreeNode tn, sn[];
  int kind;
  Token t;
  bpa( "Constant declaration items");
  expecting = "Identifier, _ or prefix op";
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      tn = Identifier();
                      addHeir( tn ); kind = N_IdentDecl;
expecting  = "(, comma, or Module Body";
      if (jj_2_6(2)) {
        /*******************************************************************
                * The following comment apparently made sense at the time.  I      *
                * wonder what it should have said.                                 *
                *                                                                  *
                * This lookahead was added by J-Ch & LL on 1 Mar 2007 to fix the   *
                * error when it tried to parse                                     *
                *                                                                  *
                *    CONSTANT ASSUME A                                             *
                *             (B+C)                                                *
                *    PROVE ...                                                     *
                *******************************************************************/
              t = jj_consume_token(LBR);
                  addHeir( new SyntaxTreeNode( mn, t) ) ;
expecting = "_";
        t = jj_consume_token(US);
                  addHeir( new SyntaxTreeNode( mn, t) ) ;
expecting = "comma or )";
        label_7:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            jj_la1[16] = jj_gen;
            break label_7;
          }
          t = jj_consume_token(COMMA);
                      addHeir( new SyntaxTreeNode( mn, t) ) ;
expecting = "_";
          t = jj_consume_token(US);
                      addHeir( new SyntaxTreeNode( mn, t) ) ;
expecting = "comma or )";
        }
        t = jj_consume_token(RBR);
                  addHeir( new SyntaxTreeNode( mn, t) ) ;
      } else {
        ;
      }
      break;
    case op_76:
    case op_26:
    case op_29:
    case op_58:
    case CASESEP:
    case op_61:
    case op_112:
    case op_113:
    case op_114:
    case op_115:
    case op_116:
      // LOOKAHEAD( <OpSymbol>, { isPrefixDeclOp( getToken(1) )  } )
          tn = NonExpPrefixOp();
expecting = "_";
      kind = N_PrefixDecl; addHeir( tn );
      t = jj_consume_token(US);
               addHeir( new SyntaxTreeNode( mn, t) ) ;
      break;
    case US:
      t = jj_consume_token(US);
expecting = "prefix or postfix operator";
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case op_1:
      case AND:
      case op_3:
      case op_4:
      case OR:
      case op_6:
      case op_7:
      case op_8:
      case op_9:
      case op_10:
      case op_11:
      case op_12:
      case op_13:
      case op_14:
      case op_15:
      case op_16:
      case op_17:
      case op_18:
      case op_19:
      case IN:
      case op_21:
      case op_22:
      case op_23:
      case op_24:
      case op_25:
      case op_27:
      case op_30:
      case op_31:
      case op_32:
      case op_33:
      case op_34:
      case op_35:
      case op_36:
      case op_37:
      case op_38:
      case op_39:
      case op_40:
      case op_41:
      case op_42:
      case op_43:
      case op_44:
      case op_45:
      case op_46:
      case op_47:
      case op_48:
      case op_49:
      case op_50:
      case op_51:
      case op_52:
      case op_53:
      case op_54:
      case op_55:
      case op_56:
      case op_59:
      case op_62:
      case op_63:
      case op_64:
      case EQUALS:
      case op_66:
      case op_67:
      case op_71:
      case op_72:
      case op_73:
      case op_74:
      case op_75:
      case op_77:
      case op_78:
      case op_79:
      case op_80:
      case op_81:
      case op_82:
      case op_83:
      case op_84:
      case op_85:
      case op_86:
      case op_87:
      case op_88:
      case op_89:
      case op_90:
      case op_91:
      case op_92:
      case op_93:
      case op_94:
      case op_95:
      case op_96:
      case op_97:
      case op_98:
      case op_100:
      case op_101:
      case op_102:
      case op_103:
      case op_104:
      case op_105:
      case op_106:
      case op_107:
      case op_108:
      case op_109:
      case op_110:
      case op_111:
      case op_117:
      case op_118:
      case op_119:
        tn = InfixOp();
expecting = "_";
        kind = N_InfixDecl;
        addHeir( new SyntaxTreeNode( mn, t) );
        addHeir(tn);
        t = jj_consume_token(US);
                   addHeir( new SyntaxTreeNode( mn, t) ) ;
        break;
      case op_57:
      case op_68:
      case op_69:
      case op_70:
        tn = PostfixOp();
        kind = N_PostfixDecl;
        addHeir( new SyntaxTreeNode( mn, t) );
        addHeir(tn);
        break;
      default:
        jj_la1[17] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[18] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    sn = getLastHeirs();
    epa();
    {if (true) return new SyntaxTreeNode( mn, kind, sn);}
    throw new Error("Missing return statement in function");
  }

/***************************************************************************
* The following production OperatorOrFunctionDefinition() produces an      *
* N_OperatorDefinition, N_FunctionDefinition, or N_ModuleDefinition        *
* node.  These nodes have syntax "[LOCAL] ...".  The resulting node n      *
* has n.zero equal to null if the "LOCAL" is missing and equal to an       *
* array of length 1 containing the LOCAL token if it is present.  The      *
* rest of the children/heirs of the node are in the array n.one.           *
***************************************************************************/
  final public SyntaxTreeNode OperatorOrFunctionDefinition() throws ParseException {
  SyntaxTreeNode tn;
  SyntaxTreeNode zn = null;
  bpa("Definition");
  int kind = 0;
  String n;
  Token t;
  expecting = "LOCAL, Identifier or Operator Symbol";
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LOCAL:
      t = jj_consume_token(LOCAL);
                  zn = new SyntaxTreeNode( mn, t);
      break;
    default:
      jj_la1[19] = jj_gen;
      ;
    }
    t = jj_consume_token(DEFBREAK);
  expecting = "LOCAL, Identifier or Operator Symbol";
    if (jj_2_8(2147483647)) {
      /* recognize function */
              tn = Identifier();
                            addHeir( tn );  kind = N_FunctionDefinition;
expecting = "[";
      t = jj_consume_token(LSB);
          addHeir( new SyntaxTreeNode(mn, t) );
expecting = "Identifier";
      tn = QuantBound();
                            addHeir( tn );
expecting = "COMMA or ]";
      label_8:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[20] = jj_gen;
          break label_8;
        }
        t = jj_consume_token(COMMA);
                        addHeir( new SyntaxTreeNode(mn, t) );
expecting = "Identifier";
        tn = QuantBound();
                              addHeir( tn );
      }
      t = jj_consume_token(RSB);
expecting = "==";
          addHeir( new SyntaxTreeNode(mn, t) );
      t = jj_consume_token(DEF);
                     belchDEF(); addHeir( new SyntaxTreeNode(mn, t) );
expecting = "Expression";
      tn = Expression();
                            addHeir( tn );
    } else if (jj_2_9(2147483647)) {
      tn = PostfixLHS();
                             addHeir( tn );
expecting = "==";
      t = jj_consume_token(DEF);
                     belchDEF(); kind = N_OperatorDefinition;
          addHeir( new SyntaxTreeNode(mn, t) );
expecting = "Expression";
      tn = Expression();
                            addHeir( tn );
    } else if (jj_2_10(2147483647)) {
      tn = InfixLHS();
                           addHeir( tn );
expecting = "==";
      t = jj_consume_token(DEF);
                     belchDEF();  kind = N_OperatorDefinition;
          addHeir( new SyntaxTreeNode(mn, t) );
expecting = "Expression";
      tn = Expression();
                            addHeir( tn );
    } else if (jj_2_11(2147483647)) {
      /* recognize operator OR module instance */
              tn = IdentLHS();
                          addHeir( tn );
expecting = "==";
      t = jj_consume_token(DEF);
                     belchDEF(); addHeir( new SyntaxTreeNode(mn, t) );
expecting = "Expression or Instance";
      if (jj_2_7(1)) {
        tn = Expression();
                              kind = N_OperatorDefinition;
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case INSTANCE:
          tn = Instantiation();
                                   kind = N_ModuleDefinition;
          break;
        default:
          jj_la1[21] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
            addHeir( tn );
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case op_76:
      case op_26:
      case op_29:
      case op_58:
      case CASESEP:
      case op_61:
      case op_112:
      case op_113:
      case op_114:
      case op_115:
      case op_116:
        tn = PrefixLHS();
                         addHeir( tn );
expecting = "==";
        t = jj_consume_token(DEF);
                   belchDEF();
        kind = N_OperatorDefinition;
        addHeir( new SyntaxTreeNode(mn, t) );
expecting = "Expression";
        tn = Expression();
                          addHeir( tn );
        break;
      default:
        jj_la1[22] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    SyntaxTreeNode sn[] = getLastHeirs();
    epa(); {if (true) return new SyntaxTreeNode(mn,kind, zn, sn);}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode IdentifierTuple() throws ParseException {
  SyntaxTreeNode tn;
  SyntaxTreeNode hn[];
  Token t;
  bpa("Identifier tuple");
    t = jj_consume_token(LAB);
               addHeir( new SyntaxTreeNode(mn, t) );
expecting = "Identifier or >>";
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      tn = Identifier();
                        addHeir( tn );
expecting = "COMMA or >>";
      label_9:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[23] = jj_gen;
          break label_9;
        }
        t = jj_consume_token(COMMA);
                    addHeir( new SyntaxTreeNode(mn, t) );
expecting = "COMMA or >>";
        tn = Identifier();
                          addHeir( tn );
expecting = "COMMA or >>";
      }
      break;
    default:
      jj_la1[24] = jj_gen;
      ;
    }
    t = jj_consume_token(RAB);
               addHeir( new SyntaxTreeNode(mn, t) );
    SyntaxTreeNode sn[] = getLastHeirs();
    epa(); {if (true) return new SyntaxTreeNode( mn, N_IdentifierTuple, sn  );}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode IdentLHS() throws ParseException {
  SyntaxTreeNode tn;
  Token t;
  bpa("Identifier LHS");
    tn = Identifier();
                      addHeir( tn );
expecting = "( or ==";
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBR:
      t = jj_consume_token(LBR);
                  addHeir( new SyntaxTreeNode(mn, t) );
expecting = "Identifier Declaration, prefix op, _ or )";
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        tn = IdentDecl();
        break;
      case US:
      case op_76:
      case op_26:
      case op_29:
      case op_58:
      case CASESEP:
      case op_61:
      case op_112:
      case op_113:
      case op_114:
      case op_115:
      case op_116:
        tn = SomeFixDecl();
        break;
      default:
        jj_la1[25] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                                                   addHeir( tn );
expecting = "COMMA or )";
      label_10:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[26] = jj_gen;
          break label_10;
        }
        t = jj_consume_token(COMMA);
                       addHeir( new SyntaxTreeNode(mn, t) );
expecting = "Identifier Declaration, prefix op or _";
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENTIFIER:
          tn = IdentDecl();
          break;
        case US:
        case op_76:
        case op_26:
        case op_29:
        case op_58:
        case CASESEP:
        case op_61:
        case op_112:
        case op_113:
        case op_114:
        case op_115:
        case op_116:
          tn = SomeFixDecl();
          break;
        default:
          jj_la1[27] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
                                                     addHeir( tn );
expecting = "COMMA or )";
      }
      t = jj_consume_token(RBR);
                  addHeir( new SyntaxTreeNode(mn, t) );
      break;
    default:
      jj_la1[28] = jj_gen;
      ;
    }
    SyntaxTreeNode sn[] = getLastHeirs();
    epa(); {if (true) return new SyntaxTreeNode( mn, N_IdentLHS, sn);}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode PrefixLHS() throws ParseException {
  SyntaxTreeNode sn[] = new SyntaxTreeNode[2];
  SyntaxTreeNode tn;
  Token t;
  bpa("Prefix LHS");
    t = NEPrefixOpToken();
                            sn[0] = new SyntaxTreeNode(mn, t);
expecting = "Identifier";
    tn = Identifier();
                      sn[1] = tn;
    epa(); {if (true) return new SyntaxTreeNode( mn, N_PrefixLHS, sn );}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode InfixLHS() throws ParseException {
  SyntaxTreeNode sn[] = new SyntaxTreeNode[3];
  SyntaxTreeNode tn;
  Token t;
  bpa("Infix LHS");
    tn = Identifier();
                      sn[0] = tn;
    t = InfixOpToken();
                         sn[1] = new SyntaxTreeNode(mn, t);
    tn = Identifier();
                      sn[2] = tn;
    epa(); {if (true) return new SyntaxTreeNode( mn, N_InfixLHS, sn );}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode PostfixLHS() throws ParseException {
  SyntaxTreeNode sn[] = new SyntaxTreeNode[2];
  SyntaxTreeNode tn;
  Token t;
  bpa("Postfix LHS");
    tn = Identifier();
                      sn[0] = tn;
    t = PostfixOpToken();
                           sn[1] = new SyntaxTreeNode(mn, t);
    epa(); {if (true) return new SyntaxTreeNode( mn, N_PostfixLHS, sn );}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode IdentDecl() throws ParseException {
  SyntaxTreeNode tn;
  Token t;
  bpa("Identifier Declation");
    tn = Identifier();
                      addHeir( tn );
expecting = "( or ...";
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBR:
      t = jj_consume_token(LBR);
                 addHeir( new SyntaxTreeNode(mn, t) );
expecting = "_";
      t = jj_consume_token(US);
                addHeir( new SyntaxTreeNode(mn, t) );
expecting = "COMMA or )";
      label_11:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[29] = jj_gen;
          break label_11;
        }
        t = jj_consume_token(COMMA);
                     addHeir( new SyntaxTreeNode(mn, t) );
expecting = "_";
        t = jj_consume_token(US);
                  addHeir( new SyntaxTreeNode(mn, t) );
expecting = "COMMA or )";
      }
      t = jj_consume_token(RBR);
                 addHeir( new SyntaxTreeNode(mn, t) );
      break;
    default:
      jj_la1[30] = jj_gen;
      ;
    }
    SyntaxTreeNode sn[] = getLastHeirs();
    epa(); {if (true) return new SyntaxTreeNode( mn, N_IdentDecl, sn);}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode SomeFixDecl() throws ParseException {
  SyntaxTreeNode localASTN = null;
  SyntaxTreeNode tn;
  SyntaxTreeNode sn[] = null;
  int kind;
  Token t;
  UniqueString n;
  bpa("Op. Symbol Declaration");
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case op_76:
    case op_26:
    case op_29:
    case op_58:
    case CASESEP:
    case op_61:
    case op_112:
    case op_113:
    case op_114:
    case op_115:
    case op_116:
      // LOOKAHEAD( <OpSymbol>, { isPrefixDeclOp( getToken(1) )  } )
            tn = NonExpPrefixOp();
        kind = N_PrefixDecl; n = lastOp.getIdentifier();
        sn = new SyntaxTreeNode[2]; sn[0] = tn;
expecting = "_";
      t = jj_consume_token(US);
                  sn[1] = new SyntaxTreeNode(mn, t);
      break;
    case US:
      t = jj_consume_token(US);
expecting = "infix or postfix operator";
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case op_1:
      case AND:
      case op_3:
      case op_4:
      case OR:
      case op_6:
      case op_7:
      case op_8:
      case op_9:
      case op_10:
      case op_11:
      case op_12:
      case op_13:
      case op_14:
      case op_15:
      case op_16:
      case op_17:
      case op_18:
      case op_19:
      case IN:
      case op_21:
      case op_22:
      case op_23:
      case op_24:
      case op_25:
      case op_27:
      case op_30:
      case op_31:
      case op_32:
      case op_33:
      case op_34:
      case op_35:
      case op_36:
      case op_37:
      case op_38:
      case op_39:
      case op_40:
      case op_41:
      case op_42:
      case op_43:
      case op_44:
      case op_45:
      case op_46:
      case op_47:
      case op_48:
      case op_49:
      case op_50:
      case op_51:
      case op_52:
      case op_53:
      case op_54:
      case op_55:
      case op_56:
      case op_59:
      case op_62:
      case op_63:
      case op_64:
      case EQUALS:
      case op_66:
      case op_67:
      case op_71:
      case op_72:
      case op_73:
      case op_74:
      case op_75:
      case op_77:
      case op_78:
      case op_79:
      case op_80:
      case op_81:
      case op_82:
      case op_83:
      case op_84:
      case op_85:
      case op_86:
      case op_87:
      case op_88:
      case op_89:
      case op_90:
      case op_91:
      case op_92:
      case op_93:
      case op_94:
      case op_95:
      case op_96:
      case op_97:
      case op_98:
      case op_100:
      case op_101:
      case op_102:
      case op_103:
      case op_104:
      case op_105:
      case op_106:
      case op_107:
      case op_108:
      case op_109:
      case op_110:
      case op_111:
      case op_117:
      case op_118:
      case op_119:
        tn = InfixOp();
          kind = N_InfixDecl; n = lastOp.getIdentifier();
          sn = new SyntaxTreeNode[3]; sn[1] = tn;
          sn[0] =  new SyntaxTreeNode(mn, t);
expecting = "_";
        t = jj_consume_token(US);
                       sn[2] = new SyntaxTreeNode(mn, t);
        break;
      case op_57:
      case op_68:
      case op_69:
      case op_70:
        tn = PostfixOp();
          kind = N_PostfixDecl; n = lastOp.getIdentifier();
          sn = new SyntaxTreeNode[2]; sn[1] = tn;
          sn[0] =  new SyntaxTreeNode(mn, t);
        break;
      default:
        jj_la1[31] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[32] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    epa(); {if (true) return new SyntaxTreeNode(mn, kind, sn);}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode Instance() throws ParseException {
  SyntaxTreeNode tn;
  SyntaxTreeNode zn = null;
  Token t;
  bpa("Instance");
expecting = "LOCAL or instance";
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LOCAL:
      t = jj_consume_token(LOCAL);
    zn =  new SyntaxTreeNode(mn, t);
      break;
    default:
      jj_la1[33] = jj_gen;
      ;
    }
    tn = Instantiation();
                         addHeir( tn );
expecting = "COMMA or Module Body";
    SyntaxTreeNode sn[] = getLastHeirs();
    epa(); {if (true) return new SyntaxTreeNode( mn, N_Instance, zn, sn);}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode Instantiation() throws ParseException {
  SyntaxTreeNode tn;
  Token t;
  bpa("NonLocalInstance");
    t = jj_consume_token(INSTANCE);
                    addHeir( new SyntaxTreeNode(mn, t) );
expecting = "Module identifier";
  t = getToken(1);
  if (isFieldNameToken( t )) t.kind = IDENTIFIER;
    tn = Identifier();
                      addDependency( tn.image ); addHeir( tn );
expecting = "WITH or another definition.";
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WITH:
      t = jj_consume_token(WITH);
                  addHeir( new SyntaxTreeNode(mn, t) );
expecting = emptyString;
      tn = Substitution();
                          addHeir( tn );
expecting = emptyString;
      label_12:
      while (true) {
        if (jj_2_12(3)) {
          ;
        } else {
          break label_12;
        }
        t = jj_consume_token(COMMA);
                     addHeir( new SyntaxTreeNode(mn, t) );
expecting = emptyString;
        tn = Substitution();
                            addHeir( tn );
expecting = emptyString;
      }
      break;
    default:
      jj_la1[34] = jj_gen;
      ;
    }
    SyntaxTreeNode sn[] = getLastHeirs();
    epa(); {if (true) return new SyntaxTreeNode( mn, N_NonLocalInstance, sn);}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode Substitution() throws ParseException {
  SyntaxTreeNode zn[] = new SyntaxTreeNode[3];
  SyntaxTreeNode tn = null;
  Token t;
  anchor = null;
    /***********************************************************************
    * See the comments for the declaration of anchor to see what this is   *
    * being used for.                                                      *
    ***********************************************************************/
  String n;
  bpa("Substitution");
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      tn = Identifier();
                        zn[0] = tn;
      break;
    case op_76:
    case op_26:
    case op_29:
    case op_58:
    case CASESEP:
    case op_61:
    case op_112:
    case op_113:
    case op_114:
    case op_115:
    case op_116:
      tn = NonExpPrefixOp();
                            zn[0] = tn;
      break;
    case op_1:
    case AND:
    case op_3:
    case op_4:
    case OR:
    case op_6:
    case op_7:
    case op_8:
    case op_9:
    case op_10:
    case op_11:
    case op_12:
    case op_13:
    case op_14:
    case op_15:
    case op_16:
    case op_17:
    case op_18:
    case op_19:
    case IN:
    case op_21:
    case op_22:
    case op_23:
    case op_24:
    case op_25:
    case op_27:
    case op_30:
    case op_31:
    case op_32:
    case op_33:
    case op_34:
    case op_35:
    case op_36:
    case op_37:
    case op_38:
    case op_39:
    case op_40:
    case op_41:
    case op_42:
    case op_43:
    case op_44:
    case op_45:
    case op_46:
    case op_47:
    case op_48:
    case op_49:
    case op_50:
    case op_51:
    case op_52:
    case op_53:
    case op_54:
    case op_55:
    case op_56:
    case op_59:
    case op_62:
    case op_63:
    case op_64:
    case EQUALS:
    case op_66:
    case op_67:
    case op_71:
    case op_72:
    case op_73:
    case op_74:
    case op_75:
    case op_77:
    case op_78:
    case op_79:
    case op_80:
    case op_81:
    case op_82:
    case op_83:
    case op_84:
    case op_85:
    case op_86:
    case op_87:
    case op_88:
    case op_89:
    case op_90:
    case op_91:
    case op_92:
    case op_93:
    case op_94:
    case op_95:
    case op_96:
    case op_97:
    case op_98:
    case op_100:
    case op_101:
    case op_102:
    case op_103:
    case op_104:
    case op_105:
    case op_106:
    case op_107:
    case op_108:
    case op_109:
    case op_110:
    case op_111:
    case op_117:
    case op_118:
    case op_119:
      tn = InfixOp();
                     zn[0] = tn;
      break;
    case op_57:
    case op_68:
    case op_69:
    case op_70:
      tn = PostfixOp();
                       zn[0] = tn;
      break;
    default:
      jj_la1[35] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  expecting = "<-";
    t = jj_consume_token(SUBSTITUTE);
                     n = tn.getImage();
     zn[1] = new SyntaxTreeNode(mn, t);
expecting = "Expression or Op. Symbol";
    tn = OpOrExpr();
    epa(); zn[2] = tn; {if (true) return new SyntaxTreeNode(mn, N_Substitution, zn );}
    throw new Error("Missing return statement in function");
  }

/***************************************************************************
* Substitution ::=                                                         *
*     ( Identifier | NonExpPrefixOp | InfixOp | PostfixOp)                 *
*     <SUBSTITUTE> ( <op_76> | Lambda | Expression )                       *
*                                                                          *
* Note: <op_76> is "-.", the prefix - operator.                            *
*       <SUBSTITUTE> is "<-"                                               *
*                                                                          *
* Modified 27 March 2007 by LL to allow Lambda substitutions.              *
***************************************************************************/
  final public SyntaxTreeNode OldSubstitution() throws ParseException {
  SyntaxTreeNode zn[] = new SyntaxTreeNode[3];
  SyntaxTreeNode tn = null;
  Token t;
  anchor = null;
    /***********************************************************************
    * See the comments for the declaration of anchor to see what this is   *
    * being used for.                                                      *
    ***********************************************************************/
  String n;
  bpa("Substitution");
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      tn = Identifier();
                        zn[0] = tn;
      break;
    case op_76:
    case op_26:
    case op_29:
    case op_58:
    case CASESEP:
    case op_61:
    case op_112:
    case op_113:
    case op_114:
    case op_115:
    case op_116:
      tn = NonExpPrefixOp();
                            zn[0] = tn;
      break;
    case op_1:
    case AND:
    case op_3:
    case op_4:
    case OR:
    case op_6:
    case op_7:
    case op_8:
    case op_9:
    case op_10:
    case op_11:
    case op_12:
    case op_13:
    case op_14:
    case op_15:
    case op_16:
    case op_17:
    case op_18:
    case op_19:
    case IN:
    case op_21:
    case op_22:
    case op_23:
    case op_24:
    case op_25:
    case op_27:
    case op_30:
    case op_31:
    case op_32:
    case op_33:
    case op_34:
    case op_35:
    case op_36:
    case op_37:
    case op_38:
    case op_39:
    case op_40:
    case op_41:
    case op_42:
    case op_43:
    case op_44:
    case op_45:
    case op_46:
    case op_47:
    case op_48:
    case op_49:
    case op_50:
    case op_51:
    case op_52:
    case op_53:
    case op_54:
    case op_55:
    case op_56:
    case op_59:
    case op_62:
    case op_63:
    case op_64:
    case EQUALS:
    case op_66:
    case op_67:
    case op_71:
    case op_72:
    case op_73:
    case op_74:
    case op_75:
    case op_77:
    case op_78:
    case op_79:
    case op_80:
    case op_81:
    case op_82:
    case op_83:
    case op_84:
    case op_85:
    case op_86:
    case op_87:
    case op_88:
    case op_89:
    case op_90:
    case op_91:
    case op_92:
    case op_93:
    case op_94:
    case op_95:
    case op_96:
    case op_97:
    case op_98:
    case op_100:
    case op_101:
    case op_102:
    case op_103:
    case op_104:
    case op_105:
    case op_106:
    case op_107:
    case op_108:
    case op_109:
    case op_110:
    case op_111:
    case op_117:
    case op_118:
    case op_119:
      tn = InfixOp();
                     zn[0] = tn;
      break;
    case op_57:
    case op_68:
    case op_69:
    case op_70:
      tn = PostfixOp();
                       zn[0] = tn;
      break;
    default:
      jj_la1[36] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  expecting = "<-";
    t = jj_consume_token(SUBSTITUTE);
                     n = tn.getImage();
     zn[1] = new SyntaxTreeNode(mn, t);
expecting = "Expression or Op. Symbol";
    try {
      if (jj_2_13(2147483647)) {
        t = jj_consume_token(op_76);
      SyntaxTreeNode zzn[] = new SyntaxTreeNode[2];
      zzn[0] = new SyntaxTreeNode( mn, N_IdPrefix, new SyntaxTreeNode[0] );
      zzn[1] =  new SyntaxTreeNode( mn, N_NonExpPrefixOp, t );
      tn = new SyntaxTreeNode( mn, N_GenNonExpPrefixOp, zzn );
      } else if (jj_2_14(1)) {
        tn = Expression();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LAMBDA:
          tn = Lambda();
          break;
        default:
          jj_la1[37] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } catch (ParseException e) {
// first things first - restore evaluation stack
    if ( OperatorStack.isWellReduced() )
      OperatorStack.popStack();
    else
      {if (true) throw e;}
// check the nature of the node returned. It can only be a GenOp. */
// should be reviewed - N_GenNonExpPrefixOp may be unnecessary because -. has been checked.
    if ( ( anchor != null )
       &&( anchor.isKind( N_GenPrefixOp ) || anchor.isKind( N_GenInfixOp ) || anchor.isKind( N_GenPostfixOp ) || anchor.isKind( N_GenNonExpPrefixOp ) ) ) {
       tn = anchor; anchor = null;
    } else
       {if (true) throw e;}
    }
    epa(); zn[2] = tn; {if (true) return new SyntaxTreeNode(mn, N_Substitution, zn );}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode PrefixOp() throws ParseException {
  Token t;
    t = PrefixOpToken();
    lastOp = Operators.getOperator( UniqueString.uniqueStringOf(t.image) ); // YYY to revise
    {if (true) return new SyntaxTreeNode(mn, N_PrefixOp, t) ;}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode NonExpPrefixOp() throws ParseException {
  Token t;
    t = NEPrefixOpToken();
    lastOp = Operators.getOperator( UniqueString.uniqueStringOf(t.image) ); // YYY to revise
    {if (true) return new SyntaxTreeNode(mn, N_NonExpPrefixOp, t) ;}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode InfixOp() throws ParseException {
  Token t;
bpa("Infix Op") ;
    t = InfixOpToken();
    lastOp = Operators.getOperator( UniqueString.uniqueStringOf(t.image) ); // YYY to revise
epa();
    {if (true) return new SyntaxTreeNode( mn, N_InfixOp, t) ;}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode PostfixOp() throws ParseException {
  Token t;
    t = PostfixOpToken();
    lastOp = Operators.getOperator( UniqueString.uniqueStringOf(t.image) ); // YYY to revise
    {if (true) return new SyntaxTreeNode(mn, N_PostfixOp, t) ;}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode Identifier() throws ParseException {
  Token t;
    t = jj_consume_token(IDENTIFIER);
                     {if (true) return new SyntaxTreeNode(mn, t);}
    throw new Error("Missing return statement in function");
  }

/***************************************************************************
* Assumption ::= ( <ASSUME> | <ASSUMPTION> )                               *
*                  ( Identifier <DEF> )? Expression                        *
***************************************************************************/
  final public SyntaxTreeNode Assumption() throws ParseException {
  SyntaxTreeNode tn;
  SyntaxTreeNode zn = null;
  Token t;
  bpa("Assumption");
// expecting = "LOCAL or ASSUM...";
expecting = "ASSUM...";
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ASSUMPTION:
      t = jj_consume_token(ASSUMPTION);
      break;
    case ASSUME:
      t = jj_consume_token(ASSUME);
      break;
    default:
      jj_la1[38] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                                        addHeir( new SyntaxTreeNode(mn, t) );
    if (jj_2_15(2)) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DEFBREAK:
        t = jj_consume_token(DEFBREAK);
        break;
      default:
        jj_la1[39] = jj_gen;
        ;
      }
      /* A DEFBREAK might get added here by belchDEF */
          tn = Identifier();
                        addHeir( tn );
expecting = "==";
      t = jj_consume_token(DEF);
                       // belchDEF(); extra belchDEF removed 15 Mar 2007 by LL because it caused
                       // an extra <DEFBREAK> to be inserted, producing an error.
                       addHeir( new SyntaxTreeNode(mn, t) );
    } else {
      ;
    }
     belchDEF();
expecting = "Expression";
    tn = Expression();
    addHeir(tn);
    SyntaxTreeNode sn[] = getLastHeirs();
    epa(); {if (true) return new SyntaxTreeNode( mn, N_Assumption, zn, sn);}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode AssumeProve() throws ParseException {
  /*************************************************************************
  * AssumeProve ::= (<IDENTIFIER> <COLONCOLON>)?                           *
  *                 <ASSUME> (AssumeProve | NewDecl | Expression)          *
  *                  (<COMMA> (AssumeProve  | NewDecl | Expression))+      *
  *                 <PROVE> Expression                                     *
  *                                                                        *
  * For ASSUME A1, A2 PROVE B, it constructs an AssumeProve node tn with   *
  * tn.zero equal to the array containing the 6 elements                   *
  *                                                                        *
  *     "ASSUME"  A1  ","  A2  "PROVE"  B                                  *
  *                                                                        *
  * If there is a label "foo::", it returns an N_Label node.               *
  *                                                                        *
  * Changed 18 May 2008 by LL to allow a label.                            *
  *************************************************************************/
  SyntaxTreeNode tn;
  Token t;
  SyntaxTreeNode sn[] ;
  bpa("Assume-Prove");
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      tn = Identifier();
      /*********************************************************************
      * The semantic analyzer expects the label name to be a GeneralId     *
      * node whose first child is an empty N_IdPrefix node and whose       *
      * second child is the label's Identifier node.                       *
      *********************************************************************/
      addHeir(new SyntaxTreeNode(
                    mn,
                    N_GeneralId,
                    new SyntaxTreeNode[] {
                       new SyntaxTreeNode(
                             mn,
                             N_IdPrefix,
                             new SyntaxTreeNode[0]),
                       tn}
                      ) ) ;
      t = jj_consume_token(COLONCOLON);
                        addHeir( new SyntaxTreeNode(mn, t) );
      tn = AssumeProve();
                        addHeir(tn);
      sn = getLastHeirs();
      epa();
      {if (true) return new SyntaxTreeNode( mn, N_Label, sn);}
      break;
    default:
      jj_la1[40] = jj_gen;
      ;
    }
    t = jj_consume_token(ASSUME);
                  addHeir( new SyntaxTreeNode(mn, t) );
expecting = "Expression, Declaration, or AssumeProve";
    if ((getToken(1).kind == ASSUME)
                       || ((getToken(2).kind == COLONCOLON) &&
                           (getToken(3).kind == ASSUME)  )) {
      /*****************************************************
                            * Check for COLONCOLON added by LL 17 Feb 2009.      *
                            *****************************************************/
           tn = AssumeProve();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ACTION:
      case CONSTANT:
      case NEW:
      case STATE:
      case TEMPORAL:
      case VARIABLE:
        tn = NewSymb();
        break;
      default:
        jj_la1[41] = jj_gen;
        if (jj_2_16(1)) {
          tn = Expression();

        } else {
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
      addHeir(tn);
expecting = "PROVE or `,'";
    label_13:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[42] = jj_gen;
        break label_13;
      }
      t = jj_consume_token(COMMA);
                  addHeir( new SyntaxTreeNode(mn, t) );
expecting = "Expression, Declaration, or AssumeProve";
      if ((getToken(1).kind == ASSUME)
                         || ((getToken(2).kind == COLONCOLON) &&
                             (getToken(3).kind == ASSUME)  )) {
        /*****************************************************
                              * Check for COLONCOLON added by LL 17 Feb 2009.      *
                              *****************************************************/
               tn = AssumeProve();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ACTION:
        case CONSTANT:
        case NEW:
        case STATE:
        case TEMPORAL:
        case VARIABLE:
          tn = NewSymb();
          break;
        default:
          jj_la1[43] = jj_gen;
          if (jj_2_17(1)) {
            tn = Expression();
          } else {
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
      }
      addHeir(tn);
expecting = "PROVE or `,'";
    }
    t = jj_consume_token(PROVE);
                addHeir( new SyntaxTreeNode(mn, t) );
expecting = "Expression";
    tn = Expression();
                      addHeir( tn );
    sn = getLastHeirs();
    epa(); {if (true) return new SyntaxTreeNode( mn, N_AssumeProve, sn);}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode NewSymb() throws ParseException {
  /*************************************************************************
  * NewSymb ::=   (<NEW> | <CONSTANT> | <NEW> <CONSTANT>)                  *
  *               (Identifier <IN> Expression | IdentDecl | SomeFixDecl)   *
  *              | [<NEW>] <VARIABLE> Identifier                           *
  *              | [<NEW>] (<STATE> | <ACTION> | <TEMPORAL>)               *
  *                (IdentDecl | SomeFixDecl)                               *
  *************************************************************************/
  SyntaxTreeNode tn ;
  Token t ;
  boolean hasArgs ;
    /***********************************************************************
    * We want to allow "NEW Id \in S" but disallow "NEW Id(_) \in S".      *
    * For simplicity, the we do this by letting javacc accept either, but  *
    * set hasArgs to true in the latter case and report the error when we  *
    * detect the "\in".                                                    *
    ***********************************************************************/
  bpa( "NEW symbol declaration");
  expecting = "NEW, CONSTANT, VARIABLE, STATE, ACTION, or TEMPORAL";
    if (jj_2_20(2)) {
      if (jj_2_18(2)) {
        t = jj_consume_token(NEW);
                           addHeir( new SyntaxTreeNode(mn, t) );
        t = jj_consume_token(CONSTANT);
                           addHeir( new SyntaxTreeNode(mn, t) );
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case NEW:
          t = jj_consume_token(NEW);
                           addHeir( new SyntaxTreeNode(mn, t) );
          break;
        case CONSTANT:
          t = jj_consume_token(CONSTANT);
                           addHeir( new SyntaxTreeNode(mn, t) );
          break;
        default:
          jj_la1[44] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      expecting = "Constant declaration";
      if (jj_2_19(2)) {
        tn = IdentDecl();
                            hasArgs = tn.heirs().length > 1;
                            addHeir (tn) ;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IN:
          t = jj_consume_token(IN);
                      if (hasArgs) {
                        {if (true) throw new ParseException(
                          "declared symbol with arguments before \\in at "
                           + tn.getLocation().toString());}
                        } ;
                      addHeir(new SyntaxTreeNode(mn, t) );
                      expecting = "Expression";
          tn = Expression();
                               addHeir (tn) ;
          break;
        default:
          jj_la1[45] = jj_gen;
          ;
        }
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case US:
        case op_76:
        case op_26:
        case op_29:
        case op_58:
        case CASESEP:
        case op_61:
        case op_112:
        case op_113:
        case op_114:
        case op_115:
        case op_116:
          tn = SomeFixDecl();
                              addHeir (tn) ;
          break;
        default:
          jj_la1[46] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } else if (jj_2_21(2)) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NEW:
        t = jj_consume_token(NEW);
                   addHeir(new SyntaxTreeNode(mn, t) );
        break;
      default:
        jj_la1[47] = jj_gen;
        ;
      }
      t = jj_consume_token(VARIABLE);
                      addHeir(new SyntaxTreeNode(mn, t) );
                      expecting = "Identifier";
      tn = Identifier();
                         /**************************************************
                         * The semantic processor expects an N_IdentDecl   *
                         * node, and doesn't cope with a bare Identifier   *
                         * node.                                           *
                         **************************************************/
                         SyntaxTreeNode[] sn = new SyntaxTreeNode[1] ;
                         sn[0] = tn ;
                         addHeir(new SyntaxTreeNode( mn, N_IdentDecl, sn));
    } else if (jj_2_22(2)) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NEW:
        t = jj_consume_token(NEW);
                     addHeir(new SyntaxTreeNode(mn, t));
        break;
      default:
        jj_la1[48] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STATE:
        t = jj_consume_token(STATE);
        break;
      case ACTION:
        t = jj_consume_token(ACTION);
        break;
      case TEMPORAL:
        t = jj_consume_token(TEMPORAL);
        break;
      default:
        jj_la1[49] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
       addHeir( new SyntaxTreeNode(mn, t));
       expecting = "Declaration" ;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        tn = IdentDecl();
                           addHeir(tn);
        break;
      case US:
      case op_76:
      case op_26:
      case op_29:
      case op_58:
      case CASESEP:
      case op_61:
      case op_112:
      case op_113:
      case op_114:
      case op_115:
      case op_116:
        tn = SomeFixDecl();
                             addHeir(tn);
        break;
      default:
        jj_la1[50] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
    SyntaxTreeNode sn[] = getLastHeirs();
    epa(); {if (true) return new SyntaxTreeNode( mn, N_NewSymb, sn);}
    throw new Error("Missing return statement in function");
  }

// NumberedAssumeProve() commented out 5 Mar 2007 by LL
// number . sequence 
// SyntaxTreeNode
// NumberedAssumeProve () : {
//   SyntaxTreeNode tn;
//   Token t;
//   boolean b = false;
//   bpa("Numbered Assume-Prove");
// }{
//   [ LOOKAHEAD(2)
//     t = <NUMBER_LITERAL>  { addHeir( new SyntaxTreeNode(mn, t) );
// expecting = "."; }
//     t = <DOT> {
//       BStack.newReference(t.endColumn, ASSUME); b = true;
//       addHeir( new SyntaxTreeNode(mn, t) );
// expecting = "Assume-Prove, Assume-Decl or expression"; } ]
//   ( tn = AssumeProve()
//   | LOOKAHEAD( { IsNotExpression() } ) tn = AssumeDecl()
//   | tn = Expression() ) /* XXX parser confusion here !!! */
//   { if (b) BStack.popReference();
//     addHeir(tn);
//     SyntaxTreeNode sn[] = getLastHeirs();
//     epa(); return new SyntaxTreeNode( mn, N_NumberedAssumeProve, sn); }
// }

// AssumeDecl() commented out 27 March 2007; it seems to be left over
//   from the old proof grammar.
// SyntaxTreeNode
// AssumeDecl () : {
//   SyntaxTreeNode zn[] = null;
//   SyntaxTreeNode tn;
//   Token t;
//   bpa("Assume Decl.");
// }{
//   ( tn = VariableDeclaration() { zn = new SyntaxTreeNode[1]; zn[0] = tn; }
//   | ( tn = ParamDeclaration() {
//         zn = new SyntaxTreeNode[2]; zn[0] = tn;
// expecting = "optional \\in or ..."; }
//       zn[1] = MaybeBound() )
//   | LOOKAHEAD (2) tn = OperatorOrFunctionDefinition() { zn = new SyntaxTreeNode[1]; zn[0] = tn; }
//   | tn = Instance() { zn = new SyntaxTreeNode[1]; zn[0] = tn; } )
//   { epa();
//     return new SyntaxTreeNode( mn, N_AssumeDecl, zn );  }
// }
  final public SyntaxTreeNode MaybeBound() throws ParseException {
  SyntaxTreeNode zn[] = null;
  SyntaxTreeNode tn;
  Token t;
  bpa("Domain binding");
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IN:
      t = jj_consume_token(IN);
      zn    = new SyntaxTreeNode[2];
      zn[0] =  new SyntaxTreeNode(mn, t);
      zn[0].setKind(T_IN);
expecting = "Expression";
      zn[1] = Expression();
      break;
    default:
      jj_la1[51] = jj_gen;
      ;
    }
    epa(); {if (true) return new SyntaxTreeNode( mn, N_MaybeBound, zn);}
    throw new Error("Missing return statement in function");
  }

/***************************************************************************
* Theorem ::= ( <THEOREM> | <PROPOSITION> )                                *
*                ( Identifier <DEF> )? ( AssumeProve | Expression )        *
*                                                                          *
* Produces a Theorem node tn with tn.zero containing 2 or 4 nodes,         *
* depending on whether or not the "Identifier <DEF>" is present.           *
***************************************************************************/
  final public SyntaxTreeNode Theorem() throws ParseException {
  SyntaxTreeNode tn;
  Token t;
  bpa("Theorem");
expecting= "THEOREM, PROPOSITION";
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case THEOREM:
      t = jj_consume_token(THEOREM);
      break;
    case PROPOSITION:
      t = jj_consume_token(PROPOSITION);
      break;
    default:
      jj_la1[52] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                                          addHeir( new SyntaxTreeNode(mn, t) );
expecting = "Identifier, Assume-Prove or Expression";
    if (jj_2_23(2)) {
      tn = Identifier();
                        addHeir( tn );
expecting = "==";
      t = jj_consume_token(DEF);
                       // belchDEF(); extra belchDEF removed 15 Mar 2007 by LL because it caused
                       // an extra <DEFBREAK> to be inserted, producing an error.
                       addHeir( new SyntaxTreeNode(mn, t) );
    } else {
      ;
    }
    belchDEF();
    if (jj_2_24(3)) {
      if (getToken(1).kind == ASSUME) {

      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
      tn = AssumeProve();
    } else if (jj_2_25(1)) {
      tn = Expression();
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
    addHeir(tn);
    if (beginsProof(getToken(1))) {
      tn = Proof();
       addHeir(tn) ;
    } else {
      ;
    }
   SyntaxTreeNode sn[] = getLastHeirs();
    epa(); {if (true) return new SyntaxTreeNode( mn, N_Theorem, sn);}
    throw new Error("Missing return statement in function");
  }

/***************************************************************************
* The Grammar of Proofs                                                    *
*  XXXXXXX THIS IS OBSOLETE                                                *
* Proof ::= InnerProof                                                     *
*   // Proof checks that we're not inside a proof at the end.              *
*                                                                          *
* InnerProof ::=                                                           *
*      TerminalProof                                                       *
*    | (<PROOF>)?                                                          *
*      ( Step )* // Terminated by lookahead for "QED"                      *
*      QEDStep                                                             *
*                                                                          *
*   // Note: (InnerProof)? uses lookahead for beginsProof(...)             *
*                                                                          *
* TerminalProof ::=    <BY> ...                                            *
*                    | (<PROOF>)? OBVIOUS                                  *
* QEDStep ::= (<ProofStepLexeme> | <ProofStepDotLexeme> )?                 *
*             <QED> (InnerProof)?                                          *
*                                                                          *
* Step ::=   N_DefStep                                                     *
*          | N_UseOrHide                                                   *
*          | N_NonLocalInstance                                            *
*          | N_NumerableStep                                               *
*          | N_QEDStep                                                     *
*                                                                          *
* NumerableStep ==    ExprStep                                             *
*                   | NumberedStep                                         *
*                   | UnnumberedStep                                       *
*                                                                          *
* DefStep ::= (<DEFINE>)? OperatorOrFunctionDefinition                     *
*                                                                          *
* NumberedStep ::= (<ProofStepLexeme> | <ProofStepDotLexeme> )             *
*                  UnnumberedStep                                          *
*                                                                          *
* ExprStep ::= (   <PROVE>                                                 *
*                | <SUFFICES>                                              *
*                | (<ProofStepLexeme> | <ProofStepDotLexeme> )             *
*                  (<SUFFICES>)?                                           *
*              )                                                           *
*              Expression                                                  *
*                                                                          *
* UnnumberedStep ::=                                                       *
*     Have                                                                 *
*   | Take                                                                 *
*   | Witness                                                              *
*   | (  Pick                                                              *
*      | (<SUFFICES>)? (AssumeProve | <CASE> Expression)                   *
*     )                                                                    *
*     (InnerProof)?                                                        *
***************************************************************************/
  final public SyntaxTreeNode Proof() throws ParseException {
/***************************************************************************
* Returns an N_Proof or N_TerminalProof node.  The heirs of an N_Proof     *
* node consist of an option PROOF token followed by a seequence of         *
* N_ProofStep nodes.  The heirs of an N_ProofStep node are a StartStep()   *
* token, a statement body, and an optional proof.  A statement body is     *
* one of the following node kinds:                                         *
*                                                                          *
*   Have no proof:                                                         *
*     N_DefStep   N_UseOrHide   N_NonLocalInstance   N_HaveStep,           *
*     N_TakeStep  N_WitnessStep                                            *
*                                                                          *
*   Have a proof                                                           *
*     N_QEDStep  N_PickStep   N_CaseStep   N_AssertStep                    *
***************************************************************************/
  SyntaxTreeNode tn;
  Token t = null ;
  Token t0 = null;
  pushProofLevel() ;
  bpa("Proof");
    if ((getToken(1).kind == BY) || (getToken(2).kind == BY)) {
      tn = UseOrHideOrBy();
    } else if (jj_2_27(2)) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PROOF:
        t0 = jj_consume_token(PROOF);
        break;
      default:
        jj_la1[53] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OBVIOUS:
        t = jj_consume_token(OBVIOUS);
        break;
      case OMITTED:
        t = jj_consume_token(OMITTED);
        break;
      default:
        jj_la1[54] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
     SyntaxTreeNode sn[] ;
     if (t0 != null) {
       sn = new SyntaxTreeNode[2];
       sn[0] = new SyntaxTreeNode(mn, t0);
       sn[1] = new SyntaxTreeNode(mn, t);
      }
     else {
       sn = new SyntaxTreeNode[1];
       sn[0] = new SyntaxTreeNode(mn, t);
      };
     tn = new SyntaxTreeNode(mn, N_TerminalProof, sn );
    } else if (jj_2_28(1)) {
      if (jj_2_26(2)) {
        t = jj_consume_token(PROOF);
                  addHeir(new SyntaxTreeNode(mn, t));
      } else {
        ;
      }
      label_14:
      while (true) {
        if (getToken(2).kind != QED) {
          ;
        } else {
          break label_14;
        }
        tn = Step();
                   addHeir(tn);
                   expecting = "a proof step";
      }
      tn = QEDStep();
     addHeir(tn);
     SyntaxTreeNode sn[] = getLastHeirs();
     tn = new SyntaxTreeNode(mn, N_Proof, sn );
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
   epa();
   popProofLevel() ;
   {if (true) return tn ;}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode UseOrHideOrBy() throws ParseException {
/***************************************************************************
* Returns an N_TerminalProof (for a BY) or N_UseOrHide node.  Having       *
* one nonterminal that returns both is the only easy way I know to         *
* avoid having to duplicate the code for handling BY and for handling      *
* USE/HIDE.  Lookahead should prevent it from being called to parse        *
* the wrong kind of object.                                                *
*                                                                          *
* Note: This production accepts a By, USE, or HIDE with no items.  This    *
* should be reported by an error in the semantic analysis phase.           *
***************************************************************************/
  SyntaxTreeNode tn;
  Token t;
  int kind = N_UseOrHide;
  bpa("UseOrHideOrBy");
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BY:
    case PROOF:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PROOF:
        t = jj_consume_token(PROOF);
                    addHeir(new SyntaxTreeNode(mn, t));
        break;
      default:
        jj_la1[55] = jj_gen;
        ;
      }
      t = jj_consume_token(BY);
                 kind = N_TerminalProof;
        addHeir(new SyntaxTreeNode(mn, t));
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ONLY:
        t = jj_consume_token(ONLY);
                   addHeir(new SyntaxTreeNode(mn, t));
        break;
      default:
        jj_la1[56] = jj_gen;
        ;
      }
      break;
    case USE:
      t = jj_consume_token(USE);
       addHeir(new SyntaxTreeNode(mn, t));
      break;
    case HIDE:
      t = jj_consume_token(HIDE);
       addHeir(new SyntaxTreeNode(mn, t));
      break;
    default:
      jj_la1[57] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     expecting = "an expression, `MODULE' or `DEF'";
    if (jj_2_31(1)) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MODULE:
        t = jj_consume_token(MODULE);
                             addHeir( new SyntaxTreeNode(mn, t) );
                             expecting = "identifier";
        tn = Identifier();
                             addHeir(tn);
        break;
      default:
        jj_la1[58] = jj_gen;
        if (jj_2_29(1)) {
          tn = Expression();
                            addHeir(tn);
        } else {
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      label_15:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[59] = jj_gen;
          break label_15;
        }
        t = jj_consume_token(COMMA);
                     addHeir( new SyntaxTreeNode(mn, t) );
                     expecting = "MODULE or expression";
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case MODULE:
          t = jj_consume_token(MODULE);
                               addHeir( new SyntaxTreeNode(mn, t) );
                               expecting = "identifier";
          tn = Identifier();
                               addHeir(tn);
          break;
        default:
          jj_la1[60] = jj_gen;
          if (jj_2_30(1)) {
            tn = Expression();
                              addHeir(tn);
          } else {
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
         if (kind == N_TerminalProof) { expecting = "comma, DEF, or [.]"; }
         else {expecting = "comma, DEF, or proof step";};
      }
    } else {
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DF:
      t = jj_consume_token(DF);
                addHeir( new SyntaxTreeNode(mn, t) );
                expecting = "MODULE or expression";
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MODULE:
        t = jj_consume_token(MODULE);
                             addHeir( new SyntaxTreeNode(mn, t) );
                               expecting = "identifier";
        tn = Identifier();
                             addHeir(tn);
        break;
      default:
        jj_la1[61] = jj_gen;
        if (jj_2_32(1)) {
          tn = Expression();
                            addHeir(tn);
        } else {
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      label_16:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[62] = jj_gen;
          break label_16;
        }
        t = jj_consume_token(COMMA);
                     addHeir( new SyntaxTreeNode(mn, t) );
                     expecting = "MODULE or expression";
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case MODULE:
          t = jj_consume_token(MODULE);
                               addHeir( new SyntaxTreeNode(mn, t) );
                               expecting = "identifier";
          tn = Identifier();
                               addHeir(tn);
          break;
        default:
          jj_la1[63] = jj_gen;
          if (jj_2_33(1)) {
            tn = Expression();
                              addHeir(tn);
          } else {
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
          if (kind == N_TerminalProof) { expecting = "comma or [.]"; }
         else {expecting = "comma or proof step" ; };
      }
      break;
    default:
      jj_la1[64] = jj_gen;
      ;
    }
    if (kind == N_TerminalProof) {expecting = "[.]";};
    SyntaxTreeNode sn[] = getLastHeirs();
    epa();
    {if (true) return new SyntaxTreeNode(mn, kind, sn );}
    throw new Error("Missing return statement in function");
  }

  final public Token StepStartToken() throws ParseException {
 Token t ;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ProofStepLexeme:
      t = jj_consume_token(ProofStepLexeme);
      break;
    case ProofImplicitStepLexeme:
      t = jj_consume_token(ProofImplicitStepLexeme);
      break;
    case ProofStepDotLexeme:
      t = jj_consume_token(ProofStepDotLexeme);
      break;
    case BareLevelLexeme:
      t = jj_consume_token(BareLevelLexeme);
      break;
    case UnnumberedStepLexeme:
      t = jj_consume_token(UnnumberedStepLexeme);
      break;
    default:
      jj_la1[65] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return t ;}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode QEDStep() throws ParseException {
/***************************************************************************
* Returns an N_ProofStep node whose body is an N_QEDStep node.             *
***************************************************************************/
 Token t ;
 SyntaxTreeNode tn;
 SyntaxTreeNode[] sn;
 int level = -1 ;
 bpa("QED step") ;
 expecting = "Step number" ;
    t = StepStartToken();
      tn = new SyntaxTreeNode(mn, t) ;
      if (!correctLevel(t)) {
         {if (true) throw new ParseException(tn.getLocation().toString() +
             ": QED step's number has bad level." );}
       };
      if (   (t.kind == ProofImplicitStepLexeme)
          || (t.kind == ProofStepLexeme)
          || (t.kind == ProofStepDotLexeme)) {
        tn.originalImage = tn.image ;
        tn.image = correctedStepNum(t) ;
// ToolIO.out.println("correcting " + tn.originalImage) ;
       } ;
// ToolIO.out.println("xyz: t.image = " + t.image + ", correctedImage = " 
// + tn.image + ", t.kind = " + t.kind ) ;

      addHeir(tn) ;
      expecting = "QED" ;
    t = jj_consume_token(QED);
        sn = new SyntaxTreeNode[1] ;
        sn[0] = new SyntaxTreeNode(mn, t) ;
        addHeir(new SyntaxTreeNode(mn, N_QEDStep, sn));
    if (beginsProof(getToken(1))) {
      tn = Proof();
       addHeir(tn) ;
    } else {
      ;
    }
     sn = getLastHeirs();
     epa();
     {if (true) return new SyntaxTreeNode(mn, N_ProofStep, sn);}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode Step() throws ParseException {
/***************************************************************************
* Returns an N_ProofStep node with the following heirs:                    *
*                                                                          *
*  - A StepStart() token.                                                  *
*                                                                          *
*  - An N_DefStep (for an operator or function def or named                *
*    instantiation, N_UseOrHide, N_NonLocalInstance, N_HaveStep,           *
*    N_TakeStep, N_WitnessStep, N_PickStep, N_CaseStep, or                 *
*    N_AssertStep node.  (An N_AssertStep node has an optional             *
*    "SUFFICES" followed by an expression or N_AssumeProve node.)          *
*                                                                          *
*  - An optional N_Proof or N_TerminalProof node.                          *
*                                                                          *
* Note: The grammar accepts a USE or HIDE with no items.  This should      *
* be reported as an error in the semantic analysis phase.                  *
***************************************************************************/
 Token t = null;
 SyntaxTreeNode tn = null;
 boolean mayHaveProof = false ;
 bpa("Step") ;
 expecting = "Step number" ;
    t = StepStartToken();
      tn = new SyntaxTreeNode(mn, t);
      if (!correctLevel(t)) {
         {if (true) throw new ParseException(tn.getLocation().toString() +
             ": step's number has bad level." );}
        };
      if (   (t.kind == ProofImplicitStepLexeme)
          || (t.kind == ProofStepLexeme)
          || (t.kind == ProofStepDotLexeme)) {
        tn.originalImage = tn.image ;
        tn.image = correctedStepNum(t) ;
       } ;
// ToolIO.out.println("xyz2: t.image = " + t.image + ", correctedImage = " 
// + tn.image + ", t.kind = " + t.kind ) ;
      addHeir(tn) ;
      expecting = "proof step";
    if ((getToken(1).kind == USE) || (getToken(1).kind == HIDE)) {
      tn = UseOrHideOrBy();
                            addHeir(tn) ;
    } else if (getToken(1).kind == INSTANCE) {
      tn = Instantiation();
                            addHeir(tn) ;
    } else if ((getToken(1).kind == DEFBREAK)
                       || (getToken(1).kind == DEFINE)) {
      tn = DefStep();
                           addHeir(tn) ;
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case HAVE:
        tn = HaveStep();
                           addHeir(tn) ;
        break;
      case TAKE:
        tn = TakeStep();
                           addHeir(tn) ;
        break;
      case WITNESS:
        tn = WitnessStep();
                           addHeir(tn) ;
        break;
      case PICK:
        tn = PickStep();
                           addHeir(tn) ;  mayHaveProof = true;
        break;
      case CASE:
        tn = CaseStep();
                           addHeir(tn) ;  mayHaveProof = true;
        break;
      default:
        jj_la1[66] = jj_gen;
        if (jj_2_34(1)) {
          tn = AssertStep();
                           addHeir(tn) ; mayHaveProof = true;
        } else {
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
    if (beginsProof(getToken(1))) {
      if (! mayHaveProof) {
         {if (true) throw new ParseException(tn.getLocation().toString() +
             ": proof of step that does not take a proof." );}
        } ;
      tn = Proof();
                    addHeir(tn) ;
    } else {
      ;
    }
    SyntaxTreeNode sn[] = getLastHeirs();
     epa();
     {if (true) return new SyntaxTreeNode(mn, N_ProofStep, sn);}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode DefStep() throws ParseException {
/***************************************************************************
* Returns an N_DefStep node whose heirs begin with an optional <DEFINE>    *
* followed by a non-empty sequence of nodes returned by                    *
* OperatorOrFunctionDefinition().                                          *
***************************************************************************/
 Token t = null;
 SyntaxTreeNode tn = null;
 bpa("DefStep") ;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DEFINE:
      t = jj_consume_token(DEFINE);
                    addHeir(new SyntaxTreeNode(mn, t));
      break;
    default:
      jj_la1[67] = jj_gen;
      ;
    }
    label_17:
    while (true) {
      tn = OperatorOrFunctionDefinition();
                                           addHeir(tn) ;
      if (jj_2_35(2)) {
        ;
      } else {
        break label_17;
      }
    }
     SyntaxTreeNode sn[] = getLastHeirs();
     epa();
     {if (true) return new SyntaxTreeNode(mn, N_DefStep, sn );}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode HaveStep() throws ParseException {
/***************************************************************************
* Returns an N_HaveStep node whose heirs are a <HAVE> token and an         *
* expression node.                                                         *
***************************************************************************/
 Token t = null;
 SyntaxTreeNode tn = null;
 bpa("HaveStep") ;
    t = jj_consume_token(HAVE);
                 addHeir(new SyntaxTreeNode(mn, t));
                  expecting = "expression";
    tn = Expression();
      addHeir(tn) ;
      SyntaxTreeNode sn[] = getLastHeirs();
      epa();
      {if (true) return new SyntaxTreeNode(mn, N_HaveStep, sn );}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode TakeStep() throws ParseException {
/***************************************************************************
* Returns an N_TakeStep node whose first heir is a <TAKE> token and whose  *
* remaining heirs are a sequence of QuantBound() nodes or a sequence of    *
* identifiers.                                                             *
***************************************************************************/
 Token t = null;
 SyntaxTreeNode tn = null;
 bpa("TakeStep") ;
    t = jj_consume_token(TAKE);
                addHeir(new SyntaxTreeNode(mn, t)) ;
                   expecting = "identifier";
    if (jj_2_36(2147483647)) {
      tn = QuantBound();
                         addHeir(tn) ;
                         expecting = "comma or step";
      label_18:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[68] = jj_gen;
          break label_18;
        }
        t = jj_consume_token(COMMA);
                     addHeir( new SyntaxTreeNode(mn, t) );
                     expecting = "identifier or tuple of identifiers";
        tn = QuantBound();
                           addHeir(tn) ;
                           expecting = "comma or proof step";
      }
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        tn = Identifier();
                         addHeir(tn) ;
                         expecting = "comma or proof step";
        label_19:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            jj_la1[69] = jj_gen;
            break label_19;
          }
          t = jj_consume_token(COMMA);
                     addHeir( new SyntaxTreeNode(mn, t) );
                     expecting = "identifier";
          tn = Identifier();
                           addHeir(tn) ;
                           expecting = "comma or proof step";
        }
        break;
      default:
        jj_la1[70] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
      SyntaxTreeNode sn[] = getLastHeirs();
      epa();
      {if (true) return new SyntaxTreeNode(mn, N_TakeStep, sn );}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode WitnessStep() throws ParseException {
/***************************************************************************
* Returns an N_WitnessStep node whose heirs are a <WITNESS> token and a    *
* sequence of expression nodes.  It's up to later processing to decide if  *
* those expressions have the form <<expr, ...  , expr>> \in expr,          *
* expr \in expr, or just expr.                                             *
***************************************************************************/
 Token t = null;
 SyntaxTreeNode tn = null;
 bpa("WitnessStep") ;
    t = jj_consume_token(WITNESS);
                    addHeir(new SyntaxTreeNode(mn, t));
                   expecting = "expression";
    tn = Expression();
                        addHeir(tn) ;
    label_20:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[71] = jj_gen;
        break label_20;
      }
      t = jj_consume_token(COMMA);
                      addHeir( new SyntaxTreeNode(mn, t) );
                        expecting = "expression";
      tn = Expression();
                            addHeir(tn) ;
                            expecting = "comma or colon";
    }
      SyntaxTreeNode sn[] = getLastHeirs();
      epa();
      {if (true) return new SyntaxTreeNode(mn, N_WitnessStep, sn );}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode PickStep() throws ParseException {
/***************************************************************************
* Returns an N_PickStep node whose heirs are a <PICK> token and an         *
* expression node.                                                         *
***************************************************************************/
 Token t = null;
 SyntaxTreeNode tn = null;
 bpa("PickStep") ;
    t = jj_consume_token(PICK);
                 addHeir(new SyntaxTreeNode(mn, t)) ;
                 expecting = "identifier";
    if (jj_2_37(2147483647)) {
      /* CommaList Identifier */
            tn = Identifier();
                          addHeir(tn) ;
                          expecting = "comma, or colon";
      label_21:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[72] = jj_gen;
          break label_21;
        }
        t = jj_consume_token(COMMA);
                      addHeir( new SyntaxTreeNode(mn, t) );
                      expecting = "identifier";
        tn = Identifier();
                            addHeir(tn) ;
                            expecting = "comma or colon";
      }
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LAB:
      case IDENTIFIER:
        tn = QuantBound();
                          addHeir(tn) ;
                          expecting = "comma or colon";
        label_22:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            jj_la1[73] = jj_gen;
            break label_22;
          }
          t = jj_consume_token(COMMA);
                      addHeir( new SyntaxTreeNode(mn, t) );
                      expecting = "identifier or tuple of identifiers";
          tn = QuantBound();
                            addHeir(tn) ;
                            expecting = "comma or colon";
        }
        break;
      default:
        jj_la1[74] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    t = jj_consume_token(COLON);
                  addHeir( new SyntaxTreeNode(mn, t) );
                  expecting = "expression";
    tn = Expression();
                        addHeir(tn) ;
      SyntaxTreeNode sn[] = getLastHeirs();
      epa();
      {if (true) return new SyntaxTreeNode(mn, N_PickStep, sn );}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode CaseStep() throws ParseException {
/***************************************************************************
* Returns an N_CaseStep node whose heirs are a <CASE> token and an         *
* expression node.                                                         *
***************************************************************************/
 Token t = null;
 SyntaxTreeNode tn = null;
 bpa("CaseStep") ;
    t = jj_consume_token(CASE);
                addHeir(new SyntaxTreeNode(mn, t));
                  expecting = "expression";
    tn = Expression();
      addHeir(tn) ;
      SyntaxTreeNode sn[] = getLastHeirs();
      epa();
      {if (true) return new SyntaxTreeNode(mn, N_CaseStep, sn );}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode AssertStep() throws ParseException {
/***************************************************************************
* Returns an N_AssertStep node whose heirs are an optional <SUFFICES>      *
* token and an expression or N_AssumeProve node.                           *
***************************************************************************/
 Token t = null;
 SyntaxTreeNode tn = null;
 bpa("AssertStep") ;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SUFFICES:
      t = jj_consume_token(SUFFICES);
                     addHeir(new SyntaxTreeNode(mn, t));
                    expecting = "expression or ASSUME/PROVE";
      break;
    default:
      jj_la1[75] = jj_gen;
      ;
    }
    if (jj_2_38(1)) {
      tn = Expression();
    } else if (getToken(1).kind == ASSUME) {
      tn = AssumeProve();
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
      addHeir(tn) ;
      SyntaxTreeNode sn[] = getLastHeirs();
      epa();
      {if (true) return new SyntaxTreeNode(mn, N_AssertStep, sn );}
    throw new Error("Missing return statement in function");
  }

// SyntaxTreeNode
// NumerableStep() : {
// /***************************************************************************
// * Returns an N_NumerableStep node, which has the syntax                    *
// *                                                                          *
// *  ( <ProofStep[Dot]Lexeme> (N_NonExprBody node)                           *
// *   | N_NonExprBody node )                                                 *
// *  ( N_Proof node | N_TerminalProof node)?                                 *
// ***************************************************************************/
//  Token t = null;
//  SyntaxTreeNode tn = null;
//  boolean mayHaveProof = true ;
//  bpa("NumerableStep") ;
//  }{( LOOKAHEAD(2)
//      (t = <ProofStepLexeme> | t = <ProofStepDotLexeme>)
//      { tn = new SyntaxTreeNode(mn, t) ;
//        addHeir(tn); 
//        if ((proofDepth > 0) && (proofLevelStack[proofDepth-1] == -1)){
//          throw new ParseException(tn.getLocation() + 
//                     ": numbered step inside unnumbered proof.");
//         } ;
//        if (!correctLevel(t)) {
//          throw new ParseException(tn.getLocation() + 
//                     ": step number has incorrect level.");
//         } ;
//       }
//      ( (t = <CASE> {addHeir(new SyntaxTreeNode(mn, t)); })?          // XXXX
// //     ^^^^^^^^^^^
// // javacc generates the following warning here:
// //   Choice conflict in [...] construct at line 2700, column 8.
// //   Expansion nested within construct and expansion following construct
// //   have common prefixes, one of which is: "CASE"
// //   Consider using a lookahead of 2 or more for nested expansion.
// //
// // This conflict is between "<1>2.  CASE expr" and 
// // "<1>2.  CASE p -> ...".  This is an inherent ambiguity that arises
// // from the use of "CASE" as a keyword here.  Javacc resolves
// // conflicts by choosing the first successful match.  Here, this
// // means that "<1>2.  CASE p -> ..." is parsed as
// //
// //      <ProofStepDotLexeme> <CASE> Expression()
// //
// // causing an error when it tries to parse "-> ..." as an expression.
// 
// 
// 
//        tn = Expression() {addHeir(tn);                               // XXXX
//                           mayHaveProof = true ;}   // XXXX
//       |                                                              // XXXX
//         tn = NonExprBody() {addHeir(tn);
//                             mayHaveProof = nonExprBodyMayHaveProof;}
//       )                                                              // XXXX
//    | t = <CASE> {addHeir(new SyntaxTreeNode(mn, t)); }             // XXXX
//      tn = Expression() {addHeir(tn);                               // XXXX
//                         mayHaveProof = nonExprBodyMayHaveProof;} // XXXX
// 
//    | tn = NonExprBody() 
//        { addHeir(tn); 
//          mayHaveProof = nonExprBodyMayHaveProof;
//          if (getProofLevel() == -2)
//            { setProofLevel(-1) ;
//           }
//          else {
//           if (getProofLevel() != -1) {
//          throw new ParseException(tn.getLocation() + 
//                     ": Unnumbered step in numbered proof.");
//             }
//           }
//       }
//   )
//   ( LOOKAHEAD( {mayHaveProof && beginsProof(getToken(1))} )
//      tn = Proof() 
//      { addHeir(tn) ; }
//   )?
//   { SyntaxTreeNode sn[] = getLastHeirs();
//     epa(); 
//     return new SyntaxTreeNode(mn, N_NumerableStep, sn);
//   }
// }

// /***************************************************************************
// * Hack: In addition to returning a node, NonExprBody() needs to return a   *
// * boolean saying whether or not the statement it is returning can have a   *
// * proof.  It does this by setting the field nonExprBodyMayHaveProof.       *
// ***************************************************************************/
// SyntaxTreeNode
// NonExprBody() : {
//  SyntaxTreeNode tn = null;
//  Token t = null;
//  nonExprBodyMayHaveProof = false ;
//  bpa("NonExprBody") ;
// }{ (  LOOKAHEAD(2)
//       (t = <SUFFICES>    { addHeir(new SyntaxTreeNode(mn, t)); }) ? 
//       tn = AssumeProve() { addHeir(tn) ; 
//                            nonExprBodyMayHaveProof = true;}
//     | LOOKAHEAD(2)
//       ( t = <PROVE> | t = <SUFFICES>)   // | t = <PROOFCASE>
//       { addHeir(new SyntaxTreeNode(mn, t));  
//         expecting = "expression";}
//       tn = Expression() { addHeir(tn) ; 
//                           nonExprBodyMayHaveProof = true;}
//     | t = <HAVE> { addHeir(new SyntaxTreeNode(mn, t)) ;   
//                    expecting = "expression";}
//       tn = Expression() { addHeir(tn) ; }
//     | t = <TAKE> { addHeir(new SyntaxTreeNode(mn, t)) ;    
//                    expecting = "identifier";}
//       ( LOOKAHEAD (  <IDENTIFIER> (<COMMA> <IDENTIFIER>)* <IN>
//                    | <LAB>) 
//         tn = QuantBound() { addHeir(tn) ;  
//                             expecting = "comma or step";}
//         ( t = <COMMA> { addHeir( new SyntaxTreeNode(mn, t) ); 
//                         expecting = "identifier or tuple of identifiers";}
//           tn = QuantBound() { addHeir(tn) ;  
//                               expecting = "comma or proof step";}
//         )*
//       |  
//         tn = Identifier() { addHeir(tn) ; 
//                              expecting = "comma or proof step";}
//          ( t = <COMMA> { addHeir( new SyntaxTreeNode(mn, t) ); 
//                           expecting = "identifier";}
//            tn = Identifier() { addHeir(tn) ;  
//                                expecting = "comma or proof step";}
//          )*
//       )
// 
//     | t = <WITNESS> { addHeir(new SyntaxTreeNode(mn, t)) ;     
//                       expecting = "expression";}
//       tn = Expression() { addHeir(tn) ; }
//       /*********************************************************************
//       * Note: The semantic phase must determine if this is expr \in expr,  *
//       * or <<expr, ...  , expr>> \in expr, or just expr.                   *
//       *********************************************************************/
//       ( t = <COMMA> { addHeir( new SyntaxTreeNode(mn, t) ); 
//                         expecting = "expression";}
//         tn = Expression() { addHeir(tn) ;  
//                             expecting = "comma or colon";}
//       )*
//       
//     | t = <PICK> { addHeir(new SyntaxTreeNode(mn, t)) ;  
//                    expecting = "identifier";}
//       ( LOOKAHEAD ( <IDENTIFIER> ( <COMMA> <IDENTIFIER> )* <COLON> ) 
//                           /* CommaList Identifier */
//         tn = Identifier() { addHeir(tn) ; 
//                              expecting = "comma, or colon";}
//          ( t = <COMMA> { addHeir( new SyntaxTreeNode(mn, t) ); 
//                           expecting = "identifier";}
//            tn = Identifier() { addHeir(tn) ;  
//                                expecting = "comma or colon";}
//          )*
//       |  
//         tn = QuantBound() { addHeir(tn) ;  
//                             expecting = "comma or colon";}
//         ( t = <COMMA> { addHeir( new SyntaxTreeNode(mn, t) ); 
//                         expecting = "identifier or tuple of identifiers";}
//           tn = QuantBound() { addHeir(tn) ;  
//                               expecting = "comma or colon";}
//         )*
//        )
//        t = <COLON> { addHeir( new SyntaxTreeNode(mn, t) );  
//                      expecting = "expression";}
//        tn = Expression() { addHeir(tn) ; }
//        { nonExprBodyMayHaveProof = true;}
//    )
//   { SyntaxTreeNode sn[] = getLastHeirs();
//     epa(); 
//     return new SyntaxTreeNode(mn, N_NonExprBody, sn);
//   }
// }



/***************************************************************************
* The GeneralId() production is not used and can be deleted.  The parser   *
* uses Java code to construct N_GeneralId nodes inside Extension(),        *
* NoOpExtension(), and BraceCases()                                        *
***************************************************************************/
  final public SyntaxTreeNode GeneralId() throws ParseException {
  SyntaxTreeNode zn[] = new SyntaxTreeNode[2];
  Token t;
  bpa("General ID");
    zn[0] = IdPrefix();
    zn[1] = Identifier();
    epa(); {if (true) return new SyntaxTreeNode( mn, N_GeneralId, zn);}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode IdPrefix() throws ParseException {
  SyntaxTreeNode tn;
  bpa("ID Prefix");
    label_23:
    while (true) {
      if (jj_2_39(2147483647)) {
        ;
      } else {
        break label_23;
      }
      tn = IdPrefixElement();
                            addHeir( tn );
    }
    SyntaxTreeNode sn[] = getLastHeirs();
    epa(); {if (true) return new SyntaxTreeNode(mn, N_Proof, sn );}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode IdPrefixElement() throws ParseException {
  SyntaxTreeNode tn;
  Token t;
  bpa("ID Prefix Element");
    tn = Identifier();
                      addHeir( tn );
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBR:
      tn = OpArgs();
                   addHeir( tn );
      break;
    default:
      jj_la1[76] = jj_gen;
      ;
    }
    t = jj_consume_token(BANG);
               addHeir( new SyntaxTreeNode(mn, t) );
    SyntaxTreeNode sn[] = getLastHeirs();
    epa(); {if (true) return  new SyntaxTreeNode(mn, N_IdPrefixElement, sn);}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode ParenthesesExpression() throws ParseException {
  SyntaxTreeNode tn;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBR:
      tn = ParenExpr();
      break;
    case LBC:
      tn = BraceCases();
      break;
    case LSB:
      tn = SBracketCases();
      break;
    case LWB:
      tn = SetExcept();
      break;
    case LAB:
      tn = TupleOrAction();
      break;
    case SF:
    case WF:
      tn = FairnessExpr();
      break;
    default:
      jj_la1[77] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return tn;}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode ClosedExpressionOrOp() throws ParseException {
  SyntaxTreeNode tn;
  Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NUMBER_LITERAL:
    case STRING_LITERAL:
    case op_57:
    case op_68:
    case op_69:
    case op_70:
    case op_26:
    case op_29:
    case op_58:
    case CASESEP:
    case op_61:
    case op_112:
    case op_113:
    case op_114:
    case op_115:
    case op_116:
    case op_1:
    case AND:
    case op_3:
    case op_4:
    case OR:
    case op_6:
    case op_7:
    case op_8:
    case op_9:
    case op_10:
    case op_11:
    case op_12:
    case op_13:
    case op_14:
    case op_15:
    case op_16:
    case op_17:
    case op_18:
    case op_19:
    case IN:
    case op_21:
    case op_22:
    case op_23:
    case op_24:
    case op_25:
    case op_27:
    case op_30:
    case op_31:
    case op_32:
    case op_33:
    case op_34:
    case op_35:
    case op_36:
    case op_37:
    case op_38:
    case op_39:
    case op_40:
    case op_41:
    case op_42:
    case op_43:
    case op_44:
    case op_45:
    case op_46:
    case op_47:
    case op_48:
    case op_49:
    case op_50:
    case op_51:
    case op_52:
    case op_53:
    case op_54:
    case op_55:
    case op_56:
    case op_59:
    case op_62:
    case op_63:
    case op_64:
    case EQUALS:
    case op_66:
    case op_67:
    case op_71:
    case op_72:
    case op_73:
    case op_74:
    case op_75:
    case op_77:
    case op_78:
    case op_79:
    case op_80:
    case op_81:
    case op_82:
    case op_83:
    case op_84:
    case op_85:
    case op_86:
    case op_87:
    case op_88:
    case op_89:
    case op_90:
    case op_91:
    case op_92:
    case op_93:
    case op_94:
    case op_95:
    case op_96:
    case op_97:
    case op_98:
    case op_100:
    case op_101:
    case op_102:
    case op_103:
    case op_104:
    case op_105:
    case op_106:
    case op_107:
    case op_108:
    case op_109:
    case op_110:
    case op_111:
    case op_117:
    case op_118:
    case op_119:
    case IDENTIFIER:
      tn = ElementaryExpression();
      break;
    case SF:
    case WF:
    case LBR:
    case LSB:
    case LWB:
    case LBC:
    case LAB:
      tn = ParenthesesExpression();
      break;
    default:
      jj_la1[78] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return tn;}
    throw new Error("Missing return statement in function");
  }

/***************************************************************************
* The following does not seem to be used anywhere.                         *
***************************************************************************/
  final public SyntaxTreeNode ClosedExpressionOnly() throws ParseException {
  SyntaxTreeNode tn;
    tn = ClosedExpressionOrOp();
    if ( isGenOp( tn ) ) {if (true) throw new ParseException( "Encountered unexpected Operator" );}
    else {if (true) return tn;}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode OpenExpression() throws ParseException {
  SyntaxTreeNode tn;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EXISTS:
    case FORALL:
      tn = SomeQuant();
      break;
    case T_EXISTS:
    case T_FORALL:
      tn = SomeTQuant();
      break;
    case IF:
      tn = IfThenElse();
      break;
    case CASE:
      tn = Case();
      break;
    case LET:
      tn = LetIn();
      break;
    case CHOOSE:
      tn = UnboundOrBoundChoose();
      break;
    default:
      jj_la1[79] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return tn;}
    throw new Error("Missing return statement in function");
  }

/*
  L.GeneralId, L.OpApplication, L.String, L.Number, L.GenOp...
*/
  final public SyntaxTreeNode ElementaryExpression() throws ParseException {
  SyntaxTreeNode tn;
  Token t;
  bpa("Elementary expression");
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case op_57:
    case op_68:
    case op_69:
    case op_70:
    case op_26:
    case op_29:
    case op_58:
    case CASESEP:
    case op_61:
    case op_112:
    case op_113:
    case op_114:
    case op_115:
    case op_116:
    case op_1:
    case AND:
    case op_3:
    case op_4:
    case OR:
    case op_6:
    case op_7:
    case op_8:
    case op_9:
    case op_10:
    case op_11:
    case op_12:
    case op_13:
    case op_14:
    case op_15:
    case op_16:
    case op_17:
    case op_18:
    case op_19:
    case IN:
    case op_21:
    case op_22:
    case op_23:
    case op_24:
    case op_25:
    case op_27:
    case op_30:
    case op_31:
    case op_32:
    case op_33:
    case op_34:
    case op_35:
    case op_36:
    case op_37:
    case op_38:
    case op_39:
    case op_40:
    case op_41:
    case op_42:
    case op_43:
    case op_44:
    case op_45:
    case op_46:
    case op_47:
    case op_48:
    case op_49:
    case op_50:
    case op_51:
    case op_52:
    case op_53:
    case op_54:
    case op_55:
    case op_56:
    case op_59:
    case op_62:
    case op_63:
    case op_64:
    case EQUALS:
    case op_66:
    case op_67:
    case op_71:
    case op_72:
    case op_73:
    case op_74:
    case op_75:
    case op_77:
    case op_78:
    case op_79:
    case op_80:
    case op_81:
    case op_82:
    case op_83:
    case op_84:
    case op_85:
    case op_86:
    case op_87:
    case op_88:
    case op_89:
    case op_90:
    case op_91:
    case op_92:
    case op_93:
    case op_94:
    case op_95:
    case op_96:
    case op_97:
    case op_98:
    case op_100:
    case op_101:
    case op_102:
    case op_103:
    case op_104:
    case op_105:
    case op_106:
    case op_107:
    case op_108:
    case op_109:
    case op_110:
    case op_111:
    case op_117:
    case op_118:
    case op_119:
    case IDENTIFIER:
      tn = Extension();
      break;
    case STRING_LITERAL:
      tn = String();
                    epa();
      break;
    case NUMBER_LITERAL:
      tn = Number();
                    epa();
      break;
    default:
      jj_la1[80] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return tn;}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode String() throws ParseException {
  SyntaxTreeNode tn;
  Token t;
  bpa("String");
    t = jj_consume_token(STRING_LITERAL);
    tn = new SyntaxTreeNode( mn, N_String, t);
    tn.image = reduceString( tn.image.toString() );
    epa();
    {if (true) return tn;}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode Number() throws ParseException {
  SyntaxTreeNode tn, sn[] = null;
  Token t1, t2;
  int kind = N_Number;
    t1 = jj_consume_token(NUMBER_LITERAL);
    if (jj_2_40(2)) {
      t2 = jj_consume_token(DOT);
     kind = N_Real;
     decimalFlag = true;
     sn = new SyntaxTreeNode[3];
     sn[0] = new SyntaxTreeNode(mn, t1);
     sn[1] = new SyntaxTreeNode(mn, t2);
      t1 = jj_consume_token(NUMBER_LITERAL);
     sn[2] = new SyntaxTreeNode(mn,t1);
    } else {
      ;
    }
    if (sn == null) {
      numberFlag = true;
      sn = new SyntaxTreeNode[1];
      sn[0] =  new SyntaxTreeNode(mn, t1);
      kind = N_Number;
    }
    {if (true) return new SyntaxTreeNode(mn, kind, sn);}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode Extension() throws ParseException {
  SyntaxTreeNode last = null, tid, top = null;
  Token t = null;
  SyntaxTreeNode heirs[];
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case op_26:
    case op_29:
    case op_58:
    case CASESEP:
    case op_61:
    case op_112:
    case op_113:
    case op_114:
    case op_115:
    case op_116:
      //  LOOKAHEAD( { isPrefixOp( getToken(1) )  } )
            top = PrefixOp();
        heirs = new SyntaxTreeNode[2];
        heirs[0] = new SyntaxTreeNode( mn, N_IdPrefix, getLastHeirs() );
        heirs[1] = top;
        last = new SyntaxTreeNode( mn, N_GenPrefixOp, heirs );
        epa();
      break;
    case op_1:
    case AND:
    case op_3:
    case op_4:
    case OR:
    case op_6:
    case op_7:
    case op_8:
    case op_9:
    case op_10:
    case op_11:
    case op_12:
    case op_13:
    case op_14:
    case op_15:
    case op_16:
    case op_17:
    case op_18:
    case op_19:
    case IN:
    case op_21:
    case op_22:
    case op_23:
    case op_24:
    case op_25:
    case op_27:
    case op_30:
    case op_31:
    case op_32:
    case op_33:
    case op_34:
    case op_35:
    case op_36:
    case op_37:
    case op_38:
    case op_39:
    case op_40:
    case op_41:
    case op_42:
    case op_43:
    case op_44:
    case op_45:
    case op_46:
    case op_47:
    case op_48:
    case op_49:
    case op_50:
    case op_51:
    case op_52:
    case op_53:
    case op_54:
    case op_55:
    case op_56:
    case op_59:
    case op_62:
    case op_63:
    case op_64:
    case EQUALS:
    case op_66:
    case op_67:
    case op_71:
    case op_72:
    case op_73:
    case op_74:
    case op_75:
    case op_77:
    case op_78:
    case op_79:
    case op_80:
    case op_81:
    case op_82:
    case op_83:
    case op_84:
    case op_85:
    case op_86:
    case op_87:
    case op_88:
    case op_89:
    case op_90:
    case op_91:
    case op_92:
    case op_93:
    case op_94:
    case op_95:
    case op_96:
    case op_97:
    case op_98:
    case op_100:
    case op_101:
    case op_102:
    case op_103:
    case op_104:
    case op_105:
    case op_106:
    case op_107:
    case op_108:
    case op_109:
    case op_110:
    case op_111:
    case op_117:
    case op_118:
    case op_119:
      // LOOKAHEAD( { isInfixOp( getToken(1) )  } )
            top = InfixOp();
        heirs = new SyntaxTreeNode[2];
        heirs[0] = new SyntaxTreeNode( mn, N_IdPrefix, getLastHeirs() );
        heirs[1] = top;
        last =  new SyntaxTreeNode( mn, N_GenInfixOp, heirs );
        epa();
      break;
    case op_57:
    case op_68:
    case op_69:
    case op_70:
      // LOOKAHEAD( { isPostfixOp( getToken(1) )  } )
            top = PostfixOp();
        heirs = new SyntaxTreeNode[2];
        heirs[0] = new SyntaxTreeNode( mn, N_IdPrefix, getLastHeirs() );
        heirs[1] = top;
        last =  new SyntaxTreeNode( mn, N_GenPostfixOp, heirs );
        epa();
      break;
    case IDENTIFIER:
      tid = Identifier();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBR:
        top = OpArgs();
        break;
      default:
        jj_la1[81] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BANG:
        t = jj_consume_token(BANG);
        if ( top == null ) {
          heirs = new SyntaxTreeNode[2];
          heirs[1] = new SyntaxTreeNode( mn, t );
        } else {
          heirs = new SyntaxTreeNode[3];
          heirs[1] = top;
          heirs[2] = new SyntaxTreeNode(mn, t );
        }
        heirs[0] = tid;
        SyntaxTreeNode current = new SyntaxTreeNode( mn, N_IdPrefixElement, heirs );
        addHeir( current );
        last = Extension();
        break;
      default:
        jj_la1[82] = jj_gen;
        ;
      }
      if ( last == null ) {
         if ( top == null ) {
           heirs = new SyntaxTreeNode[2];
           heirs[0] = new SyntaxTreeNode( mn, N_IdPrefix, getLastHeirs() );
           heirs[1] = tid;
           last = new SyntaxTreeNode( mn, N_GeneralId, heirs );
         } else {
/* XXX Wrong.
           addHeir( tid );
           tid = new SyntaxTreeNode( mn, N_GeneralId, getLastHeirs() );
*/
           heirs = new SyntaxTreeNode[2];
           heirs[0] = new SyntaxTreeNode( mn, N_IdPrefix, getLastHeirs() );
           heirs[1] = tid;
           tid = new SyntaxTreeNode( mn, N_GeneralId, heirs );

           heirs = new SyntaxTreeNode[2];
           heirs[0] = tid;
           heirs[1] = top;
           last = new SyntaxTreeNode( mn, N_OpApplication, heirs );
         }
         epa();
      }
      break;
    default:
      jj_la1[83] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return last;}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode OpArgs() throws ParseException {
                      // OpSuite contributes to Heir list.
  SyntaxTreeNode tn;
  Token t;
  bpa("Optional Arguments");
    t = jj_consume_token(LBR);
               addHeir( new SyntaxTreeNode(mn, t) );
    OpSuite();
    label_24:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[84] = jj_gen;
        break label_24;
      }
      t = jj_consume_token(COMMA);
                  addHeir( new SyntaxTreeNode(mn, t) );
      OpSuite();
    }
    t = jj_consume_token(RBR);
               addHeir( new SyntaxTreeNode(mn, t) );
    SyntaxTreeNode sn[] = getLastHeirs();
    epa(); {if (true) return new SyntaxTreeNode(mn, N_OpArgs, sn);}
    throw new Error("Missing return statement in function");
  }

/***************************************************************************
* OpOrExpr ::=    (NonExpPrefixOp | InfixOp | PostfixOp)                   *
*                   followed by                                            *
*                     "," | ")" | <DEFBREAK> | "LOCAL" | "INSTANCE" |      *
*                     "THEOREM" | "ASSUME" | "ASSUMPTION" |                *
*                     "CONSTANT" | "VARIABLE" | "RECURSIVE" |              *
*                    <END_MODULE> | <SEPARATOR> | <BEGIN_MODULE>           *
*               | Lambda                                                   *
*               | Expression                                               *
*                                                                          *
* This production is called where either an operator or an expression is   *
* expected--which is either as the argument of an operator or in a         *
* substitution.  For an expression or an operator argument that's a        *
* LAMBDA expression, there's no problem.  However, something like Foo!Bar  *
* could be either an expression or an operator.  In TLA+2, something like  *
* Foo!+!Bar could only be an operator, while something like                *
* Foo!+(a,b)!Bar could only be an expression.  However, in order to        *
* minimize the changes from the TLA+1 parser, we represent both Foo!+!Bar  *
* and Foo!+(a,b)!Bar as a GeneralId node and leave it to the semantic      *
* processing to sort things out.  Thus, Foo!+(a,b)!Bar produces the        *
* folowing tree of SyntaxTreeNode objects:                                 *
*                                                                          *
*    N_GeneralId                                                           *
*    _.N_IdPrefix                                                          *
*    _._.N_IdPrefixElement                                                 *
*    _._._.IDENTIFIER "Foo"                                                *
*    _._._.BANG "!"                                                        *
*    _._.N_IdPrefixElement                                                 *
*    _._._.N_InfixOp  +                                                    *
*    _._._.N_OpArgs                                                        *
*    _._._._.LBR "("                                                       *
*    _._._._.whatever a produces                                           *
*    _._._._.COMMA ","                                                     *
*    _._._._.whatever b produces                                           *
*    _._._._.RBR ")"                                                       *
*    _._._.BANG "!"                                                        *
*    _.IDENTIFIER "Bar"                                                    *
*                                                                          *
* Something like Foo!+(a,b)!Bar(x) producs an N_OpApplication node         *
* whose first child is the N_GeneralId node above and whose second         *
* child is an N_OpArgs node.                                               *
*                                                                          *
* TLA+2 adds labels and structural operators like "<<" to this kind of     *
* operator or expression.  A label in such an expression looks just like   *
* an ordinary identifier.  A structural operator is represented by a       *
* token with the new kind "N_StructOp".  Such a node is created by         *
*                                                                          *
*   new SynaxTreeNode(moduleName, N_StructOp, node)                        *
*                                                                          *
* where node is created by either                                          *
*                                                                          *
*   new SyntaxTreeNode(moduleName, tok)                                    *
*                                                                          *
* where tok is "<<", ">>", "@", or ":", or by                              *
*                                                                          *
*    new SynaxTreeNode(moduleName, N_Number, ...)                          *
*                                                                          *
* for a <NUMBER_LITERAL> token.                                            *
*                                                                          *
* Let OpArgs = (arg_1, ...  , arg_k).  In general, there are three         *
* interesting classes of expressions of the form e_1!e_2!...!e_n.          *
*                                                                          *
* Case 1: e_n = tok OpArgs,                                                *
*           where tok is an Identifier or an In/Pre/PostfixOp.             *
*   In this case an OpApplication node is produced with two children:      *
*   - An N_GeneralId node with children                                    *
*      - An N_IdPrefixNode with n-1 children consisting N_IdPRefixElement  *
*        nodes for e_1!, ... , e_n-1!.                                     *
*      - A node of kind IDENTIFIER, N_PrefixOp, etc. for tok               *
*   - An N_OpArgs nodes obtained from OpArgs                               *
*                                                                          *
* Case 2: e_n = tok                                                        *
*           where tok is an Identifier or an In/Pre/PostfixOp.             *
*   In this case, it produces just the N_GeneralId node of Case 1          *
*                                                                          *
* Case 3: e_n = OpArgs                                                     *
*   In this case, a GeneralId node is produced with two children:          *
*    - The N_IdPrefixNode node produced in cases 1 and 2                   *
*    - An N_OpArgs node for OpArgs.                                        *
***************************************************************************/
  final public SyntaxTreeNode OpOrExpr() throws ParseException {
  /*************************************************************************
  * Used for parsing an operator argument or the right-hand side of a      *
  * substitution, which could be either an operator (like +) or an         *
  * expression (like a+b).                                                 *
  *************************************************************************/
SyntaxTreeNode tn;
int kind ;
    if (jj_2_41(2) && (BStack.aboveReference( getToken(1).beginColumn))) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case op_76:
      case op_26:
      case op_29:
      case op_58:
      case CASESEP:
      case op_61:
      case op_112:
      case op_113:
      case op_114:
      case op_115:
      case op_116:
        tn = NonExpPrefixOp();
                             kind = N_GenNonExpPrefixOp;
        break;
      case op_1:
      case AND:
      case op_3:
      case op_4:
      case OR:
      case op_6:
      case op_7:
      case op_8:
      case op_9:
      case op_10:
      case op_11:
      case op_12:
      case op_13:
      case op_14:
      case op_15:
      case op_16:
      case op_17:
      case op_18:
      case op_19:
      case IN:
      case op_21:
      case op_22:
      case op_23:
      case op_24:
      case op_25:
      case op_27:
      case op_30:
      case op_31:
      case op_32:
      case op_33:
      case op_34:
      case op_35:
      case op_36:
      case op_37:
      case op_38:
      case op_39:
      case op_40:
      case op_41:
      case op_42:
      case op_43:
      case op_44:
      case op_45:
      case op_46:
      case op_47:
      case op_48:
      case op_49:
      case op_50:
      case op_51:
      case op_52:
      case op_53:
      case op_54:
      case op_55:
      case op_56:
      case op_59:
      case op_62:
      case op_63:
      case op_64:
      case EQUALS:
      case op_66:
      case op_67:
      case op_71:
      case op_72:
      case op_73:
      case op_74:
      case op_75:
      case op_77:
      case op_78:
      case op_79:
      case op_80:
      case op_81:
      case op_82:
      case op_83:
      case op_84:
      case op_85:
      case op_86:
      case op_87:
      case op_88:
      case op_89:
      case op_90:
      case op_91:
      case op_92:
      case op_93:
      case op_94:
      case op_95:
      case op_96:
      case op_97:
      case op_98:
      case op_100:
      case op_101:
      case op_102:
      case op_103:
      case op_104:
      case op_105:
      case op_106:
      case op_107:
      case op_108:
      case op_109:
      case op_110:
      case op_111:
      case op_117:
      case op_118:
      case op_119:
        tn = InfixOp();
         kind = N_GenInfixOp;
         if (   (tn.image == UniqueString.uniqueStringOf("\\X"))
             || (tn.image == UniqueString.uniqueStringOf("\\times"))){
            {if (true) throw new ParseException(
                        tn.getLocation().toString() +
                        ": \\X may not be used as an infix operator.");}
           };
        break;
      case op_57:
      case op_68:
      case op_69:
      case op_70:
        tn = PostfixOp();
                             kind = N_GenPostfixOp;
        break;
      default:
        jj_la1[85] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    SyntaxTreeNode heirs[] = new SyntaxTreeNode[2];
    heirs[0] = new SyntaxTreeNode( mn, N_IdPrefix, ( SyntaxTreeNode []) null );
    heirs[1] = tn;
    tn = new SyntaxTreeNode(mn, kind, heirs);
    } else if (jj_2_42(2147483647) && (BStack.aboveReference( getToken(1).beginColumn))) {
      /***********************************************************************
          * Need the BStack.aboveReference check to make sure that the LAMBDA    *
          * is properly indented with respect to any enclosing dis/conjunction   *
          * list.  However, without the <LAMBDA>, the lookahead would succeed    *
          * and the next production would be executed even if it shouldn't       *
          * match.                                                               *
          ***********************************************************************/
        tn = Lambda();
    } else if (jj_2_43(1)) {
      tn = Expression();
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
 {if (true) return tn;}
    throw new Error("Missing return statement in function");
  }

  final public void OpSuite() throws ParseException {
SyntaxTreeNode tn;
    tn = OpOrExpr();
                    addHeir(tn);
  }

  // OpSuite


// void /* nodes are linked internally here : no value returned */
// oldOpSuite() : {
//   SyntaxTreeNode tn = null;
//   anchor = null;
//     /***********************************************************************
//     * See the comments for the declaration of anchor to see what this is   *
//     * being used for.                                                      *
//     ***********************************************************************/
//   Token t;
// } {
//   ( /***********************************************************************
//     * This handles the operator argument "-." (token op_76)                *
//     ***********************************************************************/
// // XXXXX -- this won't work with the new expression syntax.
//     t = <op_76> {
//     tn = new SyntaxTreeNode(mn, N_NonExpPrefixOp, t); 
//     SyntaxTreeNode heirs[] = new SyntaxTreeNode[2];
//     heirs[0] = new SyntaxTreeNode( mn, N_IdPrefix, ( SyntaxTreeNode []) null );
//     heirs[1] = tn;
//     tn = new SyntaxTreeNode( mn, N_GenNonExpPrefixOp, heirs ); }
//   | LOOKAHEAD( (<AND> | <OR>) (<COMMA>|<RBR>) )
//       tn = InfixOp() {
//         heirs = new SyntaxTreeNode[2];
//         heirs[0] = new SyntaxTreeNode( mn, N_IdPrefix, (SyntaxTreeNode []) null );
//         heirs[1] = tn;
//         tn =  new SyntaxTreeNode( mn, N_GenInfixOp, heirs );
//      }
//   | tn = Lambda() 
//   | try {
//       tn = Expression()
//     } catch ( ParseException e ) {
// // ToolIO.out.println("Caught exception (bis)");
// // first things first - restore evaluation stack
//     if ( OperatorStack.isWellReduced() )
//       OperatorStack.popStack();
//     else
//       throw e;
//     /* it wasn't an expression, what was it ? */
//     /* check the nature of the node returned. It can only be a prefixed op. */
//     if ( ( anchor != null )
//        &&(    anchor.isKind( N_GenPrefixOp ) 
//            || anchor.isKind( N_GenInfixOp ) 
//            || anchor.isKind( N_GenPostfixOp ) ) ) {tn = anchor; anchor = null;
//       } else {
// // ToolIO.out.println("anchor is " + anchor.toString());
//        throw e;
//       } // end else
//     } // end catch.
// )
//     /* it wasn't an expression, what was it ?  L.GenNonExpPrefixOp | L.GenInfixOp | L.GenPostfixOp */
//     /* check the nature of the node returned . Below Expression, it has to be a prefixed op. */
//   { addHeir( tn ); }
// }
  final public SyntaxTreeNode ParenExpr() throws ParseException {
  SyntaxTreeNode zn[] = new SyntaxTreeNode[3];
  SyntaxTreeNode tn;
  Token t;
    t = jj_consume_token(LBR);
               zn[0] = new SyntaxTreeNode(mn, t);
    zn[1] = Expression();
    t = jj_consume_token(RBR);
               zn[2] = new SyntaxTreeNode(mn, t);
    {if (true) return new SyntaxTreeNode(mn, N_ParenExpr, zn );}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode SomeQuant() throws ParseException {
  SyntaxTreeNode tn;
  Token t;
  bpa("Quantified form");
  int kind;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EXISTS:
      t = jj_consume_token(EXISTS);
      break;
    case FORALL:
      t = jj_consume_token(FORALL);
      break;
    default:
      jj_la1[86] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                                    addHeir( new SyntaxTreeNode(mn, t));
    if (jj_2_44(2147483647)) {
      tn = Identifier();
      kind = N_UnboundQuant;
      addHeir( tn );
      label_25:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[87] = jj_gen;
          break label_25;
        }
        t = jj_consume_token(COMMA);
                      addHeir( new SyntaxTreeNode(mn, t) );
        tn = Identifier();
        addHeir( tn );
      }
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LAB:
      case IDENTIFIER:
        tn = QuantBound();
      kind = N_BoundQuant;
      addHeir( tn );
        label_26:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            jj_la1[88] = jj_gen;
            break label_26;
          }
          t = jj_consume_token(COMMA);
                    addHeir( new SyntaxTreeNode(mn, t) );
          tn = QuantBound();
                          addHeir( tn );
        }
        break;
      default:
        jj_la1[89] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    t = jj_consume_token(COLON);
                 addHeir( new SyntaxTreeNode(mn, t) );
    tn = Expression();
                      addHeir( tn );
    SyntaxTreeNode sn[] = getLastHeirs();
    epa(); {if (true) return new SyntaxTreeNode(mn, kind, sn);}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode SomeTQuant() throws ParseException {
  SyntaxTreeNode tn;
  Token t;
  bpa("Bound Quantified Expression");
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case T_EXISTS:
      t = jj_consume_token(T_EXISTS);
      break;
    case T_FORALL:
      t = jj_consume_token(T_FORALL);
      break;
    default:
      jj_la1[90] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                                        addHeir( new SyntaxTreeNode(mn, t) );
    tn = Identifier();
    addHeir( tn );
    label_27:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[91] = jj_gen;
        break label_27;
      }
      t = jj_consume_token(COMMA);
                  addHeir( new SyntaxTreeNode(mn, t) );
      tn = Identifier();
      addHeir( tn );
    }
    t = jj_consume_token(COLON);
                 addHeir( new SyntaxTreeNode(mn, t) );
    tn = Expression();
                      addHeir( tn );
    SyntaxTreeNode sn[] = getLastHeirs();
    epa(); {if (true) return new SyntaxTreeNode(mn, N_UnboundQuant, sn);}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode QuantBound() throws ParseException {
  SyntaxTreeNode tn;
  Token t;
  bpa("Quant Bound");
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LAB:
      tn = IdentifierTuple();
      addHeir( tn );
      break;
    case IDENTIFIER:
      tn = Identifier();
      addHeir( tn );
      label_28:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[92] = jj_gen;
          break label_28;
        }
        t = jj_consume_token(COMMA);
                      addHeir( new SyntaxTreeNode(mn, t) );
        tn = Identifier();
          addHeir( tn );
          expecting = ", or \\in";
      }
      break;
    default:
      jj_la1[93] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    t = jj_consume_token(IN);
    tn =  new SyntaxTreeNode(mn, t);
    tn.setKind(T_IN);
    addHeir(tn);
    tn = Expression();
                      addHeir( tn );
    SyntaxTreeNode sn[] = getLastHeirs();
    epa(); {if (true) return new SyntaxTreeNode(mn, N_QuantBound, sn);}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode BraceCases() throws ParseException {
  int kind = N_SetEnumerate; // set by default.
  SyntaxTreeNode tn, tn_0, tn_1, tn_2, htn = null;
  Token t;
  boolean te = false;
    /***********************************************************************
    * The value of te is set in a couple of places, but it is never        *
    * read.  J-Ch hopes it's obsolete.                                     *
    ***********************************************************************/
  bpa("Some { } form");
    t = jj_consume_token(LBC);
               addHeir( new SyntaxTreeNode(mn, t) );
    if (jj_2_48(1)) {
      if (matchFcnConst()) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LAB:
          tn = IdentifierTuple();
          break;
        case IDENTIFIER:
          tn = Identifier();
          break;
        default:
          jj_la1[94] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      tn_0 = tn;
      expecting = "\\in";
        // At this stage, we need to break since it maybe a MaybeBound or
        // a SubsetOf
        // So we'll hold to the pieces in the meantime.
            t = jj_consume_token(IN);
      tn_1 =  new SyntaxTreeNode(mn, t);
      tn_1.setKind(T_IN);
        /*******************************************************************
        * Changed from tn.setKind(T_IN) by LL on 19 Mar 2007.              *
        *                                                                  *
        * Appears to fix bug that caused semantic error on something like  *
        * {<<m, n>> \in Nat \X Nat : m > 0}.                               *
        *******************************************************************/

//      addHeir(tn);

        tn_2 = Expression();
//      addHeir( tn );
// need to create a node for a N_InfixExpr. Some reassembly required, but if course it may be for naught.
// This is in case it isn't a N_SubsetOf
      expecting = "':', ',' or '}'";
      SyntaxTreeNode zn[] = new SyntaxTreeNode[3];
      SyntaxTreeNode wn[]= new SyntaxTreeNode[2];
      wn[0] = new SyntaxTreeNode(mn, N_IdPrefix, new SyntaxTreeNode[0]);
      wn[1] = tn_0;
      zn[0] = new SyntaxTreeNode(mn, N_GeneralId, wn);
      wn = new SyntaxTreeNode[2];
      wn[0] = new SyntaxTreeNode(mn, N_IdPrefix, new SyntaxTreeNode[0]);
      wn[1] = tn_1;
      zn[1] = new SyntaxTreeNode(mn, N_GenInfixOp, wn);
      zn[2] = tn_2;
      htn = new SyntaxTreeNode( mn, N_InfixExpr, zn);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
        case COLON:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COLON:
            t = jj_consume_token(COLON);
      htn = null; // it was for naught, ignore it later.
      addHeir(tn_0); // ID
      addHeir(tn_1); // \\in
      addHeir(tn_2); // expression
      addHeir( new SyntaxTreeNode(mn, t) );
      kind = N_SubsetOf;
            tn = Expression();
                          addHeir( tn );
            break;
          case COMMA:
            label_29:
            while (true) {
              t = jj_consume_token(COMMA);
        if (htn != null) {
          addHeir( htn); htn = null;
        }
        addHeir( new SyntaxTreeNode(mn, t) );
              tn = Expression();
                            addHeir( tn );
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case COMMA:
                ;
                break;
              default:
                jj_la1[95] = jj_gen;
                break label_29;
              }
            }
            break;
          default:
            jj_la1[96] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        default:
          jj_la1[97] = jj_gen;
          ;
        }
      } else if (jj_2_45(2147483647)) {
        tn = Expression();
      kind = N_SetEnumerate;
      addHeir( tn );
        label_30:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            jj_la1[98] = jj_gen;
            break label_30;
          }
          t = jj_consume_token(COMMA);
                     addHeir( new SyntaxTreeNode(mn, t) );
          tn = Expression();
                            addHeir( tn );
        }
      } else if (jj_2_46(2147483647)) {
      te = true; kind = N_SetOfAll;
        tn = Expression();
      addHeir( tn );
        t = jj_consume_token(COLON);
                   addHeir( new SyntaxTreeNode(mn, t) );
        tn = QuantBound();
                        addHeir( tn );
        label_31:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            jj_la1[99] = jj_gen;
            break label_31;
          }
          t = jj_consume_token(COMMA);
                    addHeir( new SyntaxTreeNode(mn, t) );
          tn = QuantBound();
                          addHeir( tn );
        }
      } else if (jj_2_47(1)) {
        tn = Expression();
                        addHeir( tn );
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
        case COLON:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COLON:
            t = jj_consume_token(COLON);
        te = true; kind = N_SetOfAll;
// IF tn is infix expression, with operator IN, we have a pbm for throw new ParseException( "Form {a \in b : c \in d } is forbidden" );

        /*******************************************************************
        * The following code causes an incorrect error on the legal        *
        * expression {1 \in x : x \in T}.  It seems to me that this        *
        * test should simply be eliminated.  It seems to be based on the   *
        * mistaken belief that {x \in S : x \in T} is illegal, when it's   *
        * actually an expression of type N_SubsetOf.                       *
        *******************************************************************/
        SyntaxTreeNode Hone[] = (SyntaxTreeNode[])tn.heirs();
        if (Hone.length>1) { // better make sure it's long enough.
          Hone = (SyntaxTreeNode[])Hone[1].heirs(); // second heir of second heir
          if ( tn.isKind( N_InfixExpr ) && Hone[1].getImage().equals("\\in") ) {
            {if (true) throw new ParseException( "Form {a \\in b : c \\in d }, at line " + t.beginLine + ", is not allowed" );}
          }
        }
        addHeir( new SyntaxTreeNode(mn, t) );
            tn = QuantBound();
                          addHeir( tn );
            label_32:
            while (true) {
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case COMMA:
                ;
                break;
              default:
                jj_la1[100] = jj_gen;
                break label_32;
              }
              t = jj_consume_token(COMMA);
                      addHeir( new SyntaxTreeNode(mn, t) );
              tn = QuantBound();
                          addHeir( tn );
            }
            break;
          case COMMA:
            label_33:
            while (true) {
              t = jj_consume_token(COMMA);
                      kind = N_SetEnumerate;
        addHeir( new SyntaxTreeNode(mn, t) );
              tn = Expression();
                            addHeir( tn );
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case COMMA:
                ;
                break;
              default:
                jj_la1[101] = jj_gen;
                break label_33;
              }
            }
            break;
          default:
            jj_la1[102] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        default:
          jj_la1[103] = jj_gen;
          ;
        }
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
    } else {
      ;
    }
    t = jj_consume_token(RBC);
    if (htn!=null) addHeir(htn);
    addHeir( new SyntaxTreeNode(mn, t) );
    SyntaxTreeNode sn[] = getLastHeirs();
    epa(); {if (true) return new SyntaxTreeNode(mn, kind, sn);}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode SBracketCases() throws ParseException {
  SyntaxTreeNode tn;
  Token t;
  int kind = 0;
  bpa("Some [] Form");
    t = jj_consume_token(LSB);
               addHeir( new SyntaxTreeNode(mn, t) );
    if (matchFcnConst()) {
      // FcnConst - because we use OpSymbol rather than IN, we need to use semantic detection.
          tn = QuantBound();
      kind = N_FcnConst;
      addHeir( tn );
      label_34:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[104] = jj_gen;
          break label_34;
        }
        t = jj_consume_token(COMMA);
                    addHeir( new SyntaxTreeNode(mn, t) );
        tn = QuantBound();
                          addHeir( tn );
      }
      t = jj_consume_token(MAPTO);
                  addHeir( new SyntaxTreeNode(mn, t) );
      tn = Expression();
                        addHeir( tn );
      t = jj_consume_token(RSB);
                addHeir( new SyntaxTreeNode(mn, t) );
    } else if (jj_2_49(2147483647)) {
      /* RcdConstructor */
          tn = FieldVal();
      kind = N_RcdConstructor;
      addHeir( tn );
      label_35:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[105] = jj_gen;
          break label_35;
        }
        t = jj_consume_token(COMMA);
                    addHeir( new SyntaxTreeNode(mn, t) );
        tn = FieldVal();
                        addHeir( tn );
      }
      t = jj_consume_token(RSB);
                addHeir( new SyntaxTreeNode(mn, t) );
    } else if ((getToken(2).kind == MAPTO) && isFieldNameToken( getToken(1))) {
      getToken(1).kind = IDENTIFIER;
      tn = FieldVal();
      kind = N_RcdConstructor;
      addHeir( tn );
      label_36:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[106] = jj_gen;
          break label_36;
        }
        t = jj_consume_token(COMMA);
                    addHeir( new SyntaxTreeNode(mn, t) );
        tn = FieldVal();
                        addHeir( tn );
      }
      t = jj_consume_token(RSB);
                addHeir( new SyntaxTreeNode(mn, t) );
    } else if (jj_2_50(2147483647)) {
      /* SetOfRcds */
          tn = FieldSet();
      kind = N_SetOfRcds;
      addHeir( tn );
      label_37:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[107] = jj_gen;
          break label_37;
        }
        t = jj_consume_token(COMMA);
                    addHeir( new SyntaxTreeNode(mn, t) );
        tn = FieldSet();
                        addHeir( tn );
      }
      t = jj_consume_token(RSB);
                addHeir( new SyntaxTreeNode(mn, t) );
    } else if (jj_2_51(1)) {
      tn = Expression();
                        addHeir( tn );
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
      case RSB:
        label_38:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            jj_la1[108] = jj_gen;
            break label_38;
          }
          t = jj_consume_token(COMMA);
                      addHeir( new SyntaxTreeNode(mn, t) );
          tn = Expression();
                            addHeir( tn );
        }
        t = jj_consume_token(RSB);
                  addHeir( new SyntaxTreeNode(mn, t) );
      kind = N_FcnAppl;
      lastOp = FcnOp;
        break;
      case ARROW:
        t = jj_consume_token(ARROW);
                                          // SetOfFcns
        kind = N_SetOfFcns;
        addHeir( new SyntaxTreeNode(mn, t) );
        tn = Expression();
                          addHeir( tn );
        t = jj_consume_token(RSB);
                  addHeir( new SyntaxTreeNode(mn, t) );
        break;
      case EXCEPT:
        t = jj_consume_token(EXCEPT);
                                           // Except
        kind = N_Except;
        addHeir( new SyntaxTreeNode(mn, t) );
        tn = ExceptSpec();
                          addHeir( tn );
        label_39:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            jj_la1[109] = jj_gen;
            break label_39;
          }
          t = jj_consume_token(COMMA);
                      addHeir( new SyntaxTreeNode(mn, t) );
          tn = ExceptSpec();
                            addHeir( tn );
        }
        t = jj_consume_token(RSB);
                  addHeir( new SyntaxTreeNode(mn, t) );
        break;
      case ARSB:
        t = jj_consume_token(ARSB);
        kind = N_ActionExpr;
        addHeir( new SyntaxTreeNode(mn, t) );
        tn = ReducedExpression();
                                 addHeir( tn );
        break;
      default:
        jj_la1[110] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
    SyntaxTreeNode sn[] = getLastHeirs();
    Assert.assertion(kind !=0);
    epa(); {if (true) return new SyntaxTreeNode(mn, kind, sn);}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode FieldVal() throws ParseException {
  SyntaxTreeNode zn[] = new SyntaxTreeNode[3];
  Token t;
  bpa("Field Value");
    zn[0] = Identifier();
    t = jj_consume_token(MAPTO);
                zn[1] = new SyntaxTreeNode(mn, t);
    zn[2] = Expression();
    epa(); {if (true) return new SyntaxTreeNode(mn, N_FieldVal, zn );}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode FieldSet() throws ParseException {
  SyntaxTreeNode zn[] = new SyntaxTreeNode[3];
  SyntaxTreeNode tn;
  Token t;
  bpa("Field Set");
    zn[0] = Identifier();
    t = jj_consume_token(COLON);
                zn[1] = new SyntaxTreeNode(mn, t);
    zn[2] = Expression();
    epa(); {if (true) return new SyntaxTreeNode( mn, N_FieldSet, zn );}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode ExceptSpec() throws ParseException {
  SyntaxTreeNode tn;
  Token t;
  bpa("Except Spec");
    t = jj_consume_token(BANG);
               addHeir( new SyntaxTreeNode(mn, t) );
    label_40:
    while (true) {
      tn = ExceptComponent();
    addHeir( tn );
    expecting = "= or ,";
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DOT:
      case LSB:
        ;
        break;
      default:
        jj_la1[111] = jj_gen;
        break label_40;
      }
    }
    t = jj_consume_token(EQUALS);
    tn =  new SyntaxTreeNode(mn, t);
    tn.setKind(T_EQUAL);
    addHeir(tn);
    tn = Expression();
                      addHeir( tn );
    SyntaxTreeNode sn[] = getLastHeirs();
    epa(); {if (true) return new SyntaxTreeNode( mn, N_ExceptSpec, sn );}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode ExceptComponent() throws ParseException {
  SyntaxTreeNode tn;
  Token t;
  bpa("Except Component");
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DOT:
      t = jj_consume_token(DOT);
                addHeir( new SyntaxTreeNode(mn, t) );
                /***********************************************************
                * Following added by LL on 10 Oct 2007 to make something   *
                * like "!.THEN" work right.                                *
                ***********************************************************/
                Token next = getToken(1);
                if (isFieldNameToken( next )) next.kind = IDENTIFIER;
      tn = Identifier();
      if (tn.getUS().equals(At) ) {
        PErrors.push( new ParseError("@ used in !.@") );
      }
      addHeir( tn );
      break;
    case LSB:
      t = jj_consume_token(LSB);
                addHeir( new SyntaxTreeNode(mn, t) );
      tn = Expression();
                        addHeir( tn );
      label_41:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[112] = jj_gen;
          break label_41;
        }
        t = jj_consume_token(COMMA);
                    addHeir( new SyntaxTreeNode(mn, t) );
        tn = Expression();
                          addHeir( tn );
      }
      t = jj_consume_token(RSB);
                addHeir( new SyntaxTreeNode(mn, t) );
      break;
    default:
      jj_la1[113] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    SyntaxTreeNode sn[] = getLastHeirs(); epa();
    {if (true) return new SyntaxTreeNode( mn, N_ExceptComponent, sn );}
    throw new Error("Missing return statement in function");
  }

/***************************************************************************
* The SetExcept non-terminal was eliminated from the grammar, but not      *
* from the parser.                                                         *
***************************************************************************/
  final public SyntaxTreeNode SetExcept() throws ParseException {
  SyntaxTreeNode tn;
  Token t;
  bpa("Set Except");
    t = jj_consume_token(LWB);
              addHeir( new SyntaxTreeNode(mn, t) );
    tn = Expression();
                      addHeir( tn );
    t = jj_consume_token(EXCEPT);
                 addHeir( new SyntaxTreeNode(mn, t) );
    tn = SExceptSpec();
                       addHeir( tn );
    label_42:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[114] = jj_gen;
        break label_42;
      }
      t = jj_consume_token(COMMA);
                  addHeir( new SyntaxTreeNode(mn, t) );
      tn = SExceptSpec();
                         addHeir( tn );
    }
    t = jj_consume_token(RWB);
              addHeir( new SyntaxTreeNode(mn, t) );
    SyntaxTreeNode sn[] = getLastHeirs();
    epa(); {if (true) return new SyntaxTreeNode( mn, N_SetExcept, sn );}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode SExceptSpec() throws ParseException {
  SyntaxTreeNode zn[] = new SyntaxTreeNode[4];
  SyntaxTreeNode tn;
  Token t;
  bpa("Set Expect Spec");
    t = jj_consume_token(BANG);
               zn[0] = new SyntaxTreeNode(mn, t);
    zn[1] = ExceptComponent();
    expecting = "= or \\in";
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EQUALS:
      t = jj_consume_token(EQUALS);
      zn[2] =  new SyntaxTreeNode(mn, t); zn[2].setKind( T_EQUAL );
      break;
    case IN:
      t = jj_consume_token(IN);
      zn[2] =  new SyntaxTreeNode(mn, t); zn[2].setKind( T_IN );
      break;
    default:
      jj_la1[115] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    zn[3] = Expression();
    epa(); {if (true) return new SyntaxTreeNode( mn, N_SExceptSpec, zn );}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode TupleOrAction() throws ParseException {
  int kind = 0;
  SyntaxTreeNode tn;
  Token t;
  bpa("Some << -- >> or >>_ Form");
    t = jj_consume_token(LAB);
              addHeir( new SyntaxTreeNode(mn, t) );
    if (jj_2_52(1)) {
      tn = Expression();
                        addHeir( tn );
      label_43:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[116] = jj_gen;
          break label_43;
        }
        t = jj_consume_token(COMMA);
                    addHeir( new SyntaxTreeNode(mn, t) );
        tn = Expression();
                            addHeir( tn );
      }
    } else {
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case RAB:
      t = jj_consume_token(RAB);
      kind = N_Tuple; addHeir( new SyntaxTreeNode(mn, t) );
      break;
    case ARAB:
      t = jj_consume_token(ARAB);
      kind = N_ActionExpr; addHeir( new SyntaxTreeNode(mn, t) );
      tn = ReducedExpression();
                               addHeir( tn );
      break;
    default:
      jj_la1[117] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    SyntaxTreeNode sn[] = getLastHeirs();
    epa(); {if (true) return new SyntaxTreeNode( mn, kind, sn );}
    throw new Error("Missing return statement in function");
  }

//  new SyntaxTreeNode( N_IdPrefix )  ???
  final public SyntaxTreeNode NoOpExtension() throws ParseException {
  SyntaxTreeNode tid, top, last;
  last = null; top = null;
  Token t = null;
    tid = Identifier();
    if (jj_2_53(2)) {
      top = OpArgs();
    } else {
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BANG:
      t = jj_consume_token(BANG);
        SyntaxTreeNode heirs[];
        if ( top == null ) {
          heirs = new SyntaxTreeNode[2];
          heirs[1] = new SyntaxTreeNode( mn, t );
        } else {
          heirs = new SyntaxTreeNode[3];
          heirs[1] = top;
          heirs[2] = new SyntaxTreeNode(mn, t );
        }
        heirs[0] = tid;
        SyntaxTreeNode current = new SyntaxTreeNode( mn, N_IdPrefixElement, heirs );
        addHeir( current );
      last = NoOpExtension();
      break;
    default:
      jj_la1[118] = jj_gen;
      ;
    }
      if ( last == null ) { // means no bang, bottom of recursion
         if ( top != null )
           FairnessHook = top;
         else
           FairnessHook = null;
         SyntaxTreeNode zn[] = new SyntaxTreeNode[2];
         zn[0] = new SyntaxTreeNode( mn, N_IdPrefix, getLastHeirs() );
         zn[1] = tid;
         last = new SyntaxTreeNode( mn, N_GeneralId, zn );
      }
    {if (true) return last;}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode ReducedExpression() throws ParseException {
  /*************************************************************************
  * This is an expression that can follow "[...]_" or "<<...>>_".          *
  *************************************************************************/
  SyntaxTreeNode expr;
  bpa("restricted form of expression");
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      expr = NoOpExtension();
      break;
    case LBR:
      expr = ParenExpr();
      break;
    case LBC:
      expr = BraceCases();
      break;
    case LSB:
      expr = SBracketCases();
      break;
    case LWB:
      expr = SetExcept();
      break;
    case LAB:
      expr = TupleOrAction();
      break;
    default:
      jj_la1[119] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     epa(); {if (true) return expr;}
    throw new Error("Missing return statement in function");
  }

// The following cases - for the first expression - must be recognized :
// "GeneralId", "OpApplication", "RecordComponent", "FcnAppl", "ParenExpr", "SetEnumerate", "SubsetOf", "SetOfAll", "FcnConst", "SetOfFcns", "RcdConstructor", "SetOfRcds", "Except", "Tuple", "ActionExpr"
// The cases break down in two categories: two set of () or a single one.
// in general, it's going to be some () [] or {} expression, or an Identifier foollowed by . () or [].
// Note that FcnAppl may be more intricate.
  final public SyntaxTreeNode FairnessExpr() throws ParseException {
  SyntaxTreeNode zn[] = new SyntaxTreeNode[5];
  SyntaxTreeNode tn, expr;
  Token t;
  FairnessHook = null;
  bpa("Fairness Expression");
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WF:
      t = jj_consume_token(WF);
      break;
    case SF:
      t = jj_consume_token(SF);
      break;
    default:
      jj_la1[120] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                          zn[0] = new SyntaxTreeNode(mn, t);
    expr = ReducedExpression();
    if (jj_2_54(2)) {
      t = jj_consume_token(LBR);
// ^^^  
// Warning 3 -- Eliminated by LOOKAHEAD
    zn[1] = expr; expr = null;
    zn[2] = new SyntaxTreeNode(mn, t);
      zn[3] = Expression();
      t = jj_consume_token(RBR);
                zn[4] = new SyntaxTreeNode(mn, t);
    } else {
      ;
    }
    epa();
    if ( expr != null ) {  // no extra (), FairnessHook can't be null ** Add check.
      if (FairnessHook == null) {
        {if (true) throw new ParseException("Ill-structured fairness expression at line " + zn[0].location[0] + ", column " + zn[0].location[1]);}
      }

      SyntaxTreeNode parameters[] = (SyntaxTreeNode[]) FairnessHook.heirs();
      if ( parameters != null && parameters.length == 3) { // was FairnessHook
        zn[1] = expr;
        zn[2] = parameters[0];
        zn[3] = parameters[1];
        zn[4] = parameters[2];
      } else {
        PErrors.push( new ParseError("Error in fairness expression at " + zn[0].location[0] + ": " + zn[0].location[1] + "\n", "-- --") );
        {if (true) return expr;}
      }
// left for level checking.
//      if ( expr.isKind( N_ActionExpr ) ) {
//        PErrors.push( new ParseError("Error in fairness expression at " + zn[0].location[0] + ": " + zn[0].location[1] + ": use of an action form\n", "-- --") );
//        return expr;
//      }
    } else { // reattach FairnessHook ! unless it is tuple
// "GeneralId", "RecordComponent", "FcnAppl",
      if ( zn[1].isKind( N_GeneralId ) &&  FairnessHook != null ) {
        SyntaxTreeNode ozn[] = new SyntaxTreeNode[2];
        ozn[0] = zn[1];
        ozn[1] = FairnessHook;
        zn[1] = new SyntaxTreeNode( mn, N_OpApplication, ozn );
      } else if ( ! (zn[1].isKind( N_Tuple )|| zn[1].isKind( N_ParenExpr ) || zn[1].isKind( N_SetEnumerate )|| zn[1].isKind( N_SubsetOf )|| zn[1].isKind( N_SetOfAll )|| zn[1].isKind( N_SetOfFcns )|| zn[1].isKind( N_RcdConstructor )|| zn[1].isKind( N_SetOfRcds )|| zn[1].isKind( N_Except )|| zn[1].isKind( N_FcnConst )|| zn[1].isKind( N_ActionExpr )) ){
// "ParenExpr", "SetEnumerate", "SubsetOf", "SetOfAll", "FcnConst",
// "SetOfFcns", "RcdConstructor", "SetOfRcds", "Except",
// "Tuple", "ActionExpr"
        PErrors.push( new ParseError("Error in fairness expression at " + zn[0].location[0] + ": " + zn[0].location[1] + ": could not link arguments\n", "-- --") );
        {if (true) return zn[1];}
      }
    }
    {if (true) return new SyntaxTreeNode( mn, N_FairnessExpr, zn );}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode IfThenElse() throws ParseException {
  SyntaxTreeNode zn[] = new SyntaxTreeNode[6];
  Token t;
  bpa("IF THEN ELSE");
    t = jj_consume_token(IF);
               zn[0] = new SyntaxTreeNode(mn, t);
    zn[1] = Expression();
    t = jj_consume_token(THEN);
               zn[2] =  new SyntaxTreeNode(mn, t);
    zn[3] = Expression();
    t = jj_consume_token(ELSE);
               zn[4] =  new SyntaxTreeNode(mn, t);
    zn[5] = Expression();
    epa(); {if (true) return new SyntaxTreeNode(mn, N_IfThenElse, zn);}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode Case() throws ParseException {
  SyntaxTreeNode tn;
  Token t;
  bpa("CASE Expression");
    t = jj_consume_token(CASE);
               addHeir( new SyntaxTreeNode(mn, t) );
    tn = CaseArm();
                   addHeir( tn );
    label_44:
    while (true) {
      if (caseSep() && (getToken(2).kind != OTHER)) {
        ;
      } else {
        break label_44;
      }
      t = jj_consume_token(CASESEP);
                    addHeir( new SyntaxTreeNode(mn, t) );
      tn = CaseArm();
                     addHeir( tn );
    }
    if (caseSep()) {
      t = jj_consume_token(CASESEP);
                    addHeir( new SyntaxTreeNode(mn, t) );
      tn = OtherArm();
                      addHeir( tn );
    } else {
      ;
    }
    SyntaxTreeNode sn[] = getLastHeirs();
    epa(); {if (true) return new SyntaxTreeNode(mn, N_Case, sn);}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode CaseArm() throws ParseException {
  SyntaxTreeNode zn[] = new SyntaxTreeNode[3];
  Token t;
  bpa("Case Arm");
    zn[0] = Expression();
    t = jj_consume_token(ARROW);
                zn[1] = new SyntaxTreeNode(mn, t);
    zn[2] = Expression();
    epa(); {if (true) return new SyntaxTreeNode( mn, N_CaseArm, zn );}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode OtherArm() throws ParseException {
  SyntaxTreeNode zn[] = new SyntaxTreeNode[3];
  Token t;
  bpa("Case Other Arm");
    t = jj_consume_token(OTHER);
                zn[0] = new SyntaxTreeNode(mn, t);
    t = jj_consume_token(ARROW);
                zn[1] = new SyntaxTreeNode(mn, t);
    zn[2] = Expression();
    epa(); {if (true) return new SyntaxTreeNode( mn, N_OtherArm, zn );}
    throw new Error("Missing return statement in function");
  }

/***************************************************************************
* LetIn ::= <LET> LetDefinitions() <LETIN> Expression()                    *
*                                                                          *
* It produces a SyntaxTreeNode tn with the four heirs                      *
*    "LET", LetDefinitions, "IN", Expression                               *
* in tn.zero.                                                              *
***************************************************************************/
  final public SyntaxTreeNode LetIn() throws ParseException {
  SyntaxTreeNode zn[] = new SyntaxTreeNode[4];
  SyntaxTreeNode tn;
  Token t;
  bpa("Case Other Arm");
    t = jj_consume_token(LET);
              zn[0] = new SyntaxTreeNode(mn, t);
    zn[1] = LetDefinitions();
    t = jj_consume_token(LETIN);
                zn[2] = new SyntaxTreeNode(mn, t);
    zn[3] = Expression();
    epa(); {if (true) return new SyntaxTreeNode( mn, N_LetIn, zn );}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode LetDefinitions() throws ParseException {
  SyntaxTreeNode tn;
  Token t;
  bpa("Let Definitions");
    label_45:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LOCAL:
      case DEFBREAK:
        tn = OperatorOrFunctionDefinition();
                                            addHeir( tn );
        break;
      case RECURSIVE:
        tn = Recursive();
                         addHeir( tn );
        break;
      default:
        jj_la1[121] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LOCAL:
      case RECURSIVE:
      case DEFBREAK:
        ;
        break;
      default:
        jj_la1[122] = jj_gen;
        break label_45;
      }
    }
    SyntaxTreeNode sn[] = getLastHeirs();
    epa(); {if (true) return new SyntaxTreeNode(mn, N_LetDefinitions, sn);}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode Junctions() throws ParseException {
  BStack.newReference(getToken(1).endColumn, getToken(1).kind);
    /***********************************************************************
    * Pushes onto BStack an element of the appropriate kind with offest    *
    * equal to the column of the last character in the /\ or \/ token.     *
    ***********************************************************************/

  bpa("AND-OR Junction");
  int kind;
    if (jj_2_55(2147483647)) {
                                      kind = N_DisjList;
      DisjList();
    } else if (jj_2_56(2147483647)) {
                                       kind = N_ConjList;
      ConjList();
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
    BStack.popReference();
    SyntaxTreeNode sn[] = getLastHeirs();
    epa(); {if (true) return new SyntaxTreeNode( mn, kind, sn);}
    throw new Error("Missing return statement in function");
  }

  final public void DisjList() throws ParseException {
  SyntaxTreeNode tn;
    tn = JuncItem(N_DisjItem);
    addHeir(tn);
    label_46:
    while (true) {
      if (BStack.onReference( getToken(1).endColumn, getToken(1).kind )) {
        ;
      } else {
        break label_46;
      }
      tn = JuncItem(N_DisjItem);
                                 addHeir(tn);
    }
  }

  final public void ConjList() throws ParseException {
  SyntaxTreeNode tn;
    tn = JuncItem(N_ConjItem);
    addHeir( tn );
    label_47:
    while (true) {
      if (BStack.onReference( getToken(1).endColumn, getToken(1).kind )) {
        ;
      } else {
        break label_47;
      }
      tn = JuncItem(N_ConjItem);
                                 addHeir( tn );
    }
  }

  final public SyntaxTreeNode JuncItem(int itemKind) throws ParseException {
  SyntaxTreeNode zn[] = new SyntaxTreeNode[2];
  SyntaxTreeNode tn;
  Token t;
  bpa("Junction Item");
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OR:
      /* t = <BOR> | */ t = jj_consume_token(OR);
      break;
    case AND:
      t = jj_consume_token(AND);
      break;
    default:
      jj_la1[123] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    zn[0] = new SyntaxTreeNode(mn, t);
    zn[1] = Expression();
    epa();
    /***********************************************************************
    * Check for indentation errors.                                        *
    ***********************************************************************/
    tn = new SyntaxTreeNode( mn, itemKind, zn );
    TreeNode[] children = tn.heirs() ;
    for (int i = 1; i < children.length; i++) {
      checkIndentation((SyntaxTreeNode) children[i], tn) ;
     };
    {if (true) return tn ;}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode UnboundOrBoundChoose() throws ParseException {
  SyntaxTreeNode zn[] = new SyntaxTreeNode[5];
  SyntaxTreeNode tn;
  Token t;
  bpa("(Un)Bounded Choose");
    t = jj_consume_token(CHOOSE);
                 zn[0] = new SyntaxTreeNode(mn, t);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      zn[1] = Identifier();
      break;
    case LAB:
      zn[1] = IdentifierTuple();
      break;
    default:
      jj_la1[124] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    zn[2] = MaybeBound();
    t = jj_consume_token(COLON);
                zn[3] = new SyntaxTreeNode(mn, t);
    zn[4] = Expression();
    SyntaxTreeNode sn[] = getLastHeirs();
    epa(); {if (true) return new SyntaxTreeNode( mn, N_UnboundOrBoundChoose, zn);}
    throw new Error("Missing return statement in function");
  }

/***************************************************************************
* Lambda expression added by LL on 27 March 2007                           *
*                                                                          *
* L.Lambda ::=                                                             *
*   <LAMBDA>                                                               *
*   (IdentDecl | SomeFixDecl) (<COMMA> (IdentDecl | SomeFixDecl))*         *
*   <COLON> Expression                                                     *
***************************************************************************/
  final public SyntaxTreeNode Lambda() throws ParseException {
  SyntaxTreeNode tn;
  Token t;
  bpa("Lambda");
    t = jj_consume_token(LAMBDA);
                   addHeir(new SyntaxTreeNode(mn, t));
                   expecting = "Identifier";
    tn = Identifier();
                         addHeir( tn );
                                                 expecting = "`,' or `:'";
    label_48:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[125] = jj_gen;
        break label_48;
      }
      t = jj_consume_token(COMMA);
                     addHeir( new SyntaxTreeNode(mn, t) );
                     expecting = "Identifier";
      tn = Identifier();
                               addHeir( tn );
                               expecting = "`,' or `:'";
    }
    t = jj_consume_token(COLON);
                  addHeir( new SyntaxTreeNode(mn, t) );
                  expecting = "Expression";
    tn = Expression();
                       addHeir(tn);
                       SyntaxTreeNode sn[] = getLastHeirs();
                       epa();
                       {if (true) return new SyntaxTreeNode( mn, N_Lambda, sn);}
    throw new Error("Missing return statement in function");
  }

// boxDisc (riminate) uses preInEmptyTop
// note that junction is processed separately.
  final public SyntaxTreeNode Expression() throws ParseException {
  SyntaxTreeNode tn, tn0, tn1, tn2;
  int kind ;
  Token t;
  bpa("Expression");
  OperatorStack.newStack();
    label_49:
    while (true) {
      if (jj_2_57(2147483647) && (BStack.aboveReference( getToken(1).beginColumn))) {
        ;
      } else {
        break label_49;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case op_26:
      case op_29:
      case op_58:
      case CASESEP:
      case op_61:
      case op_112:
      case op_113:
      case op_114:
      case op_115:
      case op_116:
        tn = PrefixOp();
                      kind = N_GenPrefixOp;
        break;
      case op_1:
      case AND:
      case op_3:
      case op_4:
      case OR:
      case op_6:
      case op_7:
      case op_8:
      case op_9:
      case op_10:
      case op_11:
      case op_12:
      case op_13:
      case op_14:
      case op_15:
      case op_16:
      case op_17:
      case op_18:
      case op_19:
      case IN:
      case op_21:
      case op_22:
      case op_23:
      case op_24:
      case op_25:
      case op_27:
      case op_30:
      case op_31:
      case op_32:
      case op_33:
      case op_34:
      case op_35:
      case op_36:
      case op_37:
      case op_38:
      case op_39:
      case op_40:
      case op_41:
      case op_42:
      case op_43:
      case op_44:
      case op_45:
      case op_46:
      case op_47:
      case op_48:
      case op_49:
      case op_50:
      case op_51:
      case op_52:
      case op_53:
      case op_54:
      case op_55:
      case op_56:
      case op_59:
      case op_62:
      case op_63:
      case op_64:
      case EQUALS:
      case op_66:
      case op_67:
      case op_71:
      case op_72:
      case op_73:
      case op_74:
      case op_75:
      case op_77:
      case op_78:
      case op_79:
      case op_80:
      case op_81:
      case op_82:
      case op_83:
      case op_84:
      case op_85:
      case op_86:
      case op_87:
      case op_88:
      case op_89:
      case op_90:
      case op_91:
      case op_92:
      case op_93:
      case op_94:
      case op_95:
      case op_96:
      case op_97:
      case op_98:
      case op_100:
      case op_101:
      case op_102:
      case op_103:
      case op_104:
      case op_105:
      case op_106:
      case op_107:
      case op_108:
      case op_109:
      case op_110:
      case op_111:
      case op_117:
      case op_118:
      case op_119:
        tn = InfixOp();
                      kind = N_GenInfixOp;
        break;
      default:
        jj_la1[126] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
     SyntaxTreeNode[] heirs = new SyntaxTreeNode[2];
     heirs[0] = new SyntaxTreeNode( mn, N_IdPrefix, (SyntaxTreeNode []) null);
     heirs[1] = tn ;
     OperatorStack.pushOnStack(new SyntaxTreeNode(mn, kind, heirs), lastOp);
     if (OperatorStack.size() != 1) {OperatorStack.reduceStack();} ;
          /*****************************************************************
          * This is probably a no-op since we can't reduce the stack at    *
          * this point.                                                    *
          *****************************************************************/

    }
    if (jj_2_58(2147483647) && (BStack.aboveReference( getToken(1).beginColumn))) {
      tn = OpenExpression();
                          OperatorStack.pushOnStack( tn, null );
    } else if (BStack.aboveReference( getToken(1).beginColumn)) {
      ExtendableExpr();
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
  epa();
  tn = OperatorStack.finalReduce();
   if (tn==null) {
     {if (true) throw new ParseException(" Couldn't reduce expression stack.");}
    } ;
   OperatorStack.popStack();
   {if (true) return tn ;}
    throw new Error("Missing return statement in function");
  }

  // Expression
  final public void ExtendableExpr() throws ParseException {
  SyntaxTreeNode tn, tn0, tn1, tn2;
  SyntaxTreeNode[] heirs;
  int kind ;
  Token t;
  bpa("ExtendableExpr") ;
    if (jj_2_59(2147483647) && (OperatorStack.preInEmptyTop()
               // && BStack.aboveReference( getToken(1).beginColumn) 
    )) {
      tn = Junctions();
                      OperatorStack.pushOnStack( tn, null );
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SF:
      case WF:
      case LBR:
      case LSB:
      case LWB:
      case LBC:
      case LAB:
        /************************************************************************
           * ParenthesesExpression                                                 *
           ************************************************************************/
           tn = ParenthesesExpression();
                                  OperatorStack.pushOnStack( tn, null );
        break;
      default:
        jj_la1[127] = jj_gen;
        if (jj_2_60(1)) {
          /************************************************************************
             * PrimitiveExpression                                                 *
             ************************************************************************/
             tn = PrimitiveExp();
                         OperatorStack.pushOnStack( tn, null );
        } else {
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
    label_50:
    while (true) {
      if (jj_2_61(1)) {
        ;
      } else {
        break label_50;
      }
      if (jj_2_62(2147483647) && (BStack.aboveReference( getToken(1).beginColumn))) {
        tn = PostfixOp();
       heirs = new SyntaxTreeNode[2];
       heirs[0] =
         new SyntaxTreeNode( mn, N_IdPrefix, (SyntaxTreeNode []) null);
       heirs[1] = tn ;
       OperatorStack.pushOnStack(new SyntaxTreeNode(mn, N_GenPostfixOp, heirs),
                                 lastOp);
       if (OperatorStack.size() != 1) {OperatorStack.reduceStack();} ;
      } else if (jj_2_63(2147483647) && (BStack.aboveReference( getToken(1).beginColumn))) {
        t = jj_consume_token(DOT);
       Token next = getToken(1);
       if (isFieldNameToken( next )) next.kind = IDENTIFIER;
        if (BStack.aboveReference( getToken(1).beginColumn)) {

        } else {
          jj_consume_token(-1);
          throw new ParseException();
        }
        tn = Identifier();
         OperatorStack.reduceRecord(  new SyntaxTreeNode(mn, t) , tn );
      } else if (jj_2_64(2147483647) && (BStack.aboveReference( getToken(1).beginColumn))) {
    expecting = "function argument";
        tn = SBracketCases();
      if ( isGenOp( tn ) ) {
        /*******************************************************************
        * In the normal case, tn will be an N_FcnAppl node and             *
        * isGenOp(tn) will be true.  In an error case, isGenOp(tn) should  *
        * be false, and whatever is returned will presumably not be an     *
        * operator and pushing it on the stack will produce an error       *
        * because the stack will have two expressions with no intervening  *
        * infix operator.                                                  *
        *******************************************************************/
        OperatorStack.pushOnStack( tn, lastOp );
        if (OperatorStack.size() != 1) {OperatorStack.reduceStack();} ;
       }
      else {OperatorStack.pushOnStack( tn, null );};
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    if (jj_2_69(1)) {
      if (jj_2_67(2147483647) && (BStack.aboveReference( getToken(1).beginColumn))) {
        tn = InfixOp();
     heirs = new SyntaxTreeNode[2];
     heirs[0] = new SyntaxTreeNode( mn, N_IdPrefix, (SyntaxTreeNode []) null);
     heirs[1] = tn ;
     OperatorStack.pushOnStack(new SyntaxTreeNode(mn, N_GenInfixOp, heirs),
                               lastOp);
     if (OperatorStack.size() != 1) {OperatorStack.reduceStack();} ;
        label_51:
        while (true) {
          if (jj_2_65(2147483647) && (BStack.aboveReference( getToken(1).beginColumn))) {
            ;
          } else {
            break label_51;
          }
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case op_26:
          case op_29:
          case op_58:
          case CASESEP:
          case op_61:
          case op_112:
          case op_113:
          case op_114:
          case op_115:
          case op_116:
            tn = PrefixOp();
                        kind = N_GenPrefixOp;
            break;
          case op_1:
          case AND:
          case op_3:
          case op_4:
          case OR:
          case op_6:
          case op_7:
          case op_8:
          case op_9:
          case op_10:
          case op_11:
          case op_12:
          case op_13:
          case op_14:
          case op_15:
          case op_16:
          case op_17:
          case op_18:
          case op_19:
          case IN:
          case op_21:
          case op_22:
          case op_23:
          case op_24:
          case op_25:
          case op_27:
          case op_30:
          case op_31:
          case op_32:
          case op_33:
          case op_34:
          case op_35:
          case op_36:
          case op_37:
          case op_38:
          case op_39:
          case op_40:
          case op_41:
          case op_42:
          case op_43:
          case op_44:
          case op_45:
          case op_46:
          case op_47:
          case op_48:
          case op_49:
          case op_50:
          case op_51:
          case op_52:
          case op_53:
          case op_54:
          case op_55:
          case op_56:
          case op_59:
          case op_62:
          case op_63:
          case op_64:
          case EQUALS:
          case op_66:
          case op_67:
          case op_71:
          case op_72:
          case op_73:
          case op_74:
          case op_75:
          case op_77:
          case op_78:
          case op_79:
          case op_80:
          case op_81:
          case op_82:
          case op_83:
          case op_84:
          case op_85:
          case op_86:
          case op_87:
          case op_88:
          case op_89:
          case op_90:
          case op_91:
          case op_92:
          case op_93:
          case op_94:
          case op_95:
          case op_96:
          case op_97:
          case op_98:
          case op_100:
          case op_101:
          case op_102:
          case op_103:
          case op_104:
          case op_105:
          case op_106:
          case op_107:
          case op_108:
          case op_109:
          case op_110:
          case op_111:
          case op_117:
          case op_118:
          case op_119:
            tn = InfixOp();
                        kind = N_GenInfixOp;
            break;
          default:
            jj_la1[128] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
      heirs = new SyntaxTreeNode[2];
      heirs[0] = new SyntaxTreeNode( mn, N_IdPrefix, (SyntaxTreeNode []) null);
      heirs[1] = tn ;
      OperatorStack.pushOnStack(new SyntaxTreeNode(mn, kind, heirs), lastOp);
      if (OperatorStack.size() != 1) {OperatorStack.reduceStack();} ;
          /*****************************************************************
          * This is probably a no-op since we can't reduce the stack at    *
          * this point.                                                    *
          *****************************************************************/

        }
        if (jj_2_66(2147483647) && (BStack.aboveReference( getToken(1).beginColumn))) {
          tn = OpenExpression();
                            OperatorStack.pushOnStack( tn, null );
        } else if (BStack.aboveReference( getToken(1).beginColumn)) {
          ExtendableExpr();
        } else {
          jj_consume_token(-1);
          throw new ParseException();
        }
      } else if (jj_2_68(2147483647) && (BStack.aboveReference( getToken(1).beginColumn))) {
        t = jj_consume_token(COLONCOLON);
     tn1 = new SyntaxTreeNode(mn, t) ;
     tn0 = OperatorStack.topOfStack().getNode();
     if (! isLabel(tn0)) {
       {if (true) throw new ParseException("`::' at " + tn1.getLocation().toString()
                                 + " does not follow a label.") ;}
      } ;
     OperatorStack.popCurrentTop() ;
        // t = <COLONCOLON>
          tn2 = Expression();
      if (! labelDoesNotChangeParse(tn2, lastOp)) {
        /*****************************************************************
        * Note: if tn1 is a prefix, infix, or postfix expression, then   *
        * I believe (perhaps naively) that lastOp will be its operator.  *
        *****************************************************************/
        {if (true) throw new ParseException(
          "Removing label at " + tn0.getLocation().toString() +
          " would change expression parsing.") ;}
       } ;
      SyntaxTreeNode labelHeirs[] = {tn0, tn1, tn2} ;
      tn = new SyntaxTreeNode(N_Label, labelHeirs) ;
      OperatorStack.pushOnStack( tn, null );
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
    } else {
      ;
    }
   epa() ;
  }

  // ExtendableExpr
  final public SyntaxTreeNode PrimitiveExp() throws ParseException {
  SyntaxTreeNode tn, tn0, tn1, tn2;
  SyntaxTreeNode tnOpArgs = null ;
  SyntaxTreeNode tnBangs[] = null ;
  SyntaxTreeNode[] heirs ;
  Token t;
  bpa("Primitive expression") ;
    if (jj_2_72(2147483647) && (BStack.aboveReference( getToken(1).beginColumn))) {
      tn = String();
    } else if (jj_2_73(2147483647) && (BStack.aboveReference( getToken(1).beginColumn))) {
      tn = Number();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case op_57:
      case op_68:
      case op_69:
      case op_70:
      case op_76:
      case op_26:
      case op_29:
      case op_58:
      case CASESEP:
      case op_61:
      case op_112:
      case op_113:
      case op_114:
      case op_115:
      case op_116:
      case op_1:
      case AND:
      case op_3:
      case op_4:
      case OR:
      case op_6:
      case op_7:
      case op_8:
      case op_9:
      case op_10:
      case op_11:
      case op_12:
      case op_13:
      case op_14:
      case op_15:
      case op_16:
      case op_17:
      case op_18:
      case op_19:
      case IN:
      case op_21:
      case op_22:
      case op_23:
      case op_24:
      case op_25:
      case op_27:
      case op_30:
      case op_31:
      case op_32:
      case op_33:
      case op_34:
      case op_35:
      case op_36:
      case op_37:
      case op_38:
      case op_39:
      case op_40:
      case op_41:
      case op_42:
      case op_43:
      case op_44:
      case op_45:
      case op_46:
      case op_47:
      case op_48:
      case op_49:
      case op_50:
      case op_51:
      case op_52:
      case op_53:
      case op_54:
      case op_55:
      case op_56:
      case op_59:
      case op_62:
      case op_63:
      case op_64:
      case EQUALS:
      case op_66:
      case op_67:
      case op_71:
      case op_72:
      case op_73:
      case op_74:
      case op_75:
      case op_77:
      case op_78:
      case op_79:
      case op_80:
      case op_81:
      case op_82:
      case op_83:
      case op_84:
      case op_85:
      case op_86:
      case op_87:
      case op_88:
      case op_89:
      case op_90:
      case op_91:
      case op_92:
      case op_93:
      case op_94:
      case op_95:
      case op_96:
      case op_97:
      case op_98:
      case op_100:
      case op_101:
      case op_102:
      case op_103:
      case op_104:
      case op_105:
      case op_106:
      case op_107:
      case op_108:
      case op_109:
      case op_110:
      case op_111:
      case op_117:
      case op_118:
      case op_119:
      case IDENTIFIER:
      case ProofStepLexeme:
      case ProofImplicitStepLexeme:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENTIFIER:
          tn0 = Identifier();
          break;
        case ProofStepLexeme:
        case ProofImplicitStepLexeme:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case ProofStepLexeme:
            t = jj_consume_token(ProofStepLexeme);
            break;
          case ProofImplicitStepLexeme:
            t = jj_consume_token(ProofImplicitStepLexeme);
            break;
          default:
            jj_la1[129] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
                  tn0 = new SyntaxTreeNode(mn, t);
                  if ((getProofLevel() < 0) && (proofDepth <= 0)) {
                    {if (true) throw new
                      ParseException(tn0.getLocation().toString() +
                           ": Step number used outside proof.");}
                    } ;
                  if (t.image.substring(1,2).equals("+")) {
                    {if (true) throw new ParseException(tn0.getLocation().toString() +
                           ": <+> step number used in an expression.");}
                    } ;
                  if (t.kind == ProofImplicitStepLexeme) {
                    tn0.originalImage = tn0.image ;
                    tn0.image = correctedStepNum(t) ;
                   } ;

// ToolIO.out.println("xyz-expr: t.image = " + t.image + 
// ", correctedImage = " + tn0.image) ;

          break;
        case op_1:
        case AND:
        case op_3:
        case op_4:
        case OR:
        case op_6:
        case op_7:
        case op_8:
        case op_9:
        case op_10:
        case op_11:
        case op_12:
        case op_13:
        case op_14:
        case op_15:
        case op_16:
        case op_17:
        case op_18:
        case op_19:
        case IN:
        case op_21:
        case op_22:
        case op_23:
        case op_24:
        case op_25:
        case op_27:
        case op_30:
        case op_31:
        case op_32:
        case op_33:
        case op_34:
        case op_35:
        case op_36:
        case op_37:
        case op_38:
        case op_39:
        case op_40:
        case op_41:
        case op_42:
        case op_43:
        case op_44:
        case op_45:
        case op_46:
        case op_47:
        case op_48:
        case op_49:
        case op_50:
        case op_51:
        case op_52:
        case op_53:
        case op_54:
        case op_55:
        case op_56:
        case op_59:
        case op_62:
        case op_63:
        case op_64:
        case EQUALS:
        case op_66:
        case op_67:
        case op_71:
        case op_72:
        case op_73:
        case op_74:
        case op_75:
        case op_77:
        case op_78:
        case op_79:
        case op_80:
        case op_81:
        case op_82:
        case op_83:
        case op_84:
        case op_85:
        case op_86:
        case op_87:
        case op_88:
        case op_89:
        case op_90:
        case op_91:
        case op_92:
        case op_93:
        case op_94:
        case op_95:
        case op_96:
        case op_97:
        case op_98:
        case op_100:
        case op_101:
        case op_102:
        case op_103:
        case op_104:
        case op_105:
        case op_106:
        case op_107:
        case op_108:
        case op_109:
        case op_110:
        case op_111:
        case op_117:
        case op_118:
        case op_119:
          tn0 = InfixOp();
          break;
        case op_57:
        case op_68:
        case op_69:
        case op_70:
          tn0 = PostfixOp();
          break;
        default:
          jj_la1[130] = jj_gen;
          if (jj_2_70(2147483647)) {
            tn0 = NonExpPrefixOp();
          } else {
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
        if (jj_2_71(2)) {
          tnOpArgs = OpArgs();
        } else {
          ;
        }
        label_52:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case BANG:
            ;
            break;
          default:
            jj_la1[131] = jj_gen;
            break label_52;
          }
          tn1 = BangExt();
                          addHeir(tn1) ;
        }
        tnBangs = getLastHeirs() ;
        if (tnBangs == null) {
          heirs = new SyntaxTreeNode[2];
          heirs[0] = new SyntaxTreeNode( mn, N_IdPrefix,
                                         new SyntaxTreeNode[0]);
          heirs[1] = tn0;
          tn1 = new SyntaxTreeNode(mn, N_GeneralId, heirs) ;
          if (tnOpArgs == null) {tn = tn1;}
          else { heirs    = new SyntaxTreeNode[2];
                 heirs[0] = tn1 ;
                 heirs[1] = tnOpArgs ;
                 tn = new SyntaxTreeNode(mn, N_OpApplication, heirs) ;
           }
         } // if (tnBangs == null)
        else {
         /******************************************************************
         * There is a BangExt.  The parse tree constructed so far needs    *
         * to be rearranged to be what is expected of the parser           *
         * (because the parser was designed for TLA+1).  For example, if   *
         * we're parsing                                                   *
         *                                                                 *
         *   foo(1)!b!c(2,3), so far we have                               *
         *   tn0 = foo                                                     *
         *   tnOpArgs = OpArgs[1]                                          *
         *   tnBangs = IdPrefixElement[! b]                                *
         *             IdPrefixElement[! c OpArgs[2, 3]]                   *
         *                                                                 *
         * and we must turn that into                                      *
         *                                                                 *
         *   OpAppl[ GeneralId[ IdPrefix[IdPrefixElement[foo OpArgs[1] !]  *
         *                               IdPrefixElement[b !]]             *
         *                      c]                                         *
         *           OpArgs[2, 3]]                                         *
         *                                                                 *
         * Note that the result is an OpAppl node iff the last             *
         * IdPrefixElement contains an OpArg heir, otherwise it is a       *
         * GeneralId node.                                                 *
         ******************************************************************/

         /******************************************************************
         * We set heirs to the array of IdPrefixElement nodes that are     *
         * the heirs of the IdPrefix node that is the first heir of the    *
         * GeneralId node.                                                 *
         ******************************************************************/
         heirs = new SyntaxTreeNode[tnBangs.length] ;

         /******************************************************************
         * Set eltHeirs to the heirs of heirs[0].                          *
         ******************************************************************/
         SyntaxTreeNode[] eltHeirs;
         if (tnOpArgs == null) {
            eltHeirs = new SyntaxTreeNode[2] ;
            eltHeirs[0] = tn0 ;
            eltHeirs[1] = (SyntaxTreeNode) tnBangs[0].heirs()[0] ;
          }
         else {
            eltHeirs = new SyntaxTreeNode[3] ;
            eltHeirs[0] = tn0 ;
            eltHeirs[1] = tnOpArgs;
            eltHeirs[2] = (SyntaxTreeNode) tnBangs[0].heirs()[0] ;
          } ;
         heirs[0] =
           new SyntaxTreeNode(mn, N_IdPrefixElement, eltHeirs);
         for (int i = 0; i < tnBangs.length - 1; i++) {
           eltHeirs =
              new SyntaxTreeNode[tnBangs[i].heirs().length] ;
           for (int j = 0 ; j < eltHeirs.length-1; j++) {
             eltHeirs[j] = (SyntaxTreeNode) tnBangs[i].heirs()[j+1];
             } ;
           eltHeirs[eltHeirs.length-1] = (SyntaxTreeNode)
                                            tnBangs[i+1].heirs()[0];
           heirs[i+1] = new SyntaxTreeNode(mn, N_IdPrefixElement, eltHeirs);
          } // for
         TreeNode[] lastBang = tnBangs[tnBangs.length-1].heirs() ;
         SyntaxTreeNode[] genIdHeirs = new SyntaxTreeNode[2] ;
         genIdHeirs[0] = new SyntaxTreeNode(mn, N_IdPrefix, heirs) ;
         genIdHeirs[1] = (SyntaxTreeNode) lastBang[1];
         SyntaxTreeNode genId =
             new SyntaxTreeNode(mn, N_GeneralId, genIdHeirs) ;
         if (lastBang.length == 2) {tn = genId;}
         else { heirs = new SyntaxTreeNode[2] ;
                heirs[0] = genId ;
                heirs[1] = (SyntaxTreeNode) lastBang[2] ;
                tn = new SyntaxTreeNode(mn, N_OpApplication, heirs) ;
          } // else       
      } // else

        break;
      default:
        jj_la1[132] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    epa() ;
    {if (true) return tn;}
    throw new Error("Missing return statement in function");
  }

  // PrimitiveExp
  final public SyntaxTreeNode BangExt() throws ParseException {
  /*************************************************************************
  * Returns an N_IdPrefixElement node with 2 or 3 heirs consisting of:     *
  *  - A "!" (<BANG>) token.                                               *
  *  - An Identifier(), PrefixOp(), InfixOp(), or PostfixOp() node.        *
  *  - An optional OpArgs() node.                                          *
  * Note that this is not the kind of N_IdPrefixElement that the parser    *
  * ultimately produces, which ends with a "!" rather than beginning with  *
  * one.                                                                   *
  *************************************************************************/
  SyntaxTreeNode tn ;
  Token t;
  bpa("Bang Extension") ;
    t = jj_consume_token(BANG);
                addHeir(new SyntaxTreeNode(mn, t)) ;
    if (jj_2_76(1)) {
      if (jj_2_74(2147483647) && (!getToken(1).image.equals("@"))) {
        tn = Identifier();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case op_76:
        case op_26:
        case op_29:
        case op_58:
        case CASESEP:
        case op_61:
        case op_112:
        case op_113:
        case op_114:
        case op_115:
        case op_116:
          tn = NonExpPrefixOp();
          break;
        case op_1:
        case AND:
        case op_3:
        case op_4:
        case OR:
        case op_6:
        case op_7:
        case op_8:
        case op_9:
        case op_10:
        case op_11:
        case op_12:
        case op_13:
        case op_14:
        case op_15:
        case op_16:
        case op_17:
        case op_18:
        case op_19:
        case IN:
        case op_21:
        case op_22:
        case op_23:
        case op_24:
        case op_25:
        case op_27:
        case op_30:
        case op_31:
        case op_32:
        case op_33:
        case op_34:
        case op_35:
        case op_36:
        case op_37:
        case op_38:
        case op_39:
        case op_40:
        case op_41:
        case op_42:
        case op_43:
        case op_44:
        case op_45:
        case op_46:
        case op_47:
        case op_48:
        case op_49:
        case op_50:
        case op_51:
        case op_52:
        case op_53:
        case op_54:
        case op_55:
        case op_56:
        case op_59:
        case op_62:
        case op_63:
        case op_64:
        case EQUALS:
        case op_66:
        case op_67:
        case op_71:
        case op_72:
        case op_73:
        case op_74:
        case op_75:
        case op_77:
        case op_78:
        case op_79:
        case op_80:
        case op_81:
        case op_82:
        case op_83:
        case op_84:
        case op_85:
        case op_86:
        case op_87:
        case op_88:
        case op_89:
        case op_90:
        case op_91:
        case op_92:
        case op_93:
        case op_94:
        case op_95:
        case op_96:
        case op_97:
        case op_98:
        case op_100:
        case op_101:
        case op_102:
        case op_103:
        case op_104:
        case op_105:
        case op_106:
        case op_107:
        case op_108:
        case op_109:
        case op_110:
        case op_111:
        case op_117:
        case op_118:
        case op_119:
          tn = InfixOp();
          break;
        case op_57:
        case op_68:
        case op_69:
        case op_70:
          tn = PostfixOp();
          break;
        default:
          jj_la1[133] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      addHeir(tn);
      if (jj_2_75(2)) {
        tn = OpArgs();
                      addHeir(tn) ;
      } else {
        ;
      }
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBR:
        tn = OpArgs();
                      addHeir(tn) ;
        break;
      default:
        jj_la1[134] = jj_gen;
        if (jj_2_77(1)) {
          tn = StructOp();
                      addHeir(tn) ;
        } else {
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
    tn = new SyntaxTreeNode(mn, N_IdPrefixElement, getLastHeirs());
    epa();
    {if (true) return tn ;}
    throw new Error("Missing return statement in function");
  }

  // BangExt
  final public SyntaxTreeNode StructOp() throws ParseException {
  SyntaxTreeNode tn = null ;
  Token t = null;
  bpa("StructOp");
  expecting = "`<<' , `>>' , `:' , `@' , or number" ;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LAB:
      t = jj_consume_token(LAB);
      break;
    case RAB:
      t = jj_consume_token(RAB);
      break;
    case COLON:
      t = jj_consume_token(COLON);
      break;
    case NUMBER_LITERAL:
      tn = Number();
      break;
    default:
      jj_la1[135] = jj_gen;
      if (getToken(1).image.equals("@")) {
        t = jj_consume_token(IDENTIFIER);
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
   epa() ;
   if (tn == null){{if (true) return new SyntaxTreeNode(mn, N_StructOp, t) ;} }
     else { if (tn.getKind() == N_Real) {
              {if (true) throw new ParseException(
                         "Illegal structural term at " +
                          tn.getLocation().toString());}
             };
           SyntaxTreeNode[] heirs = new SyntaxTreeNode[1] ;
           heirs[0] = tn;
           {if (true) return new SyntaxTreeNode(mn, N_StructOp, heirs) ;} } ;
    throw new Error("Missing return statement in function");
  }

// SyntaxTreeNode
// oldExpression() : {
//   /*************************************************************************
//   * The basic production is                                                *
//   *                                                                        *
//   *    Expression ::= (  OpenExpression                                    *
//   *                     | (Junctions                                       *
//   *                         | ClosedExpressionOrOp                         *
//   *                         | <DOT> Identifier                             *
//   *                         | <COLONCOLON> Expression                      *
//   *                        )+                                              *
//   *                        ( OpenExpression )?                             *
//   *                   )                                                    *
//   *************************************************************************/
//   SyntaxTreeNode tn, tn0, tn1, tn2;
//   Token t;
//   OperatorStack.newStack();
// } { 
// ( 
//  LOOKAHEAD(OpenStart(), {BStack.aboveReference( getToken(1).beginColumn) } )
//    tn = OpenExpression() { OperatorStack.pushOnStack( tn, null ); }
// |   (  LOOKAHEAD( /* <BAND> | <BOR> | */ <AND> | <OR>, 
// // ^^^ 
// // Warning 4 -- Eliminated in SANY2
//          { OperatorStack.preInEmptyTop() && 
//            BStack.aboveReference( getToken(1).beginColumn) } )
//        tn = Junctions() { OperatorStack.pushOnStack( tn, null ); }
//      | LOOKAHEAD( {    ClosedStart(getToken(1)) 
//                    && boxDisc()  
//                         /***************************************************
//                        * \equiv                                            *
//                        *   (token is "[]" => it's the temporal operator)   *
//                         ***************************************************/
//                    && BStack.aboveReference( 
//                                 getToken(1).beginColumn) })
//        tn = ClosedExpressionOrOp() {
//           anchor = tn; // XXX is this correct ? Why had it disappered ? 
//                        // This is the only place where anchor is set it seems.
//           /*****************************************************************
//           * If tn is an operator, push it on the stack and, if it's not    *
//           * the only thing on the stack, then reduce the stack.            *
//           * Otherwise, just push it on the stack.                          *
//           *****************************************************************/
//           if ( isGenOp( tn ) ) {
//             OperatorStack.pushOnStack( tn, lastOp );
//             if (OperatorStack.size() != 1)
//               OperatorStack.reduceStack();
// // else
// // ToolIO.out.println("size of 1");
//           } else OperatorStack.pushOnStack( tn, null );
//         }
//      | 
//        t = <DOT> { 
//         Token next = getToken(1);
//         if (isFieldNameToken( next )) next.kind = IDENTIFIER;
//        }
//        tn = Identifier()
//        { OperatorStack.reduceRecord(  new SyntaxTreeNode(mn, t) , tn ); }
//      |
//        t = <COLONCOLON> {
//         tn1 = new SyntaxTreeNode(mn, t) ;
//         tn0 = OperatorStack.topOfStack().getNode();
//         if (! isLabel(tn0)) {
//           throw new ParseException("`::' at " + tn1.getLocation().toString()
//                                     + " does not follow a label.") ;
//          } ;
//         OperatorStack.popCurrentTop() ;
//        } // t = <COLONCOLON>
//        tn2 = Expression() {
// // String str = "null" ;
// // if (lastOp != null) { str = lastOp.toString(); } ;
// // ToolIO.out.println("lastOp after parsing labeled expression is: " + str);
//         if (! labelDoesNotChangeParse(tn2, lastOp)) {
//           /*****************************************************************
//           * Note: if tn1 is a prefix, infix, or postfix expression, then   *
//           * I believe (perhaps naively) that lastOp will be its operator.  *
//           *****************************************************************/
//           throw new ParseException(
//              "Removing label at " + tn0.getLocation().toString() +
//              " would change expression parsing.") ;
//           } ;
//         SyntaxTreeNode labelHeirs[] = {tn0, tn1, tn2} ;
//         tn = new SyntaxTreeNode(N_Label, labelHeirs) ;
//         OperatorStack.pushOnStack( tn, null );
//       }
//   )+
//   [ LOOKAHEAD( OpenStart(), {BStack.aboveReference( getToken(1).beginColumn) } )
//     tn = OpenExpression() { OperatorStack.pushOnStack( tn, null ); } ]
// )
//  { tn = OperatorStack.finalReduce();
//    if (tn==null) throw new ParseException( " Couldn't reduce expression stack.");
//    OperatorStack.popStack();
//    return tn; }
// } // Expression()

/* Obsolete
void
ClosedStart() : {
}{
  <IDENTIFIER> | <STRING_LITERAL> | <NUMBER_LITERAL> | <LBR> | <LSB> | <LAB> | <LBC> | <LWB> | <OpSymbol> | <OR> | <AND> | <WF> | <SF>
}
*/
  final public void OpenStart() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CASE:
      jj_consume_token(CASE);
      break;
    case CHOOSE:
      jj_consume_token(CHOOSE);
      break;
    case EXISTS:
      jj_consume_token(EXISTS);
      break;
    case FORALL:
      jj_consume_token(FORALL);
      break;
    case IF:
      jj_consume_token(IF);
      break;
    case LET:
      jj_consume_token(LET);
      break;
    case T_EXISTS:
      jj_consume_token(T_EXISTS);
      break;
    case T_FORALL:
      jj_consume_token(T_FORALL);
      break;
    default:
      jj_la1[136] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  final private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  final private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  final private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  final private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  final private boolean jj_2_6(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_6(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(5, xla); }
  }

  final private boolean jj_2_7(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_7(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(6, xla); }
  }

  final private boolean jj_2_8(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_8(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(7, xla); }
  }

  final private boolean jj_2_9(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_9(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(8, xla); }
  }

  final private boolean jj_2_10(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_10(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(9, xla); }
  }

  final private boolean jj_2_11(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_11(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(10, xla); }
  }

  final private boolean jj_2_12(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_12(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(11, xla); }
  }

  final private boolean jj_2_13(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_13(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(12, xla); }
  }

  final private boolean jj_2_14(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_14(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(13, xla); }
  }

  final private boolean jj_2_15(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_15(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(14, xla); }
  }

  final private boolean jj_2_16(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_16(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(15, xla); }
  }

  final private boolean jj_2_17(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_17(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(16, xla); }
  }

  final private boolean jj_2_18(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_18(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(17, xla); }
  }

  final private boolean jj_2_19(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_19(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(18, xla); }
  }

  final private boolean jj_2_20(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_20(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(19, xla); }
  }

  final private boolean jj_2_21(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_21(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(20, xla); }
  }

  final private boolean jj_2_22(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_22(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(21, xla); }
  }

  final private boolean jj_2_23(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_23(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(22, xla); }
  }

  final private boolean jj_2_24(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_24(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(23, xla); }
  }

  final private boolean jj_2_25(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_25(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(24, xla); }
  }

  final private boolean jj_2_26(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_26(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(25, xla); }
  }

  final private boolean jj_2_27(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_27(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(26, xla); }
  }

  final private boolean jj_2_28(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_28(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(27, xla); }
  }

  final private boolean jj_2_29(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_29(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(28, xla); }
  }

  final private boolean jj_2_30(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_30(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(29, xla); }
  }

  final private boolean jj_2_31(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_31(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(30, xla); }
  }

  final private boolean jj_2_32(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_32(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(31, xla); }
  }

  final private boolean jj_2_33(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_33(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(32, xla); }
  }

  final private boolean jj_2_34(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_34(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(33, xla); }
  }

  final private boolean jj_2_35(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_35(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(34, xla); }
  }

  final private boolean jj_2_36(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_36(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(35, xla); }
  }

  final private boolean jj_2_37(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_37(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(36, xla); }
  }

  final private boolean jj_2_38(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_38(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(37, xla); }
  }

  final private boolean jj_2_39(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_39(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(38, xla); }
  }

  final private boolean jj_2_40(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_40(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(39, xla); }
  }

  final private boolean jj_2_41(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_41(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(40, xla); }
  }

  final private boolean jj_2_42(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_42(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(41, xla); }
  }

  final private boolean jj_2_43(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_43(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(42, xla); }
  }

  final private boolean jj_2_44(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_44(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(43, xla); }
  }

  final private boolean jj_2_45(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_45(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(44, xla); }
  }

  final private boolean jj_2_46(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_46(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(45, xla); }
  }

  final private boolean jj_2_47(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_47(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(46, xla); }
  }

  final private boolean jj_2_48(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_48(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(47, xla); }
  }

  final private boolean jj_2_49(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_49(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(48, xla); }
  }

  final private boolean jj_2_50(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_50(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(49, xla); }
  }

  final private boolean jj_2_51(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_51(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(50, xla); }
  }

  final private boolean jj_2_52(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_52(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(51, xla); }
  }

  final private boolean jj_2_53(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_53(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(52, xla); }
  }

  final private boolean jj_2_54(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_54(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(53, xla); }
  }

  final private boolean jj_2_55(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_55(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(54, xla); }
  }

  final private boolean jj_2_56(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_56(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(55, xla); }
  }

  final private boolean jj_2_57(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_57(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(56, xla); }
  }

  final private boolean jj_2_58(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_58(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(57, xla); }
  }

  final private boolean jj_2_59(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_59(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(58, xla); }
  }

  final private boolean jj_2_60(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_60(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(59, xla); }
  }

  final private boolean jj_2_61(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_61(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(60, xla); }
  }

  final private boolean jj_2_62(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_62(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(61, xla); }
  }

  final private boolean jj_2_63(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_63(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(62, xla); }
  }

  final private boolean jj_2_64(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_64(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(63, xla); }
  }

  final private boolean jj_2_65(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_65(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(64, xla); }
  }

  final private boolean jj_2_66(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_66(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(65, xla); }
  }

  final private boolean jj_2_67(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_67(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(66, xla); }
  }

  final private boolean jj_2_68(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_68(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(67, xla); }
  }

  final private boolean jj_2_69(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_69(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(68, xla); }
  }

  final private boolean jj_2_70(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_70(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(69, xla); }
  }

  final private boolean jj_2_71(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_71(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(70, xla); }
  }

  final private boolean jj_2_72(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_72(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(71, xla); }
  }

  final private boolean jj_2_73(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_73(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(72, xla); }
  }

  final private boolean jj_2_74(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_74(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(73, xla); }
  }

  final private boolean jj_2_75(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_75(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(74, xla); }
  }

  final private boolean jj_2_76(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_76(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(75, xla); }
  }

  final private boolean jj_2_77(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_77(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(76, xla); }
  }

  final private boolean jj_3R_94() {
    if (jj_3R_63()) return true;
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_230()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_293()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_292() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_63()) return true;
    return false;
  }

  final private boolean jj_3R_93() {
    if (jj_3R_63()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_292()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3_15() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(93)) jj_scanpos = xsp;
    if (jj_3R_67()) return true;
    if (jj_scan_token(DEF)) return true;
    return false;
  }

  final private boolean jj_3R_312() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_63()) return true;
    return false;
  }

  final private boolean jj_3R_61() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(39)) {
    jj_scanpos = xsp;
    if (jj_scan_token(38)) return true;
    }
    xsp = jj_scanpos;
    if (jj_3_15()) jj_scanpos = xsp;
    if (jj_3R_63()) return true;
    return false;
  }

  final private boolean jj_3R_304() {
    Token xsp;
    if (jj_3R_312()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_312()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3_68() {
    if (jj_scan_token(COLONCOLON)) return true;
    return false;
  }

  final private boolean jj_3R_303() {
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_63()) return true;
    return false;
  }

  final private boolean jj_3R_291() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_303()) {
    jj_scanpos = xsp;
    if (jj_3R_304()) return true;
    }
    return false;
  }

  final private boolean jj_3R_84() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  final private boolean jj_3_66() {
    if (jj_3R_97()) return true;
    return false;
  }

  final private boolean jj_3R_67() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  final private boolean jj_3R_106() {
    if (jj_scan_token(COLONCOLON)) return true;
    if (jj_3R_63()) return true;
    return false;
  }

  final private boolean jj_3R_148() {
    if (jj_3R_67()) return true;
    return false;
  }

  final private boolean jj_3R_261() {
    if (jj_3R_169()) return true;
    return false;
  }

  final private boolean jj_3R_260() {
    if (jj_3R_168()) return true;
    return false;
  }

  final private boolean jj_3R_102() {
    if (jj_3R_64()) return true;
    return false;
  }

  final private boolean jj_3_37() {
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_84()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(COLON)) return true;
    return false;
  }

  final private boolean jj_3R_103() {
    if (jj_3R_150()) return true;
    return false;
  }

  final private boolean jj_3_65() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_103()) {
    jj_scanpos = xsp;
    if (jj_scan_token(192)) return true;
    }
    return false;
  }

  final private boolean jj_3R_104() {
    if (jj_3R_65()) return true;
    return false;
  }

  final private boolean jj_3R_267() {
    if (jj_3R_104()) return true;
    return false;
  }

  final private boolean jj_3R_266() {
    if (jj_3R_182()) return true;
    return false;
  }

  final private boolean jj_3_67() {
    if (jj_3R_104()) return true;
    return false;
  }

  final private boolean jj_3R_259() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_266()) {
    jj_scanpos = xsp;
    if (jj_3R_267()) return true;
    }
    return false;
  }

  final private boolean jj_3R_147() {
    if (jj_3R_146()) return true;
    return false;
  }

  final private boolean jj_3R_155() {
    if (jj_3R_145()) return true;
    return false;
  }

  final private boolean jj_3R_92() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_147()) {
    jj_scanpos = xsp;
    if (jj_3R_148()) return true;
    }
    if (jj_scan_token(IN)) return true;
    if (jj_3R_63()) return true;
    xsp = jj_scanpos;
    if (jj_3R_291()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3_48() {
    Token xsp;
    xsp = jj_scanpos;
    lookingAhead = true;
    jj_semLA = matchFcnConst();
    lookingAhead = false;
    if (!jj_semLA || jj_3R_92()) {
    jj_scanpos = xsp;
    if (jj_3R_93()) {
    jj_scanpos = xsp;
    if (jj_3R_94()) {
    jj_scanpos = xsp;
    if (jj_3_47()) return true;
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_218() {
    if (jj_scan_token(LBC)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_48()) jj_scanpos = xsp;
    if (jj_scan_token(RBC)) return true;
    return false;
  }

  final private boolean jj_3R_105() {
    if (jj_3R_104()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_259()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    lookingAhead = true;
    jj_semLA = BStack.aboveReference( getToken(1).beginColumn);
    lookingAhead = false;
    if (!jj_semLA || jj_3R_260()) {
    jj_scanpos = xsp;
    lookingAhead = true;
    jj_semLA = BStack.aboveReference( getToken(1).beginColumn);
    lookingAhead = false;
    if (!jj_semLA || jj_3R_261()) return true;
    }
    return false;
  }

  final private boolean jj_3_69() {
    Token xsp;
    xsp = jj_scanpos;
    lookingAhead = true;
    jj_semLA = BStack.aboveReference( getToken(1).beginColumn);
    lookingAhead = false;
    if (!jj_semLA || jj_3R_105()) {
    jj_scanpos = xsp;
    lookingAhead = true;
    jj_semLA = BStack.aboveReference( getToken(1).beginColumn);
    lookingAhead = false;
    if (!jj_semLA || jj_3R_106()) return true;
    }
    return false;
  }

  final private boolean jj_3R_182() {
    if (jj_3R_150()) return true;
    return false;
  }

  final private boolean jj_3R_65() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(127)) {
    jj_scanpos = xsp;
    if (jj_scan_token(128)) {
    jj_scanpos = xsp;
    if (jj_scan_token(129)) {
    jj_scanpos = xsp;
    if (jj_scan_token(130)) {
    jj_scanpos = xsp;
    if (jj_scan_token(131)) {
    jj_scanpos = xsp;
    if (jj_scan_token(132)) {
    jj_scanpos = xsp;
    if (jj_scan_token(133)) {
    jj_scanpos = xsp;
    if (jj_scan_token(134)) {
    jj_scanpos = xsp;
    if (jj_scan_token(135)) {
    jj_scanpos = xsp;
    if (jj_scan_token(136)) {
    jj_scanpos = xsp;
    if (jj_scan_token(137)) {
    jj_scanpos = xsp;
    if (jj_scan_token(138)) {
    jj_scanpos = xsp;
    if (jj_scan_token(139)) {
    jj_scanpos = xsp;
    if (jj_scan_token(140)) {
    jj_scanpos = xsp;
    if (jj_scan_token(141)) {
    jj_scanpos = xsp;
    if (jj_scan_token(142)) {
    jj_scanpos = xsp;
    if (jj_scan_token(143)) {
    jj_scanpos = xsp;
    if (jj_scan_token(144)) {
    jj_scanpos = xsp;
    if (jj_scan_token(145)) {
    jj_scanpos = xsp;
    if (jj_scan_token(146)) {
    jj_scanpos = xsp;
    if (jj_scan_token(147)) {
    jj_scanpos = xsp;
    if (jj_scan_token(148)) {
    jj_scanpos = xsp;
    if (jj_scan_token(149)) {
    jj_scanpos = xsp;
    if (jj_scan_token(150)) {
    jj_scanpos = xsp;
    if (jj_scan_token(151)) {
    jj_scanpos = xsp;
    if (jj_scan_token(152)) {
    jj_scanpos = xsp;
    if (jj_scan_token(153)) {
    jj_scanpos = xsp;
    if (jj_scan_token(154)) {
    jj_scanpos = xsp;
    if (jj_scan_token(155)) {
    jj_scanpos = xsp;
    if (jj_scan_token(156)) {
    jj_scanpos = xsp;
    if (jj_scan_token(157)) {
    jj_scanpos = xsp;
    if (jj_scan_token(158)) {
    jj_scanpos = xsp;
    if (jj_scan_token(159)) {
    jj_scanpos = xsp;
    if (jj_scan_token(160)) {
    jj_scanpos = xsp;
    if (jj_scan_token(161)) {
    jj_scanpos = xsp;
    if (jj_scan_token(162)) {
    jj_scanpos = xsp;
    if (jj_scan_token(163)) {
    jj_scanpos = xsp;
    if (jj_scan_token(164)) {
    jj_scanpos = xsp;
    if (jj_scan_token(165)) {
    jj_scanpos = xsp;
    if (jj_scan_token(166)) {
    jj_scanpos = xsp;
    if (jj_scan_token(167)) {
    jj_scanpos = xsp;
    if (jj_scan_token(168)) {
    jj_scanpos = xsp;
    if (jj_scan_token(169)) {
    jj_scanpos = xsp;
    if (jj_scan_token(170)) {
    jj_scanpos = xsp;
    if (jj_scan_token(171)) {
    jj_scanpos = xsp;
    if (jj_scan_token(172)) {
    jj_scanpos = xsp;
    if (jj_scan_token(173)) {
    jj_scanpos = xsp;
    if (jj_scan_token(174)) {
    jj_scanpos = xsp;
    if (jj_scan_token(175)) {
    jj_scanpos = xsp;
    if (jj_scan_token(176)) {
    jj_scanpos = xsp;
    if (jj_scan_token(177)) {
    jj_scanpos = xsp;
    if (jj_scan_token(178)) {
    jj_scanpos = xsp;
    if (jj_scan_token(179)) {
    jj_scanpos = xsp;
    if (jj_scan_token(180)) {
    jj_scanpos = xsp;
    if (jj_scan_token(181)) {
    jj_scanpos = xsp;
    if (jj_scan_token(182)) {
    jj_scanpos = xsp;
    if (jj_scan_token(183)) {
    jj_scanpos = xsp;
    if (jj_scan_token(184)) {
    jj_scanpos = xsp;
    if (jj_scan_token(185)) {
    jj_scanpos = xsp;
    if (jj_scan_token(186)) {
    jj_scanpos = xsp;
    if (jj_scan_token(187)) {
    jj_scanpos = xsp;
    if (jj_scan_token(188)) {
    jj_scanpos = xsp;
    if (jj_scan_token(189)) {
    jj_scanpos = xsp;
    if (jj_scan_token(190)) {
    jj_scanpos = xsp;
    if (jj_scan_token(191)) {
    jj_scanpos = xsp;
    if (jj_scan_token(192)) {
    jj_scanpos = xsp;
    if (jj_scan_token(193)) {
    jj_scanpos = xsp;
    if (jj_scan_token(194)) {
    jj_scanpos = xsp;
    if (jj_scan_token(195)) {
    jj_scanpos = xsp;
    if (jj_scan_token(196)) {
    jj_scanpos = xsp;
    if (jj_scan_token(197)) {
    jj_scanpos = xsp;
    if (jj_scan_token(198)) {
    jj_scanpos = xsp;
    if (jj_scan_token(199)) {
    jj_scanpos = xsp;
    if (jj_scan_token(200)) {
    jj_scanpos = xsp;
    if (jj_scan_token(201)) {
    jj_scanpos = xsp;
    if (jj_scan_token(202)) {
    jj_scanpos = xsp;
    if (jj_scan_token(203)) {
    jj_scanpos = xsp;
    if (jj_scan_token(204)) {
    jj_scanpos = xsp;
    if (jj_scan_token(205)) {
    jj_scanpos = xsp;
    if (jj_scan_token(206)) {
    jj_scanpos = xsp;
    if (jj_scan_token(207)) {
    jj_scanpos = xsp;
    if (jj_scan_token(208)) {
    jj_scanpos = xsp;
    if (jj_scan_token(209)) {
    jj_scanpos = xsp;
    if (jj_scan_token(210)) {
    jj_scanpos = xsp;
    if (jj_scan_token(211)) {
    jj_scanpos = xsp;
    if (jj_scan_token(212)) {
    jj_scanpos = xsp;
    if (jj_scan_token(213)) {
    jj_scanpos = xsp;
    if (jj_scan_token(214)) {
    jj_scanpos = xsp;
    if (jj_scan_token(215)) {
    jj_scanpos = xsp;
    if (jj_scan_token(216)) {
    jj_scanpos = xsp;
    if (jj_scan_token(217)) {
    jj_scanpos = xsp;
    if (jj_scan_token(218)) {
    jj_scanpos = xsp;
    if (jj_scan_token(219)) {
    jj_scanpos = xsp;
    if (jj_scan_token(220)) {
    jj_scanpos = xsp;
    if (jj_scan_token(221)) {
    jj_scanpos = xsp;
    if (jj_scan_token(222)) {
    jj_scanpos = xsp;
    if (jj_scan_token(223)) {
    jj_scanpos = xsp;
    if (jj_scan_token(224)) {
    jj_scanpos = xsp;
    if (jj_scan_token(225)) {
    jj_scanpos = xsp;
    if (jj_scan_token(226)) {
    jj_scanpos = xsp;
    if (jj_scan_token(227)) {
    jj_scanpos = xsp;
    if (jj_scan_token(228)) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3_64() {
    if (jj_scan_token(LSB)) return true;
    return false;
  }

  final private boolean jj_3R_280() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_67()) return true;
    return false;
  }

  final private boolean jj_3_13() {
    if (jj_scan_token(op_76)) return true;
    return false;
  }

  final private boolean jj_3_63() {
    if (jj_scan_token(DOT)) return true;
    return false;
  }

  final private boolean jj_3R_143() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  final private boolean jj_3R_145() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(117)) {
    jj_scanpos = xsp;
    if (jj_scan_token(118)) {
    jj_scanpos = xsp;
    if (jj_scan_token(119)) {
    jj_scanpos = xsp;
    if (jj_scan_token(120)) {
    jj_scanpos = xsp;
    if (jj_scan_token(121)) {
    jj_scanpos = xsp;
    if (jj_scan_token(116)) {
    jj_scanpos = xsp;
    if (jj_scan_token(122)) {
    jj_scanpos = xsp;
    if (jj_scan_token(123)) {
    jj_scanpos = xsp;
    if (jj_scan_token(124)) {
    jj_scanpos = xsp;
    if (jj_scan_token(125)) {
    jj_scanpos = xsp;
    if (jj_scan_token(126)) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_101() {
    if (jj_3R_154()) return true;
    return false;
  }

  final private boolean jj_3R_258() {
    return false;
  }

  final private boolean jj_3R_234() {
    if (jj_3R_67()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_280()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3_14() {
    if (jj_3R_63()) return true;
    return false;
  }

  final private boolean jj_3R_233() {
    if (jj_3R_146()) return true;
    return false;
  }

  final private boolean jj_3R_230() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_233()) {
    jj_scanpos = xsp;
    if (jj_3R_234()) return true;
    }
    if (jj_scan_token(IN)) return true;
    if (jj_3R_63()) return true;
    return false;
  }

  final private boolean jj_3_62() {
    if (jj_3R_102()) return true;
    return false;
  }

  final private boolean jj_3R_100() {
    if (jj_scan_token(DOT)) return true;
    Token xsp;
    xsp = jj_scanpos;
    lookingAhead = true;
    jj_semLA = BStack.aboveReference( getToken(1).beginColumn);
    lookingAhead = false;
    if (!jj_semLA || jj_3R_258()) return true;
    if (jj_3R_67()) return true;
    return false;
  }

  final private boolean jj_3R_83() {
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_143()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(IN)) return true;
    return false;
  }

  final private boolean jj_3_36() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_83()) {
    jj_scanpos = xsp;
    if (jj_scan_token(101)) return true;
    }
    return false;
  }

  final private boolean jj_3R_99() {
    if (jj_3R_102()) return true;
    return false;
  }

  final private boolean jj_3_61() {
    Token xsp;
    xsp = jj_scanpos;
    lookingAhead = true;
    jj_semLA = BStack.aboveReference( getToken(1).beginColumn);
    lookingAhead = false;
    if (!jj_semLA || jj_3R_99()) {
    jj_scanpos = xsp;
    lookingAhead = true;
    jj_semLA = BStack.aboveReference( getToken(1).beginColumn);
    lookingAhead = false;
    if (!jj_semLA || jj_3R_100()) {
    jj_scanpos = xsp;
    lookingAhead = true;
    jj_semLA = BStack.aboveReference( getToken(1).beginColumn);
    lookingAhead = false;
    if (!jj_semLA || jj_3R_101()) return true;
    }
    }
    return false;
  }

  final private boolean jj_3R_254() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_67()) return true;
    return false;
  }

  final private boolean jj_3_60() {
    if (jj_3R_98()) return true;
    return false;
  }

  final private boolean jj_3R_150() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(117)) {
    jj_scanpos = xsp;
    if (jj_scan_token(118)) {
    jj_scanpos = xsp;
    if (jj_scan_token(119)) {
    jj_scanpos = xsp;
    if (jj_scan_token(120)) {
    jj_scanpos = xsp;
    if (jj_scan_token(121)) {
    jj_scanpos = xsp;
    if (jj_scan_token(122)) {
    jj_scanpos = xsp;
    if (jj_scan_token(123)) {
    jj_scanpos = xsp;
    if (jj_scan_token(124)) {
    jj_scanpos = xsp;
    if (jj_scan_token(125)) {
    jj_scanpos = xsp;
    if (jj_scan_token(126)) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_89() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  final private boolean jj_3R_196() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(58)) {
    jj_scanpos = xsp;
    if (jj_scan_token(59)) return true;
    }
    if (jj_3R_67()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_254()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_63()) return true;
    return false;
  }

  final private boolean jj_3R_190() {
    if (jj_3R_202()) return true;
    return false;
  }

  final private boolean jj_3_59() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(128)) {
    jj_scanpos = xsp;
    if (jj_scan_token(131)) return true;
    }
    return false;
  }

  final private boolean jj_3R_189() {
    if (jj_3R_201()) return true;
    return false;
  }

  final private boolean jj_3R_263() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_230()) return true;
    return false;
  }

  final private boolean jj_3_44() {
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_89()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(COLON)) return true;
    return false;
  }

  final private boolean jj_3R_169() {
    Token xsp;
    xsp = jj_scanpos;
    lookingAhead = true;
    jj_semLA = OperatorStack.preInEmptyTop();
    lookingAhead = false;
    if (!jj_semLA || jj_3R_189()) {
    jj_scanpos = xsp;
    if (jj_3R_190()) {
    jj_scanpos = xsp;
    if (jj_3_60()) return true;
    }
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_61()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_3_69()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_262() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_67()) return true;
    return false;
  }

  final private boolean jj_3R_224() {
    if (jj_3R_230()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_263()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_223() {
    if (jj_3R_67()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_262()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_195() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(45)) {
    jj_scanpos = xsp;
    if (jj_scan_token(47)) return true;
    }
    xsp = jj_scanpos;
    if (jj_3R_223()) {
    jj_scanpos = xsp;
    if (jj_3R_224()) return true;
    }
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_63()) return true;
    return false;
  }

  final private boolean jj_3_58() {
    if (jj_3R_97()) return true;
    return false;
  }

  final private boolean jj_3R_132() {
    if (jj_3R_102()) return true;
    return false;
  }

  final private boolean jj_3R_131() {
    if (jj_3R_104()) return true;
    return false;
  }

  final private boolean jj_3R_130() {
    if (jj_3R_155()) return true;
    return false;
  }

  final private boolean jj_3R_128() {
    if (jj_3R_169()) return true;
    return false;
  }

  final private boolean jj_3R_129() {
    if (jj_3R_67()) return true;
    return false;
  }

  final private boolean jj_3_35() {
    if (jj_3R_59()) return true;
    return false;
  }

  final private boolean jj_3R_127() {
    if (jj_3R_168()) return true;
    return false;
  }

  final private boolean jj_3R_66() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_129()) {
    jj_scanpos = xsp;
    if (jj_3R_130()) {
    jj_scanpos = xsp;
    if (jj_3R_131()) {
    jj_scanpos = xsp;
    if (jj_3R_132()) return true;
    }
    }
    }
    if (jj_scan_token(SUBSTITUTE)) return true;
    if (jj_3R_174()) return true;
    return false;
  }

  final private boolean jj_3R_217() {
    if (jj_scan_token(LBR)) return true;
    if (jj_3R_63()) return true;
    if (jj_scan_token(RBR)) return true;
    return false;
  }

  final private boolean jj_3R_96() {
    if (jj_3R_150()) return true;
    return false;
  }

  final private boolean jj_3_57() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_96()) {
    jj_scanpos = xsp;
    if (jj_scan_token(192)) return true;
    }
    return false;
  }

  final private boolean jj_3R_167() {
    if (jj_3R_104()) return true;
    return false;
  }

  final private boolean jj_3R_166() {
    if (jj_3R_182()) return true;
    return false;
  }

  final private boolean jj_3R_126() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_166()) {
    jj_scanpos = xsp;
    if (jj_3R_167()) return true;
    }
    return false;
  }

  final private boolean jj_3R_63() {
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_126()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    lookingAhead = true;
    jj_semLA = BStack.aboveReference( getToken(1).beginColumn);
    lookingAhead = false;
    if (!jj_semLA || jj_3R_127()) {
    jj_scanpos = xsp;
    lookingAhead = true;
    jj_semLA = BStack.aboveReference( getToken(1).beginColumn);
    lookingAhead = false;
    if (!jj_semLA || jj_3R_128()) return true;
    }
    return false;
  }

  final private boolean jj_3_34() {
    if (jj_3R_82()) return true;
    return false;
  }

  final private boolean jj_3_12() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_66()) return true;
    return false;
  }

  final private boolean jj_3R_318() {
    if (jj_scan_token(WITH)) return true;
    if (jj_3R_66()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_12()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_229() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_67()) return true;
    return false;
  }

  final private boolean jj_3R_125() {
    if (jj_scan_token(INSTANCE)) return true;
    if (jj_3R_67()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_318()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_206() {
    if (jj_scan_token(LAMBDA)) return true;
    if (jj_3R_67()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_229()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_63()) return true;
    return false;
  }

  final private boolean jj_3R_88() {
    if (jj_3R_64()) return true;
    return false;
  }

  final private boolean jj_3R_124() {
    if (jj_scan_token(LOCAL)) return true;
    return false;
  }

  final private boolean jj_3R_60() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_124()) jj_scanpos = xsp;
    if (jj_3R_125()) return true;
    return false;
  }

  final private boolean jj_3R_149() {
    if (jj_3R_174()) return true;
    return false;
  }

  final private boolean jj_3R_228() {
    if (jj_3R_146()) return true;
    return false;
  }

  final private boolean jj_3R_227() {
    if (jj_3R_67()) return true;
    return false;
  }

  final private boolean jj_3R_324() {
    if (jj_3R_102()) return true;
    return false;
  }

  final private boolean jj_3R_87() {
    if (jj_3R_65()) return true;
    return false;
  }

  final private boolean jj_3R_200() {
    if (jj_scan_token(CHOOSE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_227()) {
    jj_scanpos = xsp;
    if (jj_3R_228()) return true;
    }
    if (jj_3R_257()) return true;
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_63()) return true;
    return false;
  }

  final private boolean jj_3_42() {
    if (jj_scan_token(LAMBDA)) return true;
    return false;
  }

  final private boolean jj_3_43() {
    if (jj_3R_63()) return true;
    return false;
  }

  final private boolean jj_3R_323() {
    if (jj_3R_104()) return true;
    if (jj_scan_token(US)) return true;
    return false;
  }

  final private boolean jj_3R_139() {
    if (jj_3R_140()) return true;
    return false;
  }

  final private boolean jj_3R_194() {
    if (jj_3R_206()) return true;
    return false;
  }

  final private boolean jj_3R_171() {
    if (jj_scan_token(US)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_323()) {
    jj_scanpos = xsp;
    if (jj_3R_324()) return true;
    }
    return false;
  }

  final private boolean jj_3R_205() {
    if (jj_3R_102()) return true;
    return false;
  }

  final private boolean jj_3R_170() {
    if (jj_3R_155()) return true;
    if (jj_scan_token(US)) return true;
    return false;
  }

  final private boolean jj_3R_86() {
    if (jj_3R_145()) return true;
    return false;
  }

  final private boolean jj_3_41() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_86()) {
    jj_scanpos = xsp;
    if (jj_3R_87()) {
    jj_scanpos = xsp;
    if (jj_3R_88()) return true;
    }
    }
    xsp = jj_scanpos;
    if (jj_scan_token(85)) {
    jj_scanpos = xsp;
    if (jj_scan_token(92)) {
    jj_scanpos = xsp;
    if (jj_scan_token(93)) {
    jj_scanpos = xsp;
    if (jj_scan_token(52)) {
    jj_scanpos = xsp;
    if (jj_scan_token(49)) {
    jj_scanpos = xsp;
    if (jj_scan_token(65)) {
    jj_scanpos = xsp;
    if (jj_scan_token(38)) {
    jj_scanpos = xsp;
    if (jj_scan_token(36)) {
    jj_scanpos = xsp;
    if (jj_scan_token(35)) {
    jj_scanpos = xsp;
    if (jj_scan_token(34)) {
    jj_scanpos = xsp;
    if (jj_scan_token(39)) {
    jj_scanpos = xsp;
    if (jj_scan_token(42)) {
    jj_scanpos = xsp;
    if (jj_scan_token(82)) {
    jj_scanpos = xsp;
    if (jj_scan_token(76)) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_134() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_170()) {
    jj_scanpos = xsp;
    if (jj_3R_171()) return true;
    }
    return false;
  }

  final private boolean jj_3R_204() {
    if (jj_3R_104()) return true;
    return false;
  }

  final private boolean jj_3R_222() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(131)) {
    jj_scanpos = xsp;
    if (jj_scan_token(128)) return true;
    }
    if (jj_3R_63()) return true;
    return false;
  }

  final private boolean jj_3R_203() {
    if (jj_3R_155()) return true;
    return false;
  }

  final private boolean jj_3_56() {
    if (jj_scan_token(AND)) return true;
    return false;
  }

  final private boolean jj_3R_193() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_203()) {
    jj_scanpos = xsp;
    if (jj_3R_204()) {
    jj_scanpos = xsp;
    if (jj_3R_205()) return true;
    }
    }
    return false;
  }

  final private boolean jj_3R_269() {
    if (jj_3R_222()) return true;
    return false;
  }

  final private boolean jj_3_55() {
    if (jj_scan_token(OR)) return true;
    return false;
  }

  final private boolean jj_3R_174() {
    Token xsp;
    xsp = jj_scanpos;
    lookingAhead = true;
    jj_semLA = BStack.aboveReference( getToken(1).beginColumn);
    lookingAhead = false;
    if (!jj_semLA || jj_3R_193()) {
    jj_scanpos = xsp;
    lookingAhead = true;
    jj_semLA = BStack.aboveReference( getToken(1).beginColumn);
    lookingAhead = false;
    if (!jj_semLA || jj_3R_194()) {
    jj_scanpos = xsp;
    if (jj_3_43()) return true;
    }
    }
    return false;
  }

  final private boolean jj_3R_322() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_scan_token(US)) return true;
    return false;
  }

  final private boolean jj_3R_216() {
    if (jj_3R_222()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_269()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_268() {
    if (jj_3R_222()) return true;
    return false;
  }

  final private boolean jj_3R_133() {
    if (jj_scan_token(LBR)) return true;
    if (jj_scan_token(US)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_322()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(RBR)) return true;
    return false;
  }

  final private boolean jj_3R_215() {
    if (jj_3R_222()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_268()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_68() {
    if (jj_3R_67()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_133()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_208() {
    if (jj_3R_216()) return true;
    return false;
  }

  final private boolean jj_3R_207() {
    if (jj_3R_215()) return true;
    return false;
  }

  final private boolean jj_3R_162() {
    if (jj_3R_67()) return true;
    if (jj_3R_64()) return true;
    return false;
  }

  final private boolean jj_3R_201() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_207()) {
    jj_scanpos = xsp;
    if (jj_3R_208()) return true;
    }
    return false;
  }

  final private boolean jj_3R_80() {
    if (jj_3R_140()) return true;
    return false;
  }

  final private boolean jj_3R_163() {
    if (jj_3R_67()) return true;
    if (jj_3R_65()) return true;
    if (jj_3R_67()) return true;
    return false;
  }

  final private boolean jj_3R_236() {
    if (jj_3R_115()) return true;
    return false;
  }

  final private boolean jj_3R_235() {
    if (jj_3R_59()) return true;
    return false;
  }

  final private boolean jj_3R_231() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_235()) {
    jj_scanpos = xsp;
    if (jj_3R_236()) return true;
    }
    return false;
  }

  final private boolean jj_3R_321() {
    if (jj_3R_134()) return true;
    return false;
  }

  final private boolean jj_3R_226() {
    Token xsp;
    if (jj_3R_231()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_231()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_316() {
    if (jj_3R_134()) return true;
    return false;
  }

  final private boolean jj_3R_140() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(232)) {
    jj_scanpos = xsp;
    if (jj_scan_token(233)) {
    jj_scanpos = xsp;
    if (jj_scan_token(234)) {
    jj_scanpos = xsp;
    if (jj_scan_token(235)) {
    jj_scanpos = xsp;
    if (jj_scan_token(236)) return true;
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_165() {
    if (jj_3R_145()) return true;
    if (jj_3R_67()) return true;
    return false;
  }

  final private boolean jj_3R_199() {
    if (jj_scan_token(LET)) return true;
    if (jj_3R_226()) return true;
    if (jj_scan_token(LETIN)) return true;
    if (jj_3R_63()) return true;
    return false;
  }

  final private boolean jj_3R_320() {
    if (jj_3R_68()) return true;
    return false;
  }

  final private boolean jj_3_33() {
    if (jj_3R_63()) return true;
    return false;
  }

  final private boolean jj_3R_317() {
    if (jj_scan_token(COMMA)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_320()) {
    jj_scanpos = xsp;
    if (jj_3R_321()) return true;
    }
    return false;
  }

  final private boolean jj_3R_315() {
    if (jj_3R_68()) return true;
    return false;
  }

  final private boolean jj_3R_309() {
    if (jj_scan_token(LBR)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_315()) {
    jj_scanpos = xsp;
    if (jj_3R_316()) return true;
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_317()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(RBR)) return true;
    return false;
  }

  final private boolean jj_3_32() {
    if (jj_3R_63()) return true;
    return false;
  }

  final private boolean jj_3R_164() {
    if (jj_3R_67()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_309()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_264() {
    if (jj_scan_token(OTHER)) return true;
    if (jj_scan_token(ARROW)) return true;
    if (jj_3R_63()) return true;
    return false;
  }

  final private boolean jj_3_30() {
    if (jj_3R_63()) return true;
    return false;
  }

  final private boolean jj_3R_192() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_67()) return true;
    return false;
  }

  final private boolean jj_3R_225() {
    if (jj_3R_63()) return true;
    if (jj_scan_token(ARROW)) return true;
    if (jj_3R_63()) return true;
    return false;
  }

  final private boolean jj_3_29() {
    if (jj_3R_63()) return true;
    return false;
  }

  final private boolean jj_3R_173() {
    if (jj_3R_67()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_192()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_81() {
    if (jj_scan_token(MODULE)) return true;
    return false;
  }

  final private boolean jj_3R_191() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_149()) return true;
    return false;
  }

  final private boolean jj_3R_146() {
    if (jj_scan_token(LAB)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_173()) jj_scanpos = xsp;
    if (jj_scan_token(RAB)) return true;
    return false;
  }

  final private boolean jj_3_31() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_81()) {
    jj_scanpos = xsp;
    if (jj_3_29()) return true;
    }
    return false;
  }

  final private boolean jj_3R_95() {
    if (jj_scan_token(LBR)) return true;
    if (jj_3R_149()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_191()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(RBR)) return true;
    return false;
  }

  final private boolean jj_3R_256() {
    if (jj_scan_token(CASESEP)) return true;
    if (jj_3R_264()) return true;
    return false;
  }

  final private boolean jj_3R_161() {
    if (jj_scan_token(HIDE)) return true;
    return false;
  }

  final private boolean jj_3R_160() {
    if (jj_scan_token(USE)) return true;
    return false;
  }

  final private boolean jj_3R_255() {
    if (jj_scan_token(CASESEP)) return true;
    if (jj_3R_225()) return true;
    return false;
  }

  final private boolean jj_3R_181() {
    if (jj_scan_token(PROOF)) return true;
    return false;
  }

  final private boolean jj_3R_159() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_181()) jj_scanpos = xsp;
    if (jj_scan_token(BY)) return true;
    return false;
  }

  final private boolean jj_3R_198() {
    if (jj_scan_token(CASE)) return true;
    if (jj_3R_225()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_255()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_3R_256()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_117() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_159()) {
    jj_scanpos = xsp;
    if (jj_3R_160()) {
    jj_scanpos = xsp;
    if (jj_3R_161()) return true;
    }
    }
    return false;
  }

  final private boolean jj_3_11() {
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(91)) {
    jj_scanpos = xsp;
    if (jj_scan_token(90)) return true;
    }
    return false;
  }

  final private boolean jj_3R_299() {
    if (jj_3R_125()) return true;
    return false;
  }

  final private boolean jj_3_7() {
    if (jj_3R_63()) return true;
    return false;
  }

  final private boolean jj_3R_123() {
    if (jj_3R_165()) return true;
    if (jj_scan_token(DEF)) return true;
    if (jj_3R_63()) return true;
    return false;
  }

  final private boolean jj_3_10() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_3R_65()) return true;
    return false;
  }

  final private boolean jj_3R_197() {
    if (jj_scan_token(IF)) return true;
    if (jj_3R_63()) return true;
    if (jj_scan_token(THEN)) return true;
    if (jj_3R_63()) return true;
    if (jj_scan_token(ELSE)) return true;
    if (jj_3R_63()) return true;
    return false;
  }

  final private boolean jj_3R_122() {
    if (jj_3R_164()) return true;
    if (jj_scan_token(DEF)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_7()) {
    jj_scanpos = xsp;
    if (jj_3R_299()) return true;
    }
    return false;
  }

  final private boolean jj_3_9() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_3R_64()) return true;
    return false;
  }

  final private boolean jj_3R_121() {
    if (jj_3R_163()) return true;
    if (jj_scan_token(DEF)) return true;
    if (jj_3R_63()) return true;
    return false;
  }

  final private boolean jj_3R_79() {
    if (jj_3R_139()) return true;
    return false;
  }

  final private boolean jj_3R_120() {
    if (jj_3R_162()) return true;
    if (jj_scan_token(DEF)) return true;
    if (jj_3R_63()) return true;
    return false;
  }

  final private boolean jj_3_26() {
    if (jj_scan_token(PROOF)) return true;
    return false;
  }

  final private boolean jj_3_28() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_26()) jj_scanpos = xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_79()) { jj_scanpos = xsp; break; }
    }
    if (jj_3R_80()) return true;
    return false;
  }

  final private boolean jj_3R_298() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_230()) return true;
    return false;
  }

  final private boolean jj_3_8() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(LSB)) return true;
    return false;
  }

  final private boolean jj_3_27() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(73)) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(69)) {
    jj_scanpos = xsp;
    if (jj_scan_token(70)) return true;
    }
    return false;
  }

  final private boolean jj_3R_119() {
    if (jj_3R_67()) return true;
    if (jj_scan_token(LSB)) return true;
    if (jj_3R_230()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_298()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(RSB)) return true;
    if (jj_scan_token(DEF)) return true;
    if (jj_3R_63()) return true;
    return false;
  }

  final private boolean jj_3R_118() {
    if (jj_scan_token(LOCAL)) return true;
    return false;
  }

  final private boolean jj_3R_59() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_118()) jj_scanpos = xsp;
    if (jj_scan_token(DEFBREAK)) return true;
    xsp = jj_scanpos;
    if (jj_3R_119()) {
    jj_scanpos = xsp;
    if (jj_3R_120()) {
    jj_scanpos = xsp;
    if (jj_3R_121()) {
    jj_scanpos = xsp;
    if (jj_3R_122()) {
    jj_scanpos = xsp;
    if (jj_3R_123()) return true;
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3_54() {
    if (jj_scan_token(LBR)) return true;
    if (jj_3R_63()) return true;
    if (jj_scan_token(RBR)) return true;
    return false;
  }

  final private boolean jj_3R_221() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(83)) {
    jj_scanpos = xsp;
    if (jj_scan_token(57)) return true;
    }
    if (jj_3R_243()) return true;
    xsp = jj_scanpos;
    if (jj_3_54()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_311() {
    if (jj_3R_102()) return true;
    return false;
  }

  final private boolean jj_3R_97() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(40)) {
    jj_scanpos = xsp;
    if (jj_scan_token(41)) {
    jj_scanpos = xsp;
    if (jj_scan_token(45)) {
    jj_scanpos = xsp;
    if (jj_scan_token(47)) {
    jj_scanpos = xsp;
    if (jj_scan_token(48)) {
    jj_scanpos = xsp;
    if (jj_scan_token(50)) {
    jj_scanpos = xsp;
    if (jj_scan_token(58)) {
    jj_scanpos = xsp;
    if (jj_scan_token(59)) return true;
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_310() {
    if (jj_3R_104()) return true;
    if (jj_scan_token(US)) return true;
    return false;
  }

  final private boolean jj_3_40() {
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(NUMBER_LITERAL)) return true;
    return false;
  }

  final private boolean jj_3R_252() {
    if (jj_3R_220()) return true;
    return false;
  }

  final private boolean jj_3R_251() {
    if (jj_3R_219()) return true;
    return false;
  }

  final private boolean jj_3R_250() {
    if (jj_3R_154()) return true;
    return false;
  }

  final private boolean jj_3R_185() {
    if (jj_3R_197()) return true;
    return false;
  }

  final private boolean jj_3R_175() {
    if (jj_scan_token(NUMBER_LITERAL)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_40()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_249() {
    if (jj_3R_218()) return true;
    return false;
  }

  final private boolean jj_3R_248() {
    if (jj_3R_217()) return true;
    return false;
  }

  final private boolean jj_3R_247() {
    if (jj_3R_253()) return true;
    return false;
  }

  final private boolean jj_3R_302() {
    if (jj_scan_token(US)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_310()) {
    jj_scanpos = xsp;
    if (jj_3R_311()) return true;
    }
    return false;
  }

  final private boolean jj_3R_243() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_247()) {
    jj_scanpos = xsp;
    if (jj_3R_248()) {
    jj_scanpos = xsp;
    if (jj_3R_249()) {
    jj_scanpos = xsp;
    if (jj_3R_250()) {
    jj_scanpos = xsp;
    if (jj_3R_251()) {
    jj_scanpos = xsp;
    if (jj_3R_252()) return true;
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_301() {
    if (jj_3R_155()) return true;
    if (jj_scan_token(US)) return true;
    return false;
  }

  final private boolean jj_3R_188() {
    if (jj_3R_200()) return true;
    return false;
  }

  final private boolean jj_3R_319() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_scan_token(US)) return true;
    return false;
  }

  final private boolean jj_3R_107() {
    if (jj_scan_token(STRING_LITERAL)) return true;
    return false;
  }

  final private boolean jj_3R_184() {
    if (jj_3R_196()) return true;
    return false;
  }

  final private boolean jj_3R_187() {
    if (jj_3R_199()) return true;
    return false;
  }

  final private boolean jj_3R_214() {
    if (jj_3R_221()) return true;
    return false;
  }

  final private boolean jj_3_6() {
    if (jj_scan_token(LBR)) return true;
    if (jj_scan_token(US)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_319()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(RBR)) return true;
    return false;
  }

  final private boolean jj_3R_211() {
    if (jj_3R_154()) return true;
    return false;
  }

  final private boolean jj_3R_300() {
    if (jj_3R_67()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_6()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_186() {
    if (jj_3R_198()) return true;
    return false;
  }

  final private boolean jj_3R_308() {
    if (jj_scan_token(BANG)) return true;
    if (jj_3R_253()) return true;
    return false;
  }

  final private boolean jj_3R_289() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_300()) {
    jj_scanpos = xsp;
    if (jj_3R_301()) {
    jj_scanpos = xsp;
    if (jj_3R_302()) return true;
    }
    }
    return false;
  }

  final private boolean jj_3R_183() {
    if (jj_3R_195()) return true;
    return false;
  }

  final private boolean jj_3R_168() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_183()) {
    jj_scanpos = xsp;
    if (jj_3R_184()) {
    jj_scanpos = xsp;
    if (jj_3R_185()) {
    jj_scanpos = xsp;
    if (jj_3R_186()) {
    jj_scanpos = xsp;
    if (jj_3R_187()) {
    jj_scanpos = xsp;
    if (jj_3R_188()) return true;
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3_53() {
    if (jj_3R_95()) return true;
    return false;
  }

  final private boolean jj_3R_253() {
    if (jj_3R_67()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_53()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_308()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3_25() {
    if (jj_3R_63()) return true;
    return false;
  }

  final private boolean jj_3R_213() {
    if (jj_3R_220()) return true;
    return false;
  }

  final private boolean jj_3R_290() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_289()) return true;
    return false;
  }

  final private boolean jj_3R_210() {
    if (jj_3R_218()) return true;
    return false;
  }

  final private boolean jj_3R_77() {
    return false;
  }

  final private boolean jj_3_24() {
    Token xsp;
    xsp = jj_scanpos;
    lookingAhead = true;
    jj_semLA = getToken(1).kind == ASSUME;
    lookingAhead = false;
    if (!jj_semLA || jj_3R_77()) return true;
    if (jj_3R_78()) return true;
    return false;
  }

  final private boolean jj_3R_115() {
    if (jj_scan_token(RECURSIVE)) return true;
    if (jj_3R_289()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_290()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_242() {
    if (jj_scan_token(ARAB)) return true;
    if (jj_3R_243()) return true;
    return false;
  }

  final private boolean jj_3R_241() {
    if (jj_scan_token(RAB)) return true;
    return false;
  }

  final private boolean jj_3_23() {
    if (jj_3R_67()) return true;
    if (jj_scan_token(DEF)) return true;
    return false;
  }

  final private boolean jj_3R_284() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_63()) return true;
    return false;
  }

  final private boolean jj_3R_62() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(65)) {
    jj_scanpos = xsp;
    if (jj_scan_token(56)) return true;
    }
    xsp = jj_scanpos;
    if (jj_3_23()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3_24()) {
    jj_scanpos = xsp;
    if (jj_3_25()) return true;
    }
    return false;
  }

  final private boolean jj_3_52() {
    if (jj_3R_63()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_284()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_220() {
    if (jj_scan_token(LAB)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_52()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_241()) {
    jj_scanpos = xsp;
    if (jj_3R_242()) return true;
    }
    return false;
  }

  final private boolean jj_3R_212() {
    if (jj_3R_219()) return true;
    return false;
  }

  final private boolean jj_3R_209() {
    if (jj_3R_217()) return true;
    return false;
  }

  final private boolean jj_3R_202() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_209()) {
    jj_scanpos = xsp;
    if (jj_3R_210()) {
    jj_scanpos = xsp;
    if (jj_3R_211()) {
    jj_scanpos = xsp;
    if (jj_3R_212()) {
    jj_scanpos = xsp;
    if (jj_3R_213()) {
    jj_scanpos = xsp;
    if (jj_3R_214()) return true;
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_157() {
    if (jj_scan_token(CONSTANT)) return true;
    return false;
  }

  final private boolean jj_3R_283() {
    if (jj_scan_token(IN)) return true;
    return false;
  }

  final private boolean jj_3R_156() {
    if (jj_3R_175()) return true;
    return false;
  }

  final private boolean jj_3R_282() {
    if (jj_scan_token(EQUALS)) return true;
    return false;
  }

  final private boolean jj_3R_144() {
    if (jj_3R_95()) return true;
    return false;
  }

  final private boolean jj_3_39() {
    if (jj_3R_85()) return true;
    return false;
  }

  final private boolean jj_3R_85() {
    if (jj_3R_67()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_144()) jj_scanpos = xsp;
    if (jj_scan_token(BANG)) return true;
    return false;
  }

  final private boolean jj_3R_270() {
    if (jj_scan_token(BANG)) return true;
    if (jj_3R_281()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_282()) {
    jj_scanpos = xsp;
    if (jj_3R_283()) return true;
    }
    if (jj_3R_63()) return true;
    return false;
  }

  final private boolean jj_3R_265() {
    if (jj_scan_token(IN)) return true;
    if (jj_3R_63()) return true;
    return false;
  }

  final private boolean jj_3R_257() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_265()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_271() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_270()) return true;
    return false;
  }

  final private boolean jj_3R_114() {
    if (jj_3R_157()) return true;
    return false;
  }

  final private boolean jj_3R_219() {
    if (jj_scan_token(LWB)) return true;
    if (jj_3R_63()) return true;
    if (jj_scan_token(EXCEPT)) return true;
    if (jj_3R_270()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_271()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(RWB)) return true;
    return false;
  }

  final private boolean jj_3R_56() {
    if (jj_3R_115()) return true;
    return false;
  }

  final private boolean jj_3R_307() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_63()) return true;
    return false;
  }

  final private boolean jj_3R_113() {
    if (jj_scan_token(VARIABLE)) return true;
    return false;
  }

  final private boolean jj_3R_112() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(101)) {
    jj_scanpos = xsp;
    if (jj_scan_token(103)) {
    jj_scanpos = xsp;
    if (jj_scan_token(86)) {
    jj_scanpos = xsp;
    if (jj_3R_156()) {
    jj_scanpos = xsp;
    lookingAhead = true;
    jj_semLA = getToken(1).image.equals("@");
    lookingAhead = false;
    if (!jj_semLA || jj_scan_token(229)) return true;
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_296() {
    if (jj_scan_token(LSB)) return true;
    if (jj_3R_63()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_307()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(RSB)) return true;
    return false;
  }

  final private boolean jj_3R_58() {
    if (jj_3R_117()) return true;
    return false;
  }

  final private boolean jj_3_77() {
    if (jj_3R_112()) return true;
    return false;
  }

  final private boolean jj_3R_285() {
    if (jj_3R_95()) return true;
    return false;
  }

  final private boolean jj_3R_57() {
    if (jj_3R_116()) return true;
    return false;
  }

  final private boolean jj_3_5() {
    if (jj_3R_62()) return true;
    return false;
  }

  final private boolean jj_3_75() {
    if (jj_3R_95()) return true;
    return false;
  }

  final private boolean jj_3_74() {
    if (jj_3R_67()) return true;
    return false;
  }

  final private boolean jj_3_4() {
    if (jj_3R_61()) return true;
    return false;
  }

  final private boolean jj_3R_111() {
    if (jj_3R_102()) return true;
    return false;
  }

  final private boolean jj_3_3() {
    if (jj_3R_60()) return true;
    return false;
  }

  final private boolean jj_3_2() {
    if (jj_3R_59()) return true;
    return false;
  }

  final private boolean jj_3R_55() {
    if (jj_3R_114()) return true;
    return false;
  }

  final private boolean jj_3R_54() {
    if (jj_3R_113()) return true;
    return false;
  }

  final private boolean jj_3R_110() {
    if (jj_3R_104()) return true;
    return false;
  }

  final private boolean jj_3R_295() {
    if (jj_scan_token(DOT)) return true;
    if (jj_3R_67()) return true;
    return false;
  }

  final private boolean jj_3R_53() {
    if (jj_scan_token(SEPARATOR)) return true;
    return false;
  }

  final private boolean jj_3R_109() {
    if (jj_3R_155()) return true;
    return false;
  }

  final private boolean jj_3R_281() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_295()) {
    jj_scanpos = xsp;
    if (jj_3R_296()) return true;
    }
    return false;
  }

  final private boolean jj_3R_108() {
    if (jj_3R_67()) return true;
    return false;
  }

  final private boolean jj_3_1() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_53()) {
    jj_scanpos = xsp;
    if (jj_3R_54()) {
    jj_scanpos = xsp;
    if (jj_3R_55()) {
    jj_scanpos = xsp;
    if (jj_3_2()) {
    jj_scanpos = xsp;
    if (jj_3R_56()) {
    jj_scanpos = xsp;
    if (jj_3_3()) {
    jj_scanpos = xsp;
    if (jj_3_4()) {
    jj_scanpos = xsp;
    if (jj_3_5()) {
    jj_scanpos = xsp;
    if (jj_3R_57()) {
    jj_scanpos = xsp;
    lookingAhead = true;
    jj_semLA = (getToken(1).kind == USE) || (getToken(1).kind == HIDE);
    lookingAhead = false;
    if (!jj_semLA || jj_3R_58()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3_76() {
    Token xsp;
    xsp = jj_scanpos;
    lookingAhead = true;
    jj_semLA = !getToken(1).image.equals("@");
    lookingAhead = false;
    if (!jj_semLA || jj_3R_108()) {
    jj_scanpos = xsp;
    if (jj_3R_109()) {
    jj_scanpos = xsp;
    if (jj_3R_110()) {
    jj_scanpos = xsp;
    if (jj_3R_111()) return true;
    }
    }
    }
    xsp = jj_scanpos;
    if (jj_3_75()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_76() {
    if (jj_3R_134()) return true;
    return false;
  }

  final private boolean jj_3R_75() {
    if (jj_3R_68()) return true;
    return false;
  }

  final private boolean jj_3R_244() {
    if (jj_scan_token(BANG)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_76()) {
    jj_scanpos = xsp;
    if (jj_3R_285()) {
    jj_scanpos = xsp;
    if (jj_3_77()) return true;
    }
    }
    return false;
  }

  final private boolean jj_3R_74() {
    if (jj_scan_token(NEW)) return true;
    return false;
  }

  final private boolean jj_3_22() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_74()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(77)) {
    jj_scanpos = xsp;
    if (jj_scan_token(37)) {
    jj_scanpos = xsp;
    if (jj_scan_token(78)) return true;
    }
    }
    xsp = jj_scanpos;
    if (jj_3R_75()) {
    jj_scanpos = xsp;
    if (jj_3R_76()) return true;
    }
    return false;
  }

  final private boolean jj_3R_297() {
    if (jj_3R_281()) return true;
    return false;
  }

  final private boolean jj_3R_287() {
    if (jj_scan_token(BANG)) return true;
    Token xsp;
    if (jj_3R_297()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_297()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(EQUALS)) return true;
    if (jj_3R_63()) return true;
    return false;
  }

  final private boolean jj_3R_73() {
    if (jj_scan_token(NEW)) return true;
    return false;
  }

  final private boolean jj_3R_72() {
    if (jj_3R_134()) return true;
    return false;
  }

  final private boolean jj_3_21() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_73()) jj_scanpos = xsp;
    if (jj_scan_token(VARIABLE)) return true;
    if (jj_3R_67()) return true;
    return false;
  }

  final private boolean jj_3R_246() {
    if (jj_3R_67()) return true;
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_63()) return true;
    return false;
  }

  final private boolean jj_3R_69() {
    if (jj_scan_token(IN)) return true;
    return false;
  }

  final private boolean jj_3_19() {
    if (jj_3R_68()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_69()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_71() {
    if (jj_scan_token(CONSTANT)) return true;
    return false;
  }

  final private boolean jj_3R_70() {
    if (jj_scan_token(NEW)) return true;
    return false;
  }

  final private boolean jj_3R_245() {
    if (jj_3R_67()) return true;
    if (jj_scan_token(MAPTO)) return true;
    if (jj_3R_63()) return true;
    return false;
  }

  final private boolean jj_3_18() {
    if (jj_scan_token(NEW)) return true;
    if (jj_scan_token(CONSTANT)) return true;
    return false;
  }

  final private boolean jj_3_20() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_18()) {
    jj_scanpos = xsp;
    if (jj_3R_70()) {
    jj_scanpos = xsp;
    if (jj_3R_71()) return true;
    }
    }
    xsp = jj_scanpos;
    if (jj_3_19()) {
    jj_scanpos = xsp;
    if (jj_3R_72()) return true;
    }
    return false;
  }

  final private boolean jj_3R_172() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_20()) {
    jj_scanpos = xsp;
    if (jj_3_21()) {
    jj_scanpos = xsp;
    if (jj_3_22()) return true;
    }
    }
    return false;
  }

  final private boolean jj_3R_279() {
    if (jj_scan_token(ARSB)) return true;
    if (jj_3R_243()) return true;
    return false;
  }

  final private boolean jj_3R_288() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_287()) return true;
    return false;
  }

  final private boolean jj_3R_158() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(34)) {
    jj_scanpos = xsp;
    if (jj_scan_token(3)) {
    jj_scanpos = xsp;
    if (jj_scan_token(20)) return true;
    }
    }
    return false;
  }

  final private boolean jj_3R_278() {
    if (jj_scan_token(EXCEPT)) return true;
    if (jj_3R_287()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_288()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(RSB)) return true;
    return false;
  }

  final private boolean jj_3R_277() {
    if (jj_scan_token(ARROW)) return true;
    if (jj_3R_63()) return true;
    if (jj_scan_token(RSB)) return true;
    return false;
  }

  final private boolean jj_3R_286() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_63()) return true;
    return false;
  }

  final private boolean jj_3_50() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(COLON)) return true;
    return false;
  }

  final private boolean jj_3R_276() {
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_286()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(RSB)) return true;
    return false;
  }

  final private boolean jj_3R_116() {
    if (jj_3R_158()) return true;
    return false;
  }

  final private boolean jj_3_51() {
    if (jj_3R_63()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_276()) {
    jj_scanpos = xsp;
    if (jj_3R_277()) {
    jj_scanpos = xsp;
    if (jj_3R_278()) {
    jj_scanpos = xsp;
    if (jj_3R_279()) return true;
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_275() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_246()) return true;
    return false;
  }

  final private boolean jj_3_17() {
    if (jj_3R_63()) return true;
    return false;
  }

  final private boolean jj_3R_240() {
    if (jj_3R_246()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_275()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(RSB)) return true;
    return false;
  }

  final private boolean jj_3R_274() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_245()) return true;
    return false;
  }

  final private boolean jj_3_49() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(MAPTO)) return true;
    return false;
  }

  final private boolean jj_3R_239() {
    if (jj_3R_245()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_274()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(RSB)) return true;
    return false;
  }

  final private boolean jj_3R_273() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_245()) return true;
    return false;
  }

  final private boolean jj_3R_138() {
    if (jj_scan_token(COMMA)) return true;
    return false;
  }

  final private boolean jj_3_16() {
    if (jj_3R_63()) return true;
    return false;
  }

  final private boolean jj_3R_137() {
    if (jj_3R_172()) return true;
    return false;
  }

  final private boolean jj_3R_238() {
    if (jj_3R_245()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_273()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(RSB)) return true;
    return false;
  }

  final private boolean jj_3R_272() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_230()) return true;
    return false;
  }

  final private boolean jj_3R_136() {
    if (jj_3R_78()) return true;
    return false;
  }

  final private boolean jj_3R_237() {
    if (jj_3R_230()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_272()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(MAPTO)) return true;
    if (jj_3R_63()) return true;
    if (jj_scan_token(RSB)) return true;
    return false;
  }

  final private boolean jj_3_70() {
    if (jj_scan_token(op_76)) return true;
    return false;
  }

  final private boolean jj_3R_232() {
    if (jj_3R_244()) return true;
    return false;
  }

  final private boolean jj_3R_154() {
    if (jj_scan_token(LSB)) return true;
    Token xsp;
    xsp = jj_scanpos;
    lookingAhead = true;
    jj_semLA = matchFcnConst();
    lookingAhead = false;
    if (!jj_semLA || jj_3R_237()) {
    jj_scanpos = xsp;
    if (jj_3R_238()) {
    jj_scanpos = xsp;
    lookingAhead = true;
    jj_semLA = (getToken(2).kind == MAPTO) && isFieldNameToken( getToken(1));
    lookingAhead = false;
    if (!jj_semLA || jj_3R_239()) {
    jj_scanpos = xsp;
    if (jj_3R_240()) {
    jj_scanpos = xsp;
    if (jj_3_51()) return true;
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3_71() {
    if (jj_3R_95()) return true;
    return false;
  }

  final private boolean jj_3R_180() {
    if (jj_3R_155()) return true;
    return false;
  }

  final private boolean jj_3R_179() {
    if (jj_3R_102()) return true;
    return false;
  }

  final private boolean jj_3R_64() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(112)) {
    jj_scanpos = xsp;
    if (jj_scan_token(113)) {
    jj_scanpos = xsp;
    if (jj_scan_token(114)) {
    jj_scanpos = xsp;
    if (jj_scan_token(115)) return true;
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_178() {
    if (jj_3R_104()) return true;
    return false;
  }

  final private boolean jj_3R_314() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_63()) return true;
    return false;
  }

  final private boolean jj_3R_313() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_230()) return true;
    return false;
  }

  final private boolean jj_3R_306() {
    Token xsp;
    if (jj_3R_314()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_314()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_135() {
    if (jj_3R_67()) return true;
    if (jj_scan_token(COLONCOLON)) return true;
    if (jj_3R_78()) return true;
    return false;
  }

  final private boolean jj_3R_78() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_135()) jj_scanpos = xsp;
    if (jj_scan_token(ASSUME)) return true;
    xsp = jj_scanpos;
    lookingAhead = true;
    jj_semLA = (getToken(1).kind == ASSUME)
                   || ((getToken(2).kind == COLONCOLON) &&
                       (getToken(3).kind == ASSUME)  );
    lookingAhead = false;
    if (!jj_semLA || jj_3R_136()) {
    jj_scanpos = xsp;
    if (jj_3R_137()) {
    jj_scanpos = xsp;
    if (jj_3_16()) return true;
    }
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_138()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(PROVE)) return true;
    return false;
  }

  final private boolean jj_3_73() {
    if (jj_scan_token(NUMBER_LITERAL)) return true;
    return false;
  }

  final private boolean jj_3R_177() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(232)) {
    jj_scanpos = xsp;
    if (jj_scan_token(233)) return true;
    }
    return false;
  }

  final private boolean jj_3_72() {
    if (jj_3R_107()) return true;
    return false;
  }

  final private boolean jj_3R_176() {
    if (jj_3R_67()) return true;
    return false;
  }

  final private boolean jj_3R_153() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_176()) {
    jj_scanpos = xsp;
    if (jj_3R_177()) {
    jj_scanpos = xsp;
    if (jj_3R_178()) {
    jj_scanpos = xsp;
    if (jj_3R_179()) {
    jj_scanpos = xsp;
    if (jj_3R_180()) return true;
    }
    }
    }
    }
    xsp = jj_scanpos;
    if (jj_3_71()) jj_scanpos = xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_232()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_91() {
    if (jj_3R_146()) return true;
    return false;
  }

  final private boolean jj_3R_142() {
    if (jj_3R_78()) return true;
    return false;
  }

  final private boolean jj_3R_152() {
    if (jj_3R_175()) return true;
    return false;
  }

  final private boolean jj_3R_305() {
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_230()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_313()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_294() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_305()) {
    jj_scanpos = xsp;
    if (jj_3R_306()) return true;
    }
    return false;
  }

  final private boolean jj_3_46() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_91()) {
    jj_scanpos = xsp;
    if (jj_scan_token(229)) return true;
    }
    if (jj_scan_token(COLON)) return true;
    return false;
  }

  final private boolean jj_3_38() {
    if (jj_3R_63()) return true;
    return false;
  }

  final private boolean jj_3R_151() {
    if (jj_3R_107()) return true;
    return false;
  }

  final private boolean jj_3R_293() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_230()) return true;
    return false;
  }

  final private boolean jj_3_47() {
    if (jj_3R_63()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_294()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_98() {
    Token xsp;
    xsp = jj_scanpos;
    lookingAhead = true;
    jj_semLA = BStack.aboveReference( getToken(1).beginColumn);
    lookingAhead = false;
    if (!jj_semLA || jj_3R_151()) {
    jj_scanpos = xsp;
    lookingAhead = true;
    jj_semLA = BStack.aboveReference( getToken(1).beginColumn);
    lookingAhead = false;
    if (!jj_semLA || jj_3R_152()) {
    jj_scanpos = xsp;
    if (jj_3R_153()) return true;
    }
    }
    return false;
  }

  final private boolean jj_3R_90() {
    if (jj_3R_146()) return true;
    return false;
  }

  final private boolean jj_3R_141() {
    if (jj_scan_token(SUFFICES)) return true;
    return false;
  }

  final private boolean jj_3_45() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_90()) {
    jj_scanpos = xsp;
    if (jj_scan_token(229)) return true;
    }
    if (jj_scan_token(COMMA)) return true;
    return false;
  }

  final private boolean jj_3R_82() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_141()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3_38()) {
    jj_scanpos = xsp;
    lookingAhead = true;
    jj_semLA = getToken(1).kind == ASSUME;
    lookingAhead = false;
    if (!jj_semLA || jj_3R_142()) return true;
    }
    return false;
  }

  public TLAplusParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  public boolean lookingAhead = false;
  private boolean jj_semLA;
  private int jj_gen;
  final private int[] jj_la1 = new int[137];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static private int[] jj_la1_3;
  static private int[] jj_la1_4;
  static private int[] jj_la1_5;
  static private int[] jj_la1_6;
  static private int[] jj_la1_7;
  static {
      jj_la1_0();
      jj_la1_1();
      jj_la1_2();
      jj_la1_3();
      jj_la1_4();
      jj_la1_5();
      jj_la1_6();
      jj_la1_7();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {0x0,0x0,0x0,0x0,0x4,0x80000,0x80000,0x100008,0x0,0x0,0x0,0x0,0x100008,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x0,0x4000,0x408,0x0,0x4,0x0,0x0,0x0,0x0,0x0,0x0,0x100000,0x0,0x20000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100000,0x0,0x0,0x0,0x0,0xc0,0x0,0x0,0x400420,0x0,0x400420,0x400400,0x0,0x0,0x400000,0x400000,0x20,0x0,0x0,0x1000000,0x0,0x0,0x0,0x40000000,0x20000000,0x200000,0x0,0x200000,0x200000,0x0,0x200000,0x0,0x0,0x100,0x80000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2000000,0x2000000,0xc05a300,0x0,0x0,0x0,0x0,0x0,0x0,0xa000,0x0,0x0,0x0,0xc000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2000000,0x100000,0x100000,0x0,0x0,0x0,0x0,0x2000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc05a300,};
   }
   private static void jj_la1_2() {
      jj_la1_2 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200000,0x0,0x40000,0x1000,0x0,0x200000,0x200000,0x200000,0x200000,0x0,0x2000000,0x0,0x200000,0x0,0x0,0x200000,0x0,0x2000000,0x200000,0x2000000,0x8000000,0x200000,0x8000000,0x0,0x2000000,0x0,0x100000,0x0,0x0,0x80,0x0,0x20000000,0x0,0x46000,0x200000,0x46000,0x0,0x0,0x2000000,0x0,0x0,0x6000,0x2000000,0x0,0x2,0x200,0x60,0x200,0x0,0x20c,0x0,0x200000,0x0,0x0,0x200000,0x0,0x1,0x0,0x18110,0x0,0x200000,0x200000,0x0,0x200000,0x200000,0x200000,0x0,0x20000,0x8000000,0x48080000,0x48080000,0x0,0x0,0x8000000,0x0,0x0,0x200000,0x0,0x0,0x200000,0x200000,0x0,0x0,0x200000,0x200000,0x0,0x0,0x200000,0x600000,0x600000,0x200000,0x200000,0x200000,0x200000,0x600000,0x600000,0x200000,0x200000,0x200000,0x200000,0x200000,0x200000,0x80200000,0x41000000,0x200000,0x41000000,0x200000,0x0,0x200000,0x0,0x0,0x48000000,0x80000,0x20001000,0x20001000,0x0,0x0,0x200000,0x0,0x48080000,0x0,0x0,0x0,0x0,0x0,0x0,0x8000000,0x400000,0x0,};
   }
   private static void jj_la1_3() {
      jj_la1_3 = new int[] {0x7fe00000,0x7ff00000,0x80000000,0xf0000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x800f0000,0x7ff00000,0x0,0x0,0x0,0x7ff00000,0x0,0x0,0x7ff00000,0x0,0x7ff00000,0x0,0x0,0x0,0x800f0000,0x7ff00000,0x0,0x0,0xffff0000,0xffff0000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7ff00000,0x0,0x0,0x0,0x7ff00000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20,0x0,0x0,0x2a,0xffef302a,0x0,0xffef3000,0x0,0x100,0xffef0000,0x0,0xffff0000,0x0,0x0,0x0,0x20,0x0,0x0,0x0,0x20,0x20,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x201,0x0,0x0,0x0,0x0,0x0,0x0,0xc0,0x100,0x2a,0x0,0x0,0x0,0x0,0x20,0x0,0xffe00000,0x2a,0xffe00000,0x0,0x800f0000,0x100,0xffff0000,0xffff0000,0x0,0x10a0,0x0,};
   }
   private static void jj_la1_4() {
      jj_la1_4 = new int[] {0x0,0x0,0xffffffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffffffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffffffff,0x0,0x0,0x0,0xffffffff,0xffffffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40000,0x0,0x0,0x0,0x0,0x0,0x40000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffffffff,0x0,0xffffffff,0x0,0x0,0xffffffff,0x0,0xffffffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x9,0x0,0x0,0xffffffff,0x0,0xffffffff,0x0,0xffffffff,0x0,0xffffffff,0xffffffff,0x0,0x0,0x0,};
   }
   private static void jj_la1_5() {
      jj_la1_5 = new int[] {0x0,0x0,0xffffffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffffffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffffffff,0x0,0x0,0x0,0xffffffff,0xffffffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffffffff,0x0,0xffffffff,0x0,0x0,0xffffffff,0x0,0xffffffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffffffff,0x0,0xffffffff,0x0,0xffffffff,0x0,0xffffffff,0xffffffff,0x0,0x0,0x0,};
   }
   private static void jj_la1_6() {
      jj_la1_6 = new int[] {0x0,0x0,0xffffffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffffffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffffffff,0x0,0x0,0x0,0xffffffff,0xffffffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffffffff,0x0,0xffffffff,0x0,0x0,0xffffffff,0x0,0xffffffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffffffff,0x0,0xffffffff,0x0,0xffffffff,0x0,0xffffffff,0xffffffff,0x0,0x0,0x0,};
   }
   private static void jj_la1_7() {
      jj_la1_7 = new int[] {0x0,0x0,0x1f,0x0,0x0,0x20,0x20,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1f,0x20,0x0,0x0,0x0,0x0,0x0,0x20,0x20,0x0,0x20,0x0,0x0,0x0,0x1f,0x0,0x0,0x0,0x3f,0x3f,0x0,0x0,0x0,0x20,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1f00,0x0,0x0,0x0,0x0,0x20,0x0,0x0,0x0,0x20,0x0,0x0,0x0,0x3f,0x0,0x3f,0x0,0x0,0x3f,0x0,0x1f,0x0,0x0,0x0,0x20,0x0,0x0,0x0,0x20,0x20,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20,0x0,0x0,0x0,0x0,0x20,0x0,0x1f,0x0,0x1f,0x300,0x33f,0x0,0x33f,0x1f,0x0,0x0,0x0,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[77];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  public TLAplusParser(java.io.InputStream stream) {
     this(stream, null);
  }
  public TLAplusParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new TLAplusParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 137; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 137; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public TLAplusParser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new TLAplusParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 137; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 137; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public TLAplusParser(TLAplusParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 137; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(TLAplusParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 137; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  final private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = lookingAhead ? jj_scanpos : token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      boolean exists = false;
      for (java.util.Enumeration e = jj_expentries.elements(); e.hasMoreElements();) {
        int[] oldentry = (int[])(e.nextElement());
        if (oldentry.length == jj_expentry.length) {
          exists = true;
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              exists = false;
              break;
            }
          }
          if (exists) break;
        }
      }
      if (!exists) jj_expentries.addElement(jj_expentry);
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[237];
    for (int i = 0; i < 237; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 137; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
          if ((jj_la1_3[i] & (1<<j)) != 0) {
            la1tokens[96+j] = true;
          }
          if ((jj_la1_4[i] & (1<<j)) != 0) {
            la1tokens[128+j] = true;
          }
          if ((jj_la1_5[i] & (1<<j)) != 0) {
            la1tokens[160+j] = true;
          }
          if ((jj_la1_6[i] & (1<<j)) != 0) {
            la1tokens[192+j] = true;
          }
          if ((jj_la1_7[i] & (1<<j)) != 0) {
            la1tokens[224+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 237; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

  final private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 77; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
            case 5: jj_3_6(); break;
            case 6: jj_3_7(); break;
            case 7: jj_3_8(); break;
            case 8: jj_3_9(); break;
            case 9: jj_3_10(); break;
            case 10: jj_3_11(); break;
            case 11: jj_3_12(); break;
            case 12: jj_3_13(); break;
            case 13: jj_3_14(); break;
            case 14: jj_3_15(); break;
            case 15: jj_3_16(); break;
            case 16: jj_3_17(); break;
            case 17: jj_3_18(); break;
            case 18: jj_3_19(); break;
            case 19: jj_3_20(); break;
            case 20: jj_3_21(); break;
            case 21: jj_3_22(); break;
            case 22: jj_3_23(); break;
            case 23: jj_3_24(); break;
            case 24: jj_3_25(); break;
            case 25: jj_3_26(); break;
            case 26: jj_3_27(); break;
            case 27: jj_3_28(); break;
            case 28: jj_3_29(); break;
            case 29: jj_3_30(); break;
            case 30: jj_3_31(); break;
            case 31: jj_3_32(); break;
            case 32: jj_3_33(); break;
            case 33: jj_3_34(); break;
            case 34: jj_3_35(); break;
            case 35: jj_3_36(); break;
            case 36: jj_3_37(); break;
            case 37: jj_3_38(); break;
            case 38: jj_3_39(); break;
            case 39: jj_3_40(); break;
            case 40: jj_3_41(); break;
            case 41: jj_3_42(); break;
            case 42: jj_3_43(); break;
            case 43: jj_3_44(); break;
            case 44: jj_3_45(); break;
            case 45: jj_3_46(); break;
            case 46: jj_3_47(); break;
            case 47: jj_3_48(); break;
            case 48: jj_3_49(); break;
            case 49: jj_3_50(); break;
            case 50: jj_3_51(); break;
            case 51: jj_3_52(); break;
            case 52: jj_3_53(); break;
            case 53: jj_3_54(); break;
            case 54: jj_3_55(); break;
            case 55: jj_3_56(); break;
            case 56: jj_3_57(); break;
            case 57: jj_3_58(); break;
            case 58: jj_3_59(); break;
            case 59: jj_3_60(); break;
            case 60: jj_3_61(); break;
            case 61: jj_3_62(); break;
            case 62: jj_3_63(); break;
            case 63: jj_3_64(); break;
            case 64: jj_3_65(); break;
            case 65: jj_3_66(); break;
            case 66: jj_3_67(); break;
            case 67: jj_3_68(); break;
            case 68: jj_3_69(); break;
            case 69: jj_3_70(); break;
            case 70: jj_3_71(); break;
            case 71: jj_3_72(); break;
            case 72: jj_3_73(); break;
            case 73: jj_3_74(); break;
            case 74: jj_3_75(); break;
            case 75: jj_3_76(); break;
            case 76: jj_3_77(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  final private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
