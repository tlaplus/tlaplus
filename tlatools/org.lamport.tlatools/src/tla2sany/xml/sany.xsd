<?xml version="1.0" encoding="UTF-8"?>
<!-- 23/9/2014 Author: Tomer Libal -->
<!-- This DTD represents a SANY parsed module, corresponding to an input tla file. -->
<!-- Elements starting with capital letters correspond to SANY Java classes -->
<!-- This DTD should encompass all relevant data and later should be matched against actual XMLS to see if there is redundancy (do theorems really have suffices?) -->
<!-- In addition to the inheritance structure, the DTD should also take into account semantical constraints based on kinds. I.e. it is not possible to create certain nodes of certain kinds -->

<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified">

  <xs:element name="modules">
    <xs:complexType>
      <xs:sequence>
        <xs:element name="RootModule" type="xs:string"/>
        <xs:element ref="context"/>
        <xs:sequence maxOccurs="unbounded">
          <xs:choice>
            <xs:element ref="ModuleNode"/>
            <xs:element ref="ModuleNodeRef"/>
          </xs:choice>
        </xs:sequence>
      </xs:sequence>
    </xs:complexType>
  </xs:element>

  <!-- context and symbol references -->
  <!-- everything which has a uniquename is defined only once, here, and is referred by its name.
       this element resides within a certain scope and affects only this scope -->
  <xs:element name="context">
    <xs:complexType>
      <xs:sequence minOccurs="0" maxOccurs="unbounded">
        <xs:element name="entry">
          <xs:complexType>
            <xs:sequence>
              <xs:element ref="UID"/>
              <xs:choice>
                <xs:element ref="FormalParamNode"/>
                <xs:element ref="ModuleNode"/>
                <xs:element ref="OpDeclNode"/>
                <xs:group ref="OpDefNode"/>
                <xs:element ref="TheoremNode"/>
                <xs:element ref="AssumeNode"/>
                <xs:element ref="APSubstInNode"/>
                <xs:element ref="TheoremDefNode"/>
                <xs:element ref="AssumeDef"/>
              </xs:choice>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
      </xs:sequence>
    </xs:complexType>
  </xs:element>

  <xs:group name="OpDefNodeRef">
    <xs:choice>
      <xs:element ref="ModuleInstanceKindRef"/>
      <xs:element ref="UserDefinedOpKindRef"/>
      <xs:element ref="BuiltInKindRef"/>
      <xs:element ref="TheoremDefRef"/>
      <xs:element ref="AssumeDefRef"/>
    </xs:choice>
  </xs:group>
  <xs:element name="ModuleInstanceKindRef">
    <xs:complexType>
      <xs:sequence>
        <xs:element ref="UID"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>
  <xs:element name="UserDefinedOpKindRef">
    <xs:complexType>
      <xs:sequence>
        <xs:element ref="UID"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>
  <xs:element name="BuiltInKindRef">
    <xs:complexType>
      <xs:sequence>
        <xs:element ref="UID"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>

  <xs:element name="FormalParamNodeRef">
    <xs:complexType>
      <xs:sequence>
        <xs:element ref="UID"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>

  <xs:element name="ModuleNodeRef">
    <xs:complexType>
      <xs:sequence>
        <xs:element ref="UID"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>

  <xs:element name="TheoremNodeRef">
    <xs:complexType>
      <xs:sequence>
        <xs:element ref="UID"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>

  <xs:element name="TheoremDefRef">
    <xs:complexType>
      <xs:sequence>
        <xs:element ref="UID"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>

  <xs:element name="AssumeNodeRef">
    <xs:complexType>
      <xs:sequence>
        <xs:element ref="UID"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>

  <xs:element name="AssumeDefRef">
    <xs:complexType>
      <xs:sequence>
        <xs:element ref="UID"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>

  <xs:element name="OpDeclNodeRef">
    <xs:complexType>
      <xs:sequence>
        <xs:element ref="UID"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>

  <!-- A level node is a wrapper around all other nodes containing location and level information -->
  <xs:group name="node">
    <xs:sequence>
      <xs:element minOccurs="0" ref="location"/>
      <xs:element minOccurs="0"  ref="level"/>
    </xs:sequence>
  </xs:group>

  <!-- ExprNode is a grouping of the following nodes -->
  <xs:group name="ExprNode">
    <xs:choice>
      <xs:element ref="AtNode"/>
      <xs:element ref="DecimalNode"/>
      <xs:element ref="LabelNode"/>
      <xs:element ref="LetInNode"/>
      <xs:element ref="NumeralNode"/>
      <xs:element ref="OpApplNode"/>
      <xs:element ref="StringNode"/>
      <xs:element ref="SubstInNode"/>
      <xs:element ref="TheoremDefRef"/>
      <xs:element ref="AssumeDefRef"/>
    </xs:choice>
  </xs:group>

  <!-- Location -->
  <xs:element name="location">
    <xs:complexType>
      <xs:sequence>
        <xs:element ref="column"/>
        <xs:element ref="line"/>
        <xs:element ref="filename"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>
  <xs:element name="column">
    <xs:complexType>
      <xs:sequence>
        <xs:element ref="begin"/>
        <xs:element ref="end"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>
  <xs:element name="line">
    <xs:complexType>
      <xs:sequence>
        <xs:element ref="begin"/>
        <xs:element ref="end"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>
  <xs:element name="filename" type="xs:string"/>
  <xs:element name="begin" type="xs:integer"/>
  <xs:element name="end" type="xs:integer"/>

  <!-- Level -->
  <xs:element name="level">
    <xs:simpleType>
    <xs:restriction base="xs:integer">
      <xs:minInclusive value="0"/>
      <xs:maxInclusive value="3"/>
      <!--
      ConstantLevel = 0 (Constant)
      VariableLevel = 1 (State)
      ActionLevel = 2   (Transition)
      TemporalLevel = 3 (Temporal)
      -->
    </xs:restriction>
  </xs:simpleType>
 </xs:element>

  <!-- Pre-comments -->
  <xs:element name="pre-comments" type="xs:string"/>


  <!-- Instantiations and substitutions -->
  <!-- Operator substitution? -->
  <!-- A list of substitutions and the expression they apply to -->
  <xs:element name="APSubstInNode">
    <xs:complexType>
      <xs:sequence>
        <xs:group ref="node"/>
        <xs:element name="substs">
          <xs:complexType>
            <xs:sequence>
              <xs:element maxOccurs="unbounded" ref="Subst"/>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name="body">
          <xs:complexType>
            <xs:choice>
              <xs:group ref="ExprNode"/>
              <xs:group ref="AssumeProveLike"/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name="instFrom">
          <xs:complexType>
            <xs:sequence>
              <xs:element ref="ModuleNodeRef"/>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name="instTo">
          <xs:complexType>
            <xs:sequence>
              <xs:element ref="ModuleNodeRef"/>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
      </xs:sequence>
    </xs:complexType>
  </xs:element>

  <!-- Expr substitution -->
  <!-- A list of substitutions and the expression they apply to -->
  <xs:element name="SubstInNode">
    <xs:complexType>
      <xs:sequence>
        <xs:group ref="node"/>
        <xs:element name="substs">
          <xs:complexType>
            <xs:sequence>
              <xs:element maxOccurs="unbounded" ref="Subst"/>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name="body">
          <xs:complexType>
            <xs:sequence>
              <xs:group ref="ExprNode"/>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name="instFrom">
          <xs:complexType>
            <xs:sequence>
              <xs:element ref="ModuleNodeRef"/>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name="instTo">
          <xs:complexType>
            <xs:sequence>
              <xs:element ref="ModuleNodeRef"/>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
      </xs:sequence>
    </xs:complexType>
  </xs:element>

  <!-- Module substitution -->
  <!-- A list of substitutions, the name of the instance and list of instance params -->
  <xs:element name="InstanceNode">
    <xs:complexType>
      <xs:sequence>
        <xs:group ref="node"/>
        <xs:sequence>
          <xs:element minOccurs="0" maxOccurs="1" ref="uniquename"/>
        </xs:sequence>
        <xs:element name="module" type="xs:string"/>
        <xs:element name="substs">
          <xs:complexType>
            <xs:sequence>
              <xs:element minOccurs="0" maxOccurs="unbounded" ref="Subst"/>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name="params">
          <xs:complexType>
            <xs:sequence>
              <xs:element minOccurs="0" maxOccurs="unbounded" ref="FormalParamNodeRef"/>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element minOccurs="0" ref="local"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>

  <!-- Mapping from the OpDeclNode to either of the others -->
  <xs:element name="Subst">
    <xs:complexType>
      <xs:sequence>
        <xs:element ref="OpDeclNodeRef"/>
        <xs:choice>
          <xs:group ref="ExprNode"/>
          <xs:element ref="OpArgNode"/>
        </xs:choice>
      </xs:sequence>
    </xs:complexType>
  </xs:element>

  <!-- This is a unique name in the hierarchy -->
  <xs:element name="uniquename" type="xs:string"/>

  <!-- This is a unique ID in the system -->
  <xs:element name="UID" type="xs:integer"/>

  <!-- Assumptions and Theorems -->
  <!-- An assumption named by name and described by ExprNode -->
  <xs:element name="AssumeNode">
    <xs:complexType>
      <xs:sequence>
        <xs:group ref="node"/>
        <xs:element minOccurs="0" name="definition">
          <xs:complexType>
            <xs:choice>
              <xs:element ref="AssumeDefRef"/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name="body"> <!-- Invariant: definition body is assumption body, if definition exists -->
          <xs:complexType>
            <xs:choice>
              <xs:group ref="ExprNode"/>
              <xs:element ref="AssumeDef"/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <!-- reference to AssumeDef included in ExprNode -->
      </xs:sequence>
    </xs:complexType>
  </xs:element>

  <xs:element name="AssumeDef">
    <xs:complexType>
      <xs:sequence>
        <xs:group ref="node"/>
        <xs:element name="uniquename" type="xs:string"/>
        <xs:choice>
          <xs:group ref="ExprNode"/>
          <xs:group ref="AssumeProveLike"/>
        </xs:choice>
      </xs:sequence>
    </xs:complexType>
  </xs:element>

  <!-- Similar to assumption but may contain a proof. It can also refer to a proof step -->
  <xs:element name="TheoremNode">
    <xs:complexType>
      <xs:sequence>
        <xs:group ref="node"/>
        <xs:element minOccurs="0" name="definition">
          <xs:complexType>
            <xs:choice>
              <xs:element ref="TheoremDefRef"/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name="body"> <!-- Invariant: definition body is theorem body, if definition exists -->
          <xs:complexType>
            <xs:choice>
              <xs:group ref="ExprNode"/>
              <xs:group ref="AssumeProveLike"/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:group minOccurs="0" ref="ProofNode"/>
        <xs:element minOccurs="0" ref="suffices"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>
  <xs:element name="suffices">
    <xs:complexType/>
  </xs:element>

  <xs:element name="TheoremDefNode">
    <xs:complexType>
      <xs:sequence>
        <xs:group ref="node"/>
        <xs:element name="uniquename" type="xs:string"/>
        <xs:choice>
          <xs:group ref="ExprNode"/>
          <xs:group ref="AssumeProveLike"/>
        </xs:choice>
      </xs:sequence>
    </xs:complexType>
  </xs:element>

  <!-- A non empty list of assumptions and a prove expressions with possible suffices and boxed -->
  <xs:element name="AssumeProveNode">
    <xs:complexType>
      <xs:sequence>
        <xs:group ref="node"/>
        <xs:element name="assumes">
          <xs:complexType>
            <xs:choice maxOccurs="unbounded">
              <xs:group ref="AssumeProveLike"/>
              <xs:group ref="ExprNode"/>
              <xs:element ref="NewSymbNode"/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name="prove">
          <xs:complexType>
            <xs:group ref="ExprNode"/>
          </xs:complexType>
        </xs:element>
        <xs:element minOccurs="0" ref="suffices"/>
        <xs:element minOccurs="0" ref="boxed"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>

  <xs:group name="AssumeProveLike">
    <xs:choice>
      <xs:element ref="AssumeProveNode"/>
      <xs:element ref="APSubstInNode"/>
    </xs:choice>
  </xs:group>

  <!--  Signals a boxed scope (not clear if it is implemented in SANY) -->
  <xs:element name="boxed">
    <xs:complexType/>
  </xs:element>

  <!-- Represents a new declaration + possible domain -->
  <xs:element name="NewSymbNode">
    <xs:complexType>
      <xs:sequence>
        <xs:group ref="node"/>
        <xs:element ref="OpDeclNodeRef"/>
        <xs:group minOccurs="0" ref="ExprNode"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>


  <!-- Operator definitions -->
  <!--  OpDefNode is classified according to its kinds (is NumberedProofStepKind relevant, since it is never referenced in by or use?) -->
  <xs:group name="OpDefNode">
    <xs:choice>
      <xs:element ref="ModuleInstanceKind"/>
      <xs:element ref="UserDefinedOpKind"/>
      <xs:element ref="BuiltInKind"/>
    </xs:choice>
  </xs:group>

  <!-- Represents the name of an instantiated module -->
  <xs:element name="ModuleInstanceKind">
    <xs:complexType>
      <xs:sequence>
        <xs:group ref="node"/>
        <xs:element ref="uniquename"/>
        <xs:element minOccurs="0" ref="local"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>

  <!-- An operator and its definition, arity and list of arguments -->
  <xs:element name="UserDefinedOpKind">
    <xs:complexType>
      <xs:sequence>
        <xs:group ref="node"/>
        <xs:element ref="uniquename"/>
        <xs:element ref="arity"/>
        <xs:element minOccurs="0" ref="pre-comments"/>
        <xs:element name="body">
          <xs:complexType>
            <xs:group ref="ExprNode"/>
          </xs:complexType>
        </xs:element>
        <xs:element minOccurs="0" name="params">
          <xs:complexType>
            <xs:sequence>
                <xs:element minOccurs="0" maxOccurs="unbounded" ref="leibnizparam"/>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element minOccurs="0" ref="recursive"/>
        <xs:element minOccurs="0" ref="local"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>

  <xs:element name="recursive">
    <xs:complexType/>
  </xs:element>

  <xs:element name="local">
    <xs:complexType/>
  </xs:element>

  <xs:element name="arity" type="xs:integer"/>

  <xs:element name="leibnizparam">
    <xs:complexType>
      <xs:sequence>
        <xs:element ref="FormalParamNodeRef"/>
        <xs:element minOccurs="0" ref="leibniz"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>

  <xs:element name="leibniz">
    <xs:complexType/>
  </xs:element>

  <!-- 
  The BuiltInKind node is used for all the built-in operators of TLA+ - and
  then some! In addition to all the operators you would expect like = and '
  and \in, SANY also treats various language-level operators like CASE,
  existential quantification, IF/THEN/ELSE, and even proof step types as
  built-in operators. BuiltInKind is most often found as the operator type of
  OpApplNode, where it uniquely determines the expected symbols (bound or
  unbound) and expressions in OpApplNode. The expectation is usually fairly
  clear once you are familiar with the workings of OpApplNode's bound symbols
  & operands, and the TLA+ operator in question. There are some oddities,
  however, and we try to document them here. Several built-in operators make
  use of synthetic "grouping" operators in their operands.
  -->
  <xs:element name="BuiltInKind">
    <xs:complexType>
      <xs:sequence>
        <xs:group ref="node"/>
        <xs:element name="uniquename">
       	  <xs:simpleType>
       	  	<!--
       	  	Note that some operator names need to be escaped due to XML
       	  	encoding restrictions, but when read into your program through
       	  	an XML library the strings should be represented as their non-
       	  	escaped form; ex. &lt;&gt; should be read in as <>.
       	  	-->
          	<xs:restriction base="xs:string">
              <!-- Parameterless reserved words -->
              <xs:enumeration value="FALSE"/>
              <xs:enumeration value="TRUE"/>
              <xs:enumeration value="BOOLEAN"/>
              <xs:enumeration value="STRING"/>
              <!-- Unary prefix operators -->
              <xs:enumeration value="\lnot"/>
              <xs:enumeration value="UNION"/>
              <xs:enumeration value="SUBSET"/>
              <xs:enumeration value="DOMAIN"/>
              <xs:enumeration value="ENABLED"/>
              <xs:enumeration value="UNCHANGED"/>
              <xs:enumeration value="[]"/>
              <xs:enumeration value="&lt;&gt;"/> <!-- escaped form of <> -->
              <!-- Unary postfix operators -->
              <xs:enumeration value="&apos;"/> <!-- escaped form of ', like in x' -->
              <!-- Binary infix operators -->
              <xs:enumeration value="\in"/>
              <xs:enumeration value="\notin"/>
              <xs:enumeration value="\"/>
              <xs:enumeration value="\union"/>
              <xs:enumeration value="\intersect"/>
              <xs:enumeration value="\subseteq"/>
              <xs:enumeration value="=>"/>
              <xs:enumeration value="\equiv"/>
              <xs:enumeration value="="/>
              <xs:enumeration value="/="/>
              <xs:enumeration value="\land"/>
              <xs:enumeration value="\lor"/>
              <xs:enumeration value="~>"/>
              <xs:enumeration value="\cdot"/>
              <xs:enumeration value="-+->"/>
              <!-- General built-in language operators -->
              <xs:enumeration value="$ConjList"/> <!-- Vertically-aligned conjunction -->
              <xs:enumeration value="$DisjList"/> <!-- Vertically-aligned disjunction -->
              <xs:enumeration value="$CartesianProd"/> <!-- P \X Q \X R -->
              <!--
              Note that for fairness, subscript expression comes first. For
              action-level expressions, subscript expression comes second.
              -->
              <xs:enumeration value="$WF"/> <!-- WF_vars(A) -->
              <xs:enumeration value="$SF"/> <!-- SF_vars(A) -->
              <xs:enumeration value="$SquareAct"/> <!-- [A]_vars -->
              <xs:enumeration value="$AngleAct"/> <!-- <<A>>_vars -->
              <!--
              These bounded & unbounded constructs will undoubtedly take the
              most time to deal with out of all the built-ins. Each varyingly
              allows tuples or does not, allows multiple bounds or does not,
              in a dizzying matrix. The set and function operators similarly
              use bounds, as do some of the proof steps.
              -->
              <xs:enumeration value="$BoundedChoose"/> <!-- CHOOSE e \in S : P(e) -->
              <xs:enumeration value="$UnboundedChoose"/> <!-- CHOOSE e : P(e) -->
              <xs:enumeration value="$BoundedExists"/> <!-- \E x \in S : P(x) -->
              <xs:enumeration value="$BoundedForall"/> <!-- \A x \in S : P(x) -->
              <xs:enumeration value="$UnboundedExists"/> <!-- \E x : P(x) -->
              <xs:enumeration value="$UnboundedForall"/> <!-- \A x : P(x) -->
              <xs:enumeration value="$TemporalExists"/> <!-- \EE x : P(x) -->
              <xs:enumeration value="$TemporalForall"/> <!-- \AA x : P(x) -->
              <xs:enumeration value="$SetOfAll"/> <!-- {f(e) : e \in S} -->
              <xs:enumeration value="$SubsetOf"/> <!-- {e \in S : P(e)} -->
              <xs:enumeration value="$SetEnumerate"/> <!-- {a, b, c} -->
              <xs:enumeration value="$Tuple"/> <!-- <<a, b, c>> -->
              <!-- $SetOfRcds and $RcdConstructor both use lists of $Pair operators. -->
              <xs:enumeration value="$SetOfRcds"/> <!-- [field1 : S, field2 : P] -->
              <xs:enumeration value="$RcdConstructor"/> <!-- [field1 |-> e1, field2 |-> e2] -->
              <xs:enumeration value="$RcdSelect"/> <!-- r.fieldName -->
              <xs:enumeration value="$SetOfFcns"/> <!-- [P -> Q] -->
              <!--
              The difference between $FcnConstructor and $NonRecursiveFcnSpec
              is that $FcnConstructor is used to represent anonymous functions
              like f == [e \in S |-> e], while $NonRecursiveFcnSpec is used
              to represent named functions like f[e \in S] == e. The structure
              of bound symbols and operands in the enclosing OpApplNode is
              identical in both cases. You will only find $NonRecursiveFcnSpec
              as the body of a UserDefinedOpKind, while $FcnConstructor can
              occur anywhere an expression can occur. $RecursiveFcnSpec is
              also only found in the body of a UserDefinedOpKind recursing
              on the newly-defined operator name, like f[e \in S] == f[e].
              The operator name is introduced as an unbound symbol in the
              OpApplNode, preceding the bounds for the function's arguments.
              -->
              <xs:enumeration value="$FcnConstructor"/> <!-- [e \in S |-> m(e)] -->
              <xs:enumeration value="$NonRecursiveFcnSpec"/> <!-- f[e \in S] == m(e) -->
              <xs:enumeration value="$RecursiveFcnSpec"/> <!-- f[e \in S] == f[e] -->
              <!-- Multi-parameter function application wraps arguments in a tuple. -->
              <xs:enumeration value="$FcnApply"/> <!-- f[x, y, z] -->
              <xs:enumeration value="$IfThenElse"/> <!-- IF P THEN A ELSE B -->
              <!--
              $Except operands consist of a single expression deriving the base
              function f, followed by a list of $Pair elements. The first
              operand of each $Pair is a $Seq of update expressions; example:
              ![x][y][z] would be the expression sequence x, y, z. The second
              operand of each $Pair is an expression for the updated value to
              assign to the function path. Currently there is no way to
              distinguish ![x].y.z from ![x][y][z] in update paths; record
              field selectors will be given as a string expression.
              -->
              <xs:enumeration value="$Except"/> <!-- [f EXCEPT ![x] = e] -->
              <!--
              $Case operands consist of a series of $Pair operators. The final
              $Pair instance is optionally an OTHER node, identified by the
              first operand in the $Pair being the string "$Other".
              -->
              <xs:enumeration value="$Case"/> <!-- CASE P1 -> A [] P2 -> B -->
              <xs:enumeration value="$Nop"/> <!-- Subexpressions like op!<<!>>!1!@ -->
              <!-- Proof step types -->
              <xs:enumeration value="$Pfcase"/> <!-- CASE proof step -->
              <xs:enumeration value="$Pick"/> <!-- PICK proof step -->
              <xs:enumeration value="$Take"/> <!-- TAKE proof step -->
              <xs:enumeration value="$Have"/> <!-- HAVE proof step -->
              <xs:enumeration value="$Witness"/> <!-- WITNESS proof step -->
              <xs:enumeration value="$Suffices"/> <!-- SUFFICES proof step -->
              <xs:enumeration value="$Qed"/> <!-- QED proof step -->
              <!-- Synthetic grouping operators -->
              <!--
              The $Pair operator is used whenever it is useful to group two
              expressions together within a larger list. It is used in the
              $Case, $SetOfRcds, $RcdConstructor, and $Except operators.
              -->
              <xs:enumeration value="$Pair"/>
              <!--
              The $Seq operator is used to form variable-length sub-
              groups of lists of arguments. It is only used in the $Except
              operator, to represent an update path like ![x][y][z].
              -->
              <xs:enumeration value="$Seq"/>
            </xs:restriction>
          </xs:simpleType>
        </xs:element>
        <xs:element ref="arity"/>
        <xs:element minOccurs="0" name="params">
          <xs:complexType>
            <xs:sequence>
              <xs:element minOccurs="0" maxOccurs="unbounded" ref="leibnizparam"/>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
      </xs:sequence>
    </xs:complexType>
  </xs:element>

  <xs:element name="OpArgNode">
    <xs:complexType>
      <xs:sequence>
        <xs:group ref="node"/>
        <xs:element name="argument">
          <xs:complexType>
            <xs:choice>
              <xs:element ref="FormalParamNodeRef"/>
              <xs:element ref="ModuleNodeRef"/>
              <xs:element ref="OpDeclNodeRef"/>
              <xs:group ref="OpDefNodeRef"/>
              <xs:element ref="TheoremNodeRef"/>
              <xs:element ref="AssumeNodeRef"/>
              <xs:element ref="APSubstInNode"/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
      </xs:sequence>
    </xs:complexType>
  </xs:element>

  <!-- Represents params of user definitions -->
  <xs:element name="FormalParamNode">
    <xs:complexType>
      <xs:sequence>
        <xs:group ref="node"/>
        <xs:element ref="uniquename"/>
        <xs:element ref="arity"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>

  <!-- Represents constants, variables, bound variables and new symbols -->
  <xs:element name="OpDeclNode">
    <xs:complexType>
      <xs:sequence>
        <xs:group ref="node"/>
        <xs:element ref="uniquename"/>
        <xs:element ref="arity"/>
        <xs:element name="kind">
          <xs:simpleType>
            <xs:restriction base="xs:integer">
              <xs:enumeration value="2"/> <!--ConstantDeclKind-->
              <xs:enumeration value="3"/> <!--VariableDeclKind-->
              <xs:enumeration value="4"/> <!--BoundSymbolKind-->
              <xs:enumeration value="24"/> <!--NewConstantKind-->
              <xs:enumeration value="25"/> <!--NewVariableKind-->
              <xs:enumeration value="26"/> <!--NewStateKind-->
              <xs:enumeration value="27"/> <!--NewActionKind-->
              <xs:enumeration value="28"/> <!--NewTemporalKind-->
            </xs:restriction>
          </xs:simpleType>
        </xs:element>
      </xs:sequence>
    </xs:complexType>
  </xs:element>


  <!-- Proofs -->
  <!-- The first three correspond to LeafProofNode, the last to NonLeafProofNode -->
  <xs:group name="ProofNode">
    <xs:sequence>
      <xs:group ref="node"/>
      <xs:choice>
        <xs:element ref="omitted"/>
        <xs:element ref="obvious"/>
        <xs:element ref="by"/>
        <xs:element name="steps">
          <xs:complexType>
            <xs:sequence>
              <xs:group ref="node"/>
              <xs:element name="proofLevel" type="xs:integer"/>
              <xs:sequence maxOccurs="unbounded">
                <xs:group ref="step"/>
              </xs:sequence>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
      </xs:choice>
      </xs:sequence>
  </xs:group>

  <xs:element name="omitted">
    <xs:complexType>
      <xs:group ref="node"/>
    </xs:complexType>
  </xs:element>

  <xs:element name="obvious">
    <xs:complexType>
      <xs:group ref="node"/>
    </xs:complexType>
  </xs:element>

  <!-- Facts and Defs are defined to be of these kinds according to comments in the Java code, seems step names cannot be referenced? -->
  <xs:element name="by">
    <xs:complexType>
      <xs:sequence>
        <xs:group ref="node"/>
        <xs:element name="facts">
          <xs:complexType>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
              <xs:group ref="ExprNode"/>
              <xs:element ref="ModuleNodeRef"/>
              <xs:element ref="ModuleInstanceKind"/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name="defs">
          <xs:complexType>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
              <xs:element ref="UserDefinedOpKindRef"/>
              <xs:element ref="ModuleInstanceKindRef"/>
              <xs:element ref="TheoremDefRef"/>
              <xs:element ref="AssumeDefRef"/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element minOccurs="0" ref="only"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>

  <xs:element name="only">
    <xs:complexType/>
  </xs:element>

  <!-- Steps are defined to be of this types according to comments in the Java code -->
  <xs:group name="step">
    <xs:choice>
      <xs:element ref="DefStepNode"/>
      <xs:element ref="UseOrHideNode"/>
      <xs:element ref="InstanceNode"/>
      <xs:element ref="TheoremNodeRef"/>
      <xs:element ref="TheoremNode"/> <!-- in case of unnamed theorem -->
    </xs:choice>
  </xs:group>

  <xs:element name="DefStepNode">
    <xs:complexType>
      <xs:sequence>
        <xs:group ref="node"/>
        <xs:group maxOccurs="unbounded" ref="OpDefNodeRef"/>
      </xs:sequence>
    </xs:complexType>
<!--        <xs:element minOccurs="0" ref="stepnumber"/> this is cancelled out as it is not clear what exactly is referenced by USE facts (or BY proofs)
when the xml is generated, check what for the stepnumber take (maybe as simple strings? then we need to return this field)-->
  </xs:element>

  <xs:element name="UseOrHideNode">
    <xs:complexType>
      <xs:sequence>
        <xs:group ref="node"/>
        <xs:element name="facts">
          <xs:complexType>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
              <xs:group ref="ExprNode"/>
              <xs:element ref="ModuleNodeRef"/>
              <xs:element ref="ModuleInstanceKind"/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name="defs">
          <xs:complexType>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
              <xs:element ref="UserDefinedOpKindRef"/>
              <xs:element ref="ModuleInstanceKindRef"/>
              <xs:element ref="TheoremNodeRef"/>
              <xs:element ref="AssumeNodeRef"/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element minOccurs="0" ref="only"/>
        <xs:element minOccurs="0" ref="hide"/>
<!--        <xs:element minOccurs="0" ref="stepnumber"/> this is cancelled out as it is not clear what exactly is referenced by USE facts (or BY proofs)
when the xml is generated, check what for the stepnumber take (maybe as simple strings? then we need to return this field)-->
      </xs:sequence>
    </xs:complexType>
  </xs:element>

  <xs:element name="hide">
    <xs:complexType/>
  </xs:element>

  <xs:element name="stepnumber" type="xs:string"/>


  <!-- Expressions -->
  <!-- Occurrences of @ by supplying the innermost enclosing $Except and the innermost $Pair containing this @ -->
  <xs:element name="AtNode">
    <xs:complexType>
      <xs:sequence>
        <xs:group ref="node"/>
        <xs:choice> <!-- expression -->
          <xs:group ref="ExprNode"/>
          <xs:element ref="OpArgNode"/>
        </xs:choice>
        <xs:choice> <!-- component sequence -->
          <xs:group ref="ExprNode"/>
          <xs:element ref="OpArgNode"/>
        </xs:choice>
      </xs:sequence>
    </xs:complexType>
  </xs:element>

  <!-- A decimal number (read Java code and java API for more information)-->
  <xs:element name="DecimalNode">
    <xs:complexType>
      <xs:sequence>
        <xs:group ref="node"/>
        <xs:element name="mantissa" type="xs:integer"/>
        <xs:element name="exponent" type="xs:integer"/>
        <xs:element name="integralPart" type="xs:integer"/>
        <xs:element name="fractionalPart" type="xs:integer"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>

  <!-- Represents a labeled expression nm(x,y): (ExprNode|AssumeProveNode) -->
  <xs:element name="LabelNode">
    <xs:complexType>
      <xs:sequence>
        <xs:group ref="node"/>
        <xs:element ref="uniquename"/>
        <xs:element ref="arity"/>
        <xs:element name="body">
          <xs:complexType>
            <xs:choice>
              <xs:group ref="ExprNode"/>
              <xs:group ref="AssumeProveLike"/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name="params">
          <xs:complexType>
            <xs:sequence minOccurs="0" maxOccurs="unbounded">
              <xs:element ref="FormalParamNodeRef"/>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
      </xs:sequence>
    </xs:complexType>
  </xs:element>

  <!-- A list of definitions and the body -->
  <xs:element name="LetInNode">
    <xs:complexType>
      <xs:sequence>
        <xs:group ref="node"/>
        <xs:element name="body">
          <xs:complexType>
            <xs:group ref="ExprNode"/>
          </xs:complexType>
        </xs:element>
        <xs:element name="opDefs">
          <xs:complexType>
            <xs:choice maxOccurs="unbounded">
              <xs:group ref="OpDefNodeRef"/>
              <xs:element ref="TheoremNodeRef"/>
              <xs:element ref="TheoremNode"/> <!-- in case of unnamed theorem -->
              <xs:element ref="AssumeNodeRef"/>
              <xs:element ref="AssumeNode"/> <!-- in case of unnamed theorem -->
            </xs:choice>
          </xs:complexType>
        </xs:element>
      </xs:sequence>
    </xs:complexType>
  </xs:element>

  <!-- An integer number -->
  <xs:element name="NumeralNode">
    <xs:complexType>
        <xs:sequence>
            <xs:group ref="node"/>
            <xs:element name="IntValue" type="xs:integer"/>
        </xs:sequence>
    </xs:complexType>
  </xs:element>

  <!-- An string -->
  <xs:element name="StringNode">
    <xs:complexType>
        <xs:sequence>
            <xs:group ref="node"/>
            <xs:element name="StringValue"/>
        </xs:sequence>
    </xs:complexType>
  </xs:element>

  <!-- A general node for applications. FIrst the operator and then the operands -->
  <xs:element name="OpApplNode">
    <xs:complexType>
      <xs:sequence>
        <xs:group ref="node"/>
        <xs:element name="operator">
          <xs:complexType>
            <xs:choice>
              <xs:element ref="FormalParamNodeRef"/>
              <xs:element ref="ModuleNodeRef"/>
              <xs:element ref="OpDeclNodeRef"/>
              <xs:group ref="OpDefNodeRef"/>
              <xs:element ref="TheoremNodeRef"/>
              <xs:element ref="AssumeNodeRef"/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name="operands">
          <xs:complexType>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
              <xs:group ref="ExprNode"/>
              <xs:element ref="OpArgNode"/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name="boundSymbols" minOccurs="0">
          <xs:complexType>
            <xs:choice maxOccurs="unbounded">
              <xs:element ref="unbound"/>
              <xs:element ref="bound"/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
      </xs:sequence>
    </xs:complexType>
  </xs:element>

  <xs:element name="unbound">
    <xs:complexType>
      <xs:sequence>
        <xs:element ref="FormalParamNodeRef"/>
        <xs:element minOccurs="0" ref="tuple"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>

  <xs:element name="bound">
    <xs:complexType>
      <xs:sequence>
        <xs:element maxOccurs="unbounded" ref="FormalParamNodeRef"/>
        <xs:element minOccurs="0" ref="tuple"/>
        <xs:group ref="ExprNode"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>

  <!-- this is just a flag signaling that the referenced parameter is a tuple -->
  <xs:element name="tuple">
    <xs:complexType/>
  </xs:element>

  <!-- Module(constants,variables,operators,assumptions,theorems) -->
  <xs:element name="ModuleNode">
    <xs:complexType>
      <xs:sequence>
        <xs:group ref="node"/>
        <xs:element ref="uniquename"/>
        <xs:element name="extends">
          <xs:complexType>
            <xs:sequence>
              <xs:element ref="uniquename" minOccurs="0" maxOccurs="unbounded"/>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:sequence minOccurs="0" maxOccurs="unbounded">
        <xs:choice>
          <xs:element ref="OpDeclNodeRef"/>
          <xs:group   ref="OpDefNodeRef"/>
          <xs:element ref="AssumeNodeRef"/>
          <xs:element ref="InstanceNode"/>
          <xs:element ref="UseOrHideNode"/>
          <xs:element ref="TheoremNodeRef"/>
        </xs:choice>
        </xs:sequence>
      </xs:sequence>
    </xs:complexType>
  </xs:element>

</xs:schema>
