// Copyright (c) 2003 Compaq Corporation.  All rights reserved.
// Portions Copyright (c) 2003 Microsoft Corporation.  All rights reserved.
// Last modified on Mon 30 Apr 2007 at 15:29:56 PST by lamport
//      modified on Thu Jan 10 11:22:26 PST 2002 by yuanyu

package tlc2.tool;

import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.atomic.*;

import tla2sany.modanalyzer.SpecObj;
import tla2sany.semantic.SemanticNode;
import tlc2.TLCGlobals;
import tlc2.output.EC;
import tlc2.output.MP;
import tlc2.output.StatePrinter;
import tlc2.tool.liveness.ILiveCheck;
import tlc2.tool.liveness.LiveCheck;
import tlc2.tool.liveness.LiveCheck1;
import tlc2.tool.liveness.LiveException;
import tlc2.tool.liveness.NoOpLiveCheck;
import tlc2.util.ObjLongTable;
import tlc2.util.RandomGenerator;
import tlc2.util.statistics.DummyBucketStatistics;
import tlc2.value.Value;
import util.FileUtil;
import util.FilenameToStream;

public class Simulator implements Cancelable {

	public static boolean EXPERIMENTAL_LIVENESS_SIMULATION = Boolean.getBoolean(Simulator.class.getName() + ".experimentalLiveness");
	

	/* Constructors */
	/**
	 * SZ Feb 20, 2009: added the possibility to pass the SpecObject, this is
	 * compatibility constructor
	 * @throws IOException 
	 *
	 * @deprecated use
	 *             {@link Simulator#Simulator(String, String, String, boolean, int, long, RandomGenerator, long, boolean, FilenameToStream, SpecObj)}
	 *             instead and pass the <code>null</code> as SpecObj
	 */
	public Simulator(String specFile, String configFile, String traceFile, boolean deadlock, int traceDepth,
			long traceNum, RandomGenerator rng, long seed, boolean preprocess, FilenameToStream resolver) throws IOException {
		this(specFile, configFile, traceFile, deadlock, traceDepth, traceNum, rng, seed, preprocess, resolver, null);
	}

	public Simulator(String specFile, String configFile, String traceFile, boolean deadlock, int traceDepth,
			long traceNum, RandomGenerator rng, long seed, boolean preprocess, FilenameToStream resolver,
			SpecObj specObj) throws IOException {
		// Default to 1 worker thread if not specified.
		this(specFile, configFile, traceFile, deadlock, traceDepth, traceNum, rng, seed, preprocess, resolver, specObj, 1);
	}

	// SZ Feb 20, 2009: added the possibility to pass the SpecObject
	public Simulator(String specFile, String configFile, String traceFile, boolean deadlock, int traceDepth,
			long traceNum, RandomGenerator rng, long seed, boolean preprocess, FilenameToStream resolver,
			SpecObj specObj, int numWorkers) throws IOException {
		int lastSep = specFile.lastIndexOf(FileUtil.separatorChar);
		String specDir = (lastSep == -1) ? "" : specFile.substring(0, lastSep + 1);
		specFile = specFile.substring(lastSep + 1);

		// SZ Feb 24, 2009: setup the user directory
		// SZ Mar 5, 2009: removed it again because of the bug in simulator
		// ToolIO.setUserDir(specDir);

		this.tool = new Tool(specDir, specFile, configFile, resolver);

		this.tool.init(preprocess, specObj); // parse and process the spec

		this.checkDeadlock = deadlock;
		this.checkLiveness = !this.tool.livenessIsTrue();
		this.actions = this.tool.getActions();
		this.invariants = this.tool.getInvariants();
		this.impliedActions = this.tool.getImpliedActions();
		if (traceDepth != -1) {
			// this.actionTrace = new Action[traceDepth]; // SZ: never read
			// locally
			this.traceDepth = traceDepth;
		} else {
			// this.actionTrace = new Action[0]; // SZ: never read locally
			this.traceDepth = Long.MAX_VALUE;
		}
		this.traceFile = traceFile;
		this.traceNum = traceNum;
		this.rng = rng;
		this.seed = seed;
		this.aril = 0;
		this.astCounts = new ObjLongTable(10);
		this.numWorkers = numWorkers;
		// Initialization for liveness checking
		if (this.checkLiveness) {
			if (EXPERIMENTAL_LIVENESS_SIMULATION) {
				final String tmpDir = System.getProperty("java.io.tmpdir");
				liveCheck = new LiveCheck(this.tool, new Action[0], tmpDir, new DummyBucketStatistics());
			} else {
				liveCheck = new LiveCheck1(this.tool);
			}
		} else {
			liveCheck = new NoOpLiveCheck(tool, specDir);
		}
	}

	/* Fields */
	private final ILiveCheck liveCheck;
	private final Tool tool;
	private final Action[] actions; // the sub actions
	private final Action[] invariants; // the invariants to be checked
	private final Action[] impliedActions; // the implied-actions to be checked
	private final boolean checkDeadlock; // check deadlock?
	private final boolean checkLiveness; // check liveness?
	
	// The total number of states generated by all workers. Written to concurrently.
	private AtomicLong numOfGenStates;
	
	// private Action[] actionTrace; // SZ: never read locally
	private final String traceFile;

	// The maximum length of a simulated trace.
	private final long traceDepth;

	// The maximum number of total traces to generate.
	private final long traceNum;

	// The number of worker threads to use for simulation.
	private int numWorkers = 1;

	private final RandomGenerator rng;
	private final long seed;
	private long aril;
	private final ObjLongTable astCounts;
	private boolean isCancelled; // SZ Feb 24, 2009: cancellation added
	private Value[] localValues = new Value[4];

	// The set of all initial states for the given spec. This should be only be
	// computed once and re-used whenever a new random trace is generated. This
	// variable should not be written to concurrently, but is allowed to be read
	// concurrently.
	private StateVec initStates = new StateVec(0);

	// Appended to when a simulation worker completes. We only care about the first
	// worker that completes, which is why this queue has a capacity of 1.
	private BlockingQueue<SimulationWorkerResult> workerFinishedErrChannel = new LinkedBlockingQueue<>(1);

	/**
	 * A struct that encapsulates information about a result produced during random
	 * trace simulation.
	 */
	class SimulationWorkerResult {

		public SimulationWorkerResult(int errorCode, String[] parameters, TLCState state, StateVec stateTrace, Exception e) {
			this.errorCode = errorCode;
			this.parameters = parameters;
			this.state = state;
			this.stateTrace = stateTrace;
			this.exception = e;
		}

		public Boolean isError() {
			return this.errorCode != 0;
		}

		// The error code to report. An error code of zero represents a non-error
		// result.
		public int errorCode;

		// Any additional information to be included in a reported error string.
		public String[] parameters;

		// The TLC state associated with the error.
		public TLCState state;

		// The TLC trace associated with the error.
		public StateVec stateTrace;
		
		// An exception associated with the error.
		public Exception exception;
	}

	/**
	 * A SimulationWorker repeatedly checks random traces of the spec. It is
	 * constructed with an initial seed which it uses to initialize its internal
	 * random number generator.
	 */
	class SimulationWorker extends Thread {

		RandomGenerator localRng;
		
		// Flag that is used to signal shutdown of this worker.
		private AtomicBoolean running = new AtomicBoolean(false);
		
		// Result value to be returned by this worker.
		private SimulationWorkerResult errInfo = null;
		
		// A unique id for this worker thread.
		private int id;

		// Tracks the number of traces that have been generated so far.
		private int traceCnt = 0;

		public SimulationWorker(int id, long seed) {
			this.id = id;
			this.localRng = new RandomGenerator(seed);
		}

		public void kill() {
			this.running.getAndSet(false);
		}

		/**
		 * The main worker loop. Continually generates random traces until there is an
		 * error or until we hit the trace count limit.
		 */
		public final void run() {
			this.running.set(true);
			while (this.running.get()) {
				try {
					Boolean traceOk = simulateRandomTrace();
					traceCnt++;
					// See if we should generate another trace.
					if (!traceOk) {
						if (this.errInfo != null) {
							workerFinishedErrChannel.offer(this.errInfo);
						}
						return;
					}
					// Each worker independently abides by the maximum trace generation count.
					if (traceCnt > traceNum) {
						workerFinishedErrChannel.offer(new SimulationWorkerResult(0, null, null, null, null));
						return;
					}
				} catch (Exception e) {
					workerFinishedErrChannel.offer(new SimulationWorkerResult(0, null, null, null, e));
					return;
				}
			}
		}

		/**
		 * Generates a single random trace.
		 *
		 * The core steps of this process are as follows:
		 * 
		 *  a) Pick one of the initial states. 
		 *  b) Randomly pick an action to generate the successor states (more than 1) to the current initial state. 
		 *  c) Check all of the generated successors for their validity. 
		 *  d) Randomly pick a generated successor and make it the new current state.
		 *
		 * Returns true if the simulation worker should generate another random trace.
		 * Returns false if it should stop generating traces and terminate.
		 *
		 * @param theInitStates
		 */
		private Boolean simulateRandomTrace() throws Exception {
			TLCState curState = null;
			final StateVec stateTrace = new StateVec((int) traceDepth);
			stateTrace.clear();

			aril = rng.getAril();

			// a) Randomly select a state from the set of init states.
			curState = randomState(this.localRng, initStates);

			boolean inConstraints = tool.isInModel(curState);

			// Simulate a trace up to the maximum specified length.
			for (int traceIdx = 0; traceIdx < traceDepth; traceIdx++) {
				// Check for cancellation.
				if (!this.running.get()) {
					return false;
				}

				// Add the curState to the trace regardless of its inModel property.
				stateTrace.addElement(curState);

				// Make sure this state satisfies the model constraints.
				if (!inConstraints) {
					break;
				}

				// b) Get the current state's successor states.
				StateVec nextStates = randomNextStates(this.localRng, curState);
				if (nextStates == null) {
					if (checkDeadlock) {
						// We get here because of deadlock.
						this.errInfo = new SimulationWorkerResult(EC.TLC_DEADLOCK_REACHED, null, curState, stateTrace, null);
						return TLCGlobals.continuation;
					}
					break;
				}

				// c) Check all generated next states before all but one are discarded.
				for (int i = 0; i < nextStates.size(); i++) {
					numOfGenStates.incrementAndGet();
					TLCState state = nextStates.elementAt(i);

					if (TLCGlobals.coverageInterval >= 0) {
						((TLCStateMutSource) state).addCounts(astCounts);
					}

					if (!tool.isGoodState(state)) {
						this.errInfo = new SimulationWorkerResult(EC.TLC_STATE_NOT_COMPLETELY_SPECIFIED_NEXT, null, state, stateTrace, null);
						return false;
					}
					

					// Check invariants.
					int idx = 0;
					try {
						for (idx = 0; idx < invariants.length; idx++) {
							if (!tool.isValid(invariants[idx], state)) {
								// We get here because of an invariant violation.
								this.errInfo = new SimulationWorkerResult(EC.TLC_INVARIANT_VIOLATED_BEHAVIOR,
										new String[] { tool.getInvNames()[idx] }, state, stateTrace, null);
								// We may want to continue simulating even after encountering an invariant
								// violation.
								return TLCGlobals.continuation;
							}
						}
					} catch (Exception e) {
						this.errInfo = new SimulationWorkerResult(EC.TLC_INVARIANT_EVALUATION_FAILED,
								new String[] { tool.getInvNames()[idx], e.getMessage() }, state, stateTrace, e);
						return false;
					}

					// Check action properties.
					try {
						for (idx = 0; idx < impliedActions.length; idx++) {
							if (!tool.isValid(impliedActions[idx], curState, state)) {
								// We get here because of implied-action violation.
								this.errInfo = new SimulationWorkerResult(EC.TLC_ACTION_PROPERTY_VIOLATED_BEHAVIOR,
										new String[] { tool.getImpliedActNames()[idx] }, state, stateTrace, null);
								return TLCGlobals.continuation;
							}
						}
					} catch (Exception e) {
						this.errInfo = new SimulationWorkerResult(EC.TLC_ACTION_PROPERTY_EVALUATION_FAILED,
								new String[] { tool.getImpliedActNames()[idx], e.getMessage() }, state, stateTrace, e);
						return false;
					}

				}

				// At this point all generated successor states have been checked for
				// their respective validity (isGood/isValid/impliedActions/...).

				// d) Randomly select one of them and make it the current state for the next
				// iteration of the loop.
				TLCState s1 = randomState(rng, nextStates);
				inConstraints = (tool.isInModel(s1) && tool.isInActions(curState, s1));
				curState = s1;
			}

			// Check if the current trace satisfies liveness properties.
			liveCheck.checkTrace(stateTrace);

			// Write the trace out if desired. The trace is printed in the
			// format of TLA module, so that it can be read by TLC again.
			if (traceFile != null) {
				// Make sure each worker outputs to its own set of trace files.
				String fileName = traceFile + "_" + String.valueOf(this.id) + "_" + this.traceCnt;
				// TODO is it ok here?
				PrintWriter pw = new PrintWriter(FileUtil.newBFOS(fileName));
				pw.println("---------------- MODULE " + fileName + " -----------------");
				for (int idx = 0; idx < stateTrace.size(); idx++) {
					pw.println("STATE_" + (idx + 1) + " == ");
					pw.println(stateTrace.elementAt(idx) + "\n");
				}
				pw.println("=================================================");
				pw.close();
			}

			return true;
		}
	}

	/*
	 * This method does random simulation on a TLA+ spec. 
	 * 
	 * It runs until en error is encountered or we have generated the maximum number of traces.
	 */
	public void simulate() throws Exception {
		TLCState curState = null;

		if (isCancelled) {
			return;
		}

		//
		// Compute the initial states.
		//
		try {

			// The init states are calculated only ever once and never change
			// in the loops below. Ideally the variable would be final.
			this.initStates = this.tool.getInitStates();

			this.numOfGenStates = new AtomicLong(this.initStates.size());

			// Check all initial states for validity.
			for (int i = 0; i < this.initStates.size(); i++) {
				curState = this.initStates.elementAt(i);
				if (this.tool.isGoodState(curState)) {
					for (int j = 0; j < this.invariants.length; j++) {
						if (!this.tool.isValid(this.invariants[j], curState)) {
							// We get here because of invariant violation.
							MP.printError(EC.TLC_INVARIANT_VIOLATED_INITIAL,
									new String[] { this.tool.getInvNames()[j], curState.toString() });
							return;
						}
					}
				} else {
					MP.printError(EC.TLC_STATE_NOT_COMPLETELY_SPECIFIED_INITIAL, curState.toString());
					return;
				}
			}
		} catch (Exception e) {
			if (curState != null) {
				MP.printError(EC.TLC_INITIAL_STATE,
						new String[] { (e.getMessage() == null) ? e.toString() : e.getMessage(), curState.toString() });
			} else {
				MP.printError(EC.GENERAL, e); // LL changed call 7 April 2012
			}

			this.printSummary();
			return;
		}

		if (this.numOfGenStates.get() == 0) {
			MP.printError(EC.TLC_NO_STATES_SATISFYING_INIT);
			return;
		}

		// It appears deepNormalize brings the states into a canonical form to
		// speed up equality checks.
		this.initStates.deepNormalize();

		//
		// Start progress report thread.
		//
		final ProgressReport report = new ProgressReport();
		report.start();

		//
		// Start simulating.
		//
		try {
			this.aril = rng.getAril();
			// Start up multiple simulation worker threads, each with their own unique seed.
			MP.printMessage(EC.GENERAL, "Starting " + String.valueOf(this.numWorkers) + " simulation workers.");
			ArrayList<SimulationWorker> workers = new ArrayList<>();
			for (int i = 0; i < this.numWorkers; i++) {
				SimulationWorker worker = new SimulationWorker(i, this.rng.nextLong());
				worker.start();
				workers.add(worker);
			}

			// Block until one of the worker threads completes.
			SimulationWorkerResult errInfo = workerFinishedErrChannel.take();

			// If there is an error, print it. If there is no error, this should imply we've simply reached
			// the trace count limit, and so should terminate.
			if (errInfo.isError()) {
				printBehavior(errInfo);
			} 
			
			// Print a summary in case of a liveness error.
			if(errInfo.exception != null && errInfo.exception instanceof LiveException) {
				this.printSummary();
			}

			// Shut down all workers and make sure they have stopped.
			for (SimulationWorker worker : workers) {
				worker.kill();
				worker.join();
			}

		} catch (Throwable e) {
			// TODO: This catch block can be removed? (WS 2018)
//			if (e instanceof LiveException) {
//				this.printSummary();
//			} else {
				// LL modified error message on 7 April 2012
//				this.printBehavior(EC.GENERAL, new String[] { MP.ECGeneralMsg("", e) }, curState, stateTrace);
//			}
		} finally {
			report.isRunning = false;
			synchronized (report) {
				report.notify();
			}
			// Wait for the progress reporter thread to finish.
			report.join();
		}
	}

	public final void printBehavior(SimulationWorkerResult errInfo) {
		printBehavior(errInfo.errorCode, errInfo.parameters, errInfo.state, errInfo.stateTrace);
	}

	/**
	 * Prints out the simulation behavior, in case of an error. (unless we're at
	 * maximum depth, in which case don't!)
	 */
	public final void printBehavior(int errorCode, String[] parameters, TLCState state, final StateVec stateTrace) {

		MP.printError(errorCode, parameters);
		if (this.traceDepth == Long.MAX_VALUE) {
			MP.printMessage(EC.TLC_ERROR_STATE);
			StatePrinter.printState(state);
		} else {
			MP.printError(EC.TLC_BEHAVIOR_UP_TO_THIS_POINT);
			TLCState lastState = null;
			for (int i = 0; i < stateTrace.size(); i++) {
				StatePrinter.printState(stateTrace.elementAt(i), lastState, i + 1);
				lastState = stateTrace.elementAt(i);
			}
			StatePrinter.printState(state, null, stateTrace.size() + 1);
		}
		this.printSummary();
	}

	/**
	 * This method returns a state that is randomly chosen from the set of states.
	 * It returns null if the set of states is empty.
	 */
	public final TLCState randomState(RandomGenerator rng, StateVec states) throws EvalException {
		int len = states.size();
		if (len > 0) {
			int index = (int) Math.floor(rng.nextDouble() * len);
			return states.elementAt(index);
		}
		return null;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see tlc2.tool.Cancelable#setCancelFlag(boolean)
	 */
	public void setCancelFlag(boolean flag) {
		this.isCancelled = flag;
	}

	/**
	 * This method returns the set of next states generated by a randomly chosen
	 * action. It returns null if there is no possible next state.
	 */
	public final StateVec randomNextStates(RandomGenerator rng, TLCState state) {
		int len = this.actions.length;
		int index = (int) Math.floor(rng.nextDouble() * len);
		int p = rng.nextPrime();
		for (int i = 0; i < len; i++) {
			StateVec pstates = this.tool.getNextStates(this.actions[index], state);
			if (!pstates.empty()) {
				return pstates;
			}
			index = (index + p) % len;
		}
		return null;
	}

	public Value getLocalValue(int idx) {
		if (idx < this.localValues.length) {
			return this.localValues[idx];
		}
		return null;
	}

	public void setLocalValue(int idx, Value val) {
		if (idx >= this.localValues.length) {
			Value[] vals = new Value[idx + 1];
			System.arraycopy(this.localValues, 0, vals, 0, this.localValues.length);
			this.localValues = vals;
		}
		this.localValues[idx] = val;
	}

	/**
	 * Prints the summary
	 */
	public final void printSummary() {
		this.reportCoverage();

		/*
		 * This allows the toolbox to easily display the last set of state space
		 * statistics by putting them in the same form as all other progress 
		 * statistics.
		 */
		if (TLCGlobals.tool) {
			MP.printMessage(EC.TLC_PROGRESS_SIMU, String.valueOf(numOfGenStates.get()));
		}

		MP.printMessage(EC.TLC_STATS_SIMU, new String[] { String.valueOf(numOfGenStates.get()),
				String.valueOf(this.seed), String.valueOf(this.aril) });
	}

	/**
	 * Reports coverage
	 */
	public final void reportCoverage() {
		if (TLCGlobals.coverageInterval >= 0) {
			MP.printMessage(EC.TLC_COVERAGE_START);
			ObjLongTable counts = this.tool.getPrimedLocs();
			ObjLongTable.Enumerator keys = this.astCounts.keys();
			Object key;
			while ((key = keys.nextElement()) != null) {
				String loc = ((SemanticNode) key).getLocation().toString();
				counts.add(loc, astCounts.get(key));
			}
			Object[] skeys = counts.sortStringKeys();
			for (int i = 0; i < skeys.length; i++) {
				long val = counts.get(skeys[i]);
				MP.printMessage(EC.TLC_COVERAGE_VALUE, new String[] { skeys[i].toString(), String.valueOf(val) });
			}
			MP.printMessage(EC.TLC_COVERAGE_END);
		}
	}

	/**
	 * Reports progress information
	 */
	final class ProgressReport extends Thread {

		volatile boolean isRunning = true;

		public void run() {
			int count = TLCGlobals.coverageInterval / TLCGlobals.progressInterval;
			try {
				while (isRunning) {
					synchronized (this) {
						this.wait(TLCGlobals.progressInterval);
					}
					MP.printMessage(EC.TLC_PROGRESS_SIMU, String.valueOf(numOfGenStates.get()));
					if (count > 1) {
						count--;
					} else {
						reportCoverage();
						count = TLCGlobals.coverageInterval / TLCGlobals.progressInterval;
					}
				}
			} catch (Exception e) {
				// SZ Jul 10, 2009: changed from error to bug
				MP.printTLCBug(EC.TLC_REPORTER_DIED, null);
			}
		}
	}
}
