// last modified on Mon 15 September 2008 at  7:46:37 PST by lamport



/*********************************************

This file was modified by LL beginning 5 Mar 2007 for the TLA+2
language.  

It is based on the version received from J-Ch on 26 Feb 2007 and then
modified with him during his visit 28 Feb - 2 Mar 2007.

Still need to 
- FIgure out what to do with FairnessExpr if we're to allow
  something like WF_+(x,y)(A) or perhaps even
  SF_Foo!<<!(1,3)(A)

-----

This is the javacc source file for the parser.  JavaCC generates the
following files:
   parser/SimpleCharStream.java
   parser/TLAplusParser.java
   parser/TLAplusParserConstants.java
   parser/TLAplusParserTokenManager.java
   parser/ParseException.java
   parser/Token.java
   parser/TokenMgrError.java

The last three should not be confused with the files of the same name
in configuration/, which were generated by javacc from the file
config.jj.

**********************************/


/***************************************************************************
* ERROR HANDLING                                                           *
* --------------                                                           *
* Errors are reported in two ways.  The common method is                   *
*                                                                          *
*   throw new ParseException("Some helpful error message.")                *
*                                                                          *
* The error message should be helpful enough to indiciate the location of  *
* the error with syntaxTreenodeObject.getLocation().toString() This        *
* interrupts the parsing.  Another method that's only used in two places   *
* is                                                                       *
*                                                                          *
*    PErrors.push(new ParseERror("Helpful error message"))                 *
*                                                                          *
* The parsing continues and the error is reported when parsing ends,       *
* either by parsing the complete input or by an exception being thrown.    *
* At that point, the error is reported.                                    *
***************************************************************************/


// Copyright (c) 2003 Compaq Corporation.  All rights reserved.

// WARNING - order of definition of tokens *does* matter : check ClosedExpressionOrOp
  /*************************************************************************
  * ClosedExpressionOrOp is irrelevant here.  The "order of definition of  *
  * tokens" in this file determines the actual numbers assigned to the     *
  * `kind' fields of the tokens.  (Those assignemnts are put by the        *
  * parser in TLAplusParserConstants.java.)  These values are used in the  *
  * definitions of isOp and is...fixOp, which I imagine are called         *
  * somewhere in methods called by methods called by ...  methods called   *
  * by ClosedExpressionOrOp.  The other thing to note is that the values   *
  * of token `kind' fields must be different from those of nodes' kind     *
  * fields, which are defined in st/SyntaxTreeConstants.java.              *
  *************************************************************************/
  

// Handling of FieldName : when the token is a keywork, the type of the token is changed to IDENTIFIER, and then we proceed with regular Identifier() handling.

// FairnessHook is used to capture a list of parameters of OpApl, to reattach later to a fairness node. Works only because WF_ forms are not recursive. Must be suitably reset.

// 30/11/2002, removed LOCAL from THEOREM, ASSUMPTION
// 30/11/2002, added NUMBER_CONSTANTS forms for \b, \o and \f
// 4/9/2006, modified belchDef to improve error location in case of wrong definition LHS: ( ... ) == 
// --- modified handling of STRING_LITERAL to reduce escape sequences to char values..

options {
  LOOKAHEAD = 1;
  JAVA_UNICODE_ESCAPE = false; // disable processing of \\u
  UNICODE_INPUT = false;
  DEBUG_PARSER = false;    // true;  
  DEBUG_LOOKAHEAD = false; // true; 
  DEBUG_TOKEN_MANAGER = false; // true; 
  STATIC = false;
}

PARSER_BEGIN(TLAplusParser)

package tla2sany.parser;

import tla2sany.st.ParseTree;
import tla2sany.st.TreeNode;

import tla2sany.utilities.Vector;
import tla2sany.utilities.Stack;
import tla2sany.utilities.Assert;
import util.UniqueString;
import util.ToolIO;

public class TLAplusParser implements tla2sany.st.SyntaxTreeConstants, ParseTree {

  public String[] dependencies() {
    /***********************************************************************
    * This method is used in modanalyzer/{SyntaxTreePrinter,ParserUnit}.   *
    ***********************************************************************/
    String[]deps = new String[ dependencyList.size() ];
    for (int lvi =0; lvi < deps.length; lvi++)
      deps[lvi] = ((UniqueString)dependencyList.elementAt(lvi)).toString();
    return deps;
  }
  public TreeNode rootNode() { return ParseTree; }
  public String moduleName() { return mn.toString(); }
//  public tla2sany.st.ParseErrors getErrors() { return PErrors; } Unused, apparently
// The front end can simply read the public PErrors.

  public SyntaxTreeNode ParseTree;
    /***********************************************************************
    * The root node.                                                       *
    ***********************************************************************/

  public Vector dependencyList = new Vector( 20 );

  private UniqueString mn = null;
     /**********************************************************************
     * The module name.                                                    *
     **********************************************************************/

  private boolean numberFlag = false;
  private boolean decimalFlag = false;

  private Operator FcnOp = Operators.getOperator( UniqueString.uniqueStringOf("[" ));
  private SyntaxTreeNode FairnessHook;

  private UniqueString At = UniqueString.uniqueStringOf("@");

  ParseErrors PErrors = new ParseErrors();

  private tla2sany.parser.OperatorStack OperatorStack = new tla2sany.parser.OperatorStack( PErrors );

  private BracketStack BStack;
    /***********************************************************************
    * This is a stack of the kinds and offsets of the tokens that start a  *
    * bulleted list within which the parser is currently grabbing tokens.  *
    ***********************************************************************/

  public boolean parse() {
    /***********************************************************************
    * This is a wrapper for actual parsing procedure CompilationUnit().    *
    * If an exception occurs, or if an error was pushed onto PErrors,      *
    * then an error message is printed and it returns false.  Otherwise,   *
    * it returns true.  Note that if we want to be able to parse an        *
    * expression, we need to implement a similar wrapper for               *
    * Expression().                                                        *
    ***********************************************************************/
    
    /***********************************************************************
    * The following code sets BStack to a new BracketStack object and      *
    * initializes its classes field as described in BracketStack.java.     *
    ***********************************************************************/
    BStack = new BracketStack();
    BStack.newClass();
//    BStack.registerInCurrentClass( BAND );
    BStack.registerInCurrentClass( AND );
    BStack.newClass();
//    BStack.registerInCurrentClass( BOR );
    BStack.registerInCurrentClass( OR );
    BStack.newClass();
    BStack.registerInCurrentClass( PROOF );
    BStack.newClass();
    BStack.registerInCurrentClass( LBR );
    BStack.newClass();
    BStack.registerInCurrentClass( ASSUME );

    try { ParseTree = CompilationUnit(); } 
    catch( ParseException e ) {
         PErrors.push( new ParseError( msgStackToString(e) ) ); }  
    catch( TokenMgrError tme ) {
      // lexical error.
      String msg = tme.getMessage();
      int bl = jj_input_stream.getBeginLine() + 1;
      int el = jj_input_stream.getEndLine() + 1;
      // lexical error.
      if ( (msg.indexOf("EOF") != -1) && (bl != el) )  {
        PErrors.push(new ParseError(
                  "Lexical {error: EOF reached, " + 
                  "possibly open comment starting around line " + 
                  (bl-1) )) ;
      } else  PErrors.push( new ParseError( msg  )) ;
//      PErrors.push( new ParseError( tme.getMessage() )) ;
    } /*** end catch(TokenMgrError) ****/
    if ( PErrors.empty() ) Assert.assertion( heirsIndex == 0 );
      /*********************************************************************
      * This is a sanity check.  The assertion should never be false.      *
      *********************************************************************/
    else {
      /*********************************************************************
      * An error has been pushed onto PErrors.  It might have been done    *
      * when an exception was caught, or by detecting an error during the  *
      * parsing without throwing an exception.  This happens in            *
      * ExceptComponent() if it finds "!.@", and in FairnessExpr().        *
      *********************************************************************/
      tla2sany.st.ParseError  list[] = PErrors.errors();
      for (int i = 0; i < list.length; i++ ) {
        ToolIO.out.println( list[i].reportedError() );
//        ToolIO.out.println( "+ " + list[i].defaultError() );
      }
    }
//   ParseTree.setNumberFlags( numberFlag, decimalFlag );
    return PErrors.empty();
  }

/*
  this is required to store temporarily information required by
  the semantic lookahead, as it doesn't have access to the variables
  of the production
*/
  private SyntaxTreeNode local;

  void registerTN( SyntaxTreeNode some) { local = some ; }

  boolean testTN() {
    /***********************************************************************
    * THIS METHOD IS APPARENTLY NOT USED.                                  *
    ***********************************************************************/
    return local.isKind(N_IdPrefix)
        && BStack.aboveReference( local.first().first().location[0] ) ;
  }

  private SyntaxTreeNode anchor = null;
    /***********************************************************************
    * This is set to a non-null value only in Expression().  If a          *
    * ClosedExpressionOrOp node is found when parsing an expression,       *
    * anchor is set to that node.  It is set to null in the following      *
    * places:                                                              *
    *                                                                      *
    *  - When beginning to parse a Substitution()                          *
    *                                                                      *
    *  - When OpSuite() or Substitution() finds that anchor equals an      *
    *    Op Symbol, as described below.                                    *
    *                                                                      *
    * The Substitution() and OpSuite() procedures look for an              *
    * Expression or Op Symbol by calling Expression() and, if that throws  *
    * an exception, catching the expression and checking if anchor is the  *
    * desired Op Symbol.                                                   *
    ***********************************************************************/

// Lookahead mechanisms for definitions
  /*************************************************************************
  * The following code is lifted directly from the getToken method         *
  * created by JavaCC in the file TLAplusParser.java.                      *
  *                                                                        *
  * J-Ch doesn't remember why he defined this method instead of just       *
  * using the GetToken method.  He thinks that it was to make sure         *
  * it would always return a token rather than null.                       *
  *************************************************************************/
  final private Token getNextPreviewToken(Token t) {
    if (t.next == null) t.next = token_source.getNextToken();
       /********************************************************************
       * token_source is declared in configuration/Configuration.java to   *
       * be a ConfigurationTokenManager.                                   *
       ********************************************************************/
    return t.next;
  }

// borrowed from code generated by JavaCC.
  final private Token initPreviewToken() {
    return lookingAhead ? jj_scanpos : token;
      /*********************************************************************
      * `lookingAhead', `token', and `jj_scanpos' are declared in          *
      * TLAplusParser (created by javacc from this file).  The javacc      *
      * documentation says that token is the value returned by             *
      * getToken(0).  God only knows what lookingAhead and jj_scanpos      *
      * are.                                                               *
      *********************************************************************/
  }   

  private final void belchDEF() {
    /***********************************************************************
    * The purpose of this method seems to be to introduce a dummy          *
    * <DEFBREAK> token into the token stream, which is used in parsing     *
    * the OperatorOrFunctionDefinition non-terminal.                       *
    ***********************************************************************/
    Token previousT = initPreviewToken();
    Token currentT = getNextPreviewToken( previousT );
    previousT.next = null;  // <-- to break recursion 
    Token nextT = getNextPreviewToken( currentT );
    currentT.next = previousT;
    while (   nextT.kind != EOF 
           && nextT.kind != THEOREM 
//           && nextT.kind != ASSUME
           /****************************************************************
           * This test for ASSUME removed on 26 June 2007.                 *
           * It made belchDEF get hung up on nested ASSUME/PROVEs.         *
           * However, this permitted extra DEFBREAK tokens to be inserted. *
           * Those extra tokens were eliminated by the change on the same  *
           * date described below.                                         *
           ****************************************************************/
           && nextT.kind != ASSUMPTION 
           && nextT.kind != END_MODULE) {
      /*********************************************************************
      * As long as we have not yet reached the end of the stream or a      *
      * THEOREM, ASSUME, or END_MODULE token, move forward through the     *
      * token stream looking for a "==" token.  Maintain a chain of the    *
      * tokens passed over, with t.next equal to the previous token, and   *
      * t.next = null for the first token.                                 *
      *                                                                    *
      * At this point, the last three tokens obtained are previoustT,      *
      * currentT, and nextT, where currentT.next = previousT and           *
      * nextT.next points to the first unexamined token.                   *
      *********************************************************************/
      if ( currentT.kind == DEF ) {
        /*******************************************************************
        * currentT is a "==" token.                                        *
        *******************************************************************/
        Token t = previousT;
        if        ( t.kind == RBR || t.kind == RSB ) {
          /*****************************************************************
          * t = previousT is a ")" or "]" token.                           *
          *****************************************************************/
          // the following code assumes that parentheses are evenly balanced.
          // something could be added to reinforce the test.
          // they do not have to be on the same line either, btw.
          int depth = 1;
          while (t.next != null) {
            t = t.next;
            if ( (t.kind == LBR || t.kind == LSB) && depth == 1 ) break;
            if ( (t.kind == LBR || t.kind == LSB) && depth >  1 ) depth--;
            if ( (t.kind == RBR || t.kind == RSB) ) depth++;
           }
          if (t.next == null ) break;
          else if (t.next.kind == IDENTIFIER)
            t = t.next;
          // we are positioned at first symbol before "[" or "(" : must be an identifier
        } else 
          /*****************************************************************
          * t = previousT is not a ")" or "]" token.                       *
          *****************************************************************/
           if ( t.kind == IDENTIFIER ) {
             /**************************************************************
             * t is an IDENTIFIER token.                                   *
             *                                                             *
             * If t.next [the previous token in the input stream] is a     *
             * non-prefix operator and is not preceded in the stream by    *
             * "<-" [so it belongs to a preceding substitution], then set  *
             * t to t.next if it is a prefix operator and to t.next.next   *
             * if it is an infix operator.                                 *
             *                                                             *
             * Note: If belchDef is called with the input stream at        *
             * something like "++ a ==", then evaluating t.next.next       *
             * dereferences null.  This should happen only if the user     *
             * has left off the first parameter of the definitiion and     *
             * the resulting exception seems to be caught, but it          *
             * produces a misleading error message.  This type of rare     *
             * error is hardly worth worrying about, but it would be easy  *
             * enough to add a test and might be worth doing if it's easy  *
             * to produce the right error message.                         *
             **************************************************************/
             Token identifier = t;
             if ( isOp( t.next )  && ! isPostfixOp( t.next ) ) {
               t = t.next;
               if ( t.next.kind == SUBSTITUTE )
                  t = identifier; // skip back
                else if ( isInfixOp( t ) ) t = t.next;
                // else assume prefix
              }
           } else {
             /**************************************************************
             * t is not an IDENTIFIER token.                               *
             *                                                             *
             * If it is an operator token, set t to t.next.  (It will be   *
             * a postfix operator unless the user made an error.)          *
             **************************************************************/
               if (  isOp(t) ) { // assume postfix op, the parser will catch the error
                  t = t.next;
                   }
              }
        /*******************************************************************
        * Insert a DEFBREAK token into the input stream right before       *
        * token t, and exit the while loop.                                *
        *                                                                  *
        * Changed by LL on 26 June 2007 so it doesn't add the DEFBREAK     *
        * token if there's already one there.  (This could happen because  *
        * of the change to pass over ASSUMEs described above.)             *
        *******************************************************************/
        if (   (t.next == null)
            || (t.next.kind != DEFBREAK)) {
          Token i = new Token();
          i.kind = DEFBREAK; 
          i.image = "Beginning of definition";
          i.beginLine = t.beginLine;
          i.beginColumn = t.beginColumn;
          i.endLine = t.endLine;
          i.endColumn = t.endColumn;
          i.next = t.next;
          t.next = i;
         } ;
        break;  /* EXIT while */
      } else {
        /*******************************************************************
        * currentT is not a "==" token.                                    *
        *******************************************************************/
        previousT = currentT;
        currentT = nextT;
        nextT = getNextPreviewToken( currentT );
        currentT.next = previousT;
        }
    }  /* END while */
    // reverse pointers.
    /***********************************************************************
    * Go back through the examined tokens, making t.next point to the      *
    * next one for each token t.                                           *
    ***********************************************************************/
    while (previousT != null ) {
      currentT.next = nextT;
      nextT = currentT;
      currentT = previousT;
      previousT = currentT.next;
    }
    // relink firstT
    currentT.next = nextT;
  }

//
  void skipOver( int l ) {
    while ( true ) {
      Token t = getToken(1);
      int k = t.kind;
      if ( (k == EOF) || (t.beginColumn < l ) ) return;
      t = getNextToken();
    }
  }

/***************************************************************************
* Note: the non-terminal ClosedStart was commented out, apparently to be   *
* replaced by this boolean-valued method.                                  *
***************************************************************************/
boolean
ClosedStart( Token t ) {
  return   t.kind == IDENTIFIER
        || (t.kind >= op_57 && t.kind <= op_119)
           /****************************************************************
           * These are all prefix, infix, and postfix operators.           *
           ****************************************************************/
        || t.kind == NUMBER_LITERAL
        || t.kind == LBR
        || t.kind == LSB
        || t.kind == LAB
        || t.kind == LBC
        || t.kind == LWB
        || t.kind == STRING_LITERAL
        || t.kind == WF
        || t.kind == SF;
}

boolean
isOp( Token t ) {
  return t.kind >= op_57 && t.kind <= op_119;
}

boolean isInfixOp( Token t ) {
  return t.kind >= op_1 && t.kind <= op_119;
}

boolean isPostfixOp( Token t ) {
  return t.kind >= op_57 && t.kind <= op_70;
}

boolean isPrefixOp( Token t ) {
  return t.kind >= op_26 && t.kind <= op_116;
}

// global variable follows !!! Make sure it is set everywhere as required
Operator lastOp;
  /*************************************************************************
  * This seems to equal the last Prefix, Infix, PostFix, or NonExpPrefix   *
  * op that was parsed.                                                    *
  *************************************************************************/
  
  boolean isGenOp(SyntaxTreeNode tn) { /* has to be of the form prefix, opsym */
    int kind = tn.getKind();
    if ( kind == N_GenPrefixOp
      || kind == N_GenNonExpPrefixOp
      || kind == N_GenInfixOp
      || kind == N_GenPostfixOp
      || kind == N_FcnAppl )
       return true;
    else
      return false;
  }

//  boolean IsNotExpression () {
//    /***********************************************************************
//    * This method is called only in NumberedAssumeProve.                   *
//    ***********************************************************************/
//    Token t = initPreviewToken();
//          t = getNextPreviewToken(t);
//      /*********************************************************************
//      * Previous statement added on 1 Mar 2007 by J-Ch and LL to fix bug.  *
//      *********************************************************************/
//    int k = t.kind;
//    if ( k == US || k == LOCAL || k == VARIABLE || k == PARAMETER || k == INSTANCE || k == CONSTANT || k == STATE || k == ACTION || k == TEMPORAL ) return true;
//    else {
//      t = getNextPreviewToken(t); k = t.kind;
//      if ( k == US || k == DEF || k  == LSB )
//        return true;
//      else if (k == LBR) {
//        int depth = 1;
//        Token nt = getNextPreviewToken(t);
//        while (true) {
//          t = nt; nt = getNextPreviewToken(t); k = t.kind;
//          if ( k == RBR ) {
//             if ( depth == 1 )
//               if ( nt.kind == DEF ) return true;
//               else return false;
//             else
//                depth--;
//          } else
//          if ( k == LBR ) { depth++;
//          } else
//          if ( k == EOF ) return false;
//        }
//      }
//    }
//    return false;
//  }
//
  boolean isFieldNameToken( Token t ) {
    /***********************************************************************
    * Modified by LL on 10 Oct 2007 because of new keywords added and      *
    * obsolete ones removed.                                               *
    ***********************************************************************/
    if ( (t.kind >= ACTION && t.kind <= EXCEPT)
       ||(t.kind == EXTENDS)
       ||(t.kind >= IF && t.kind <= SF)
       ||(t.kind == STATE)
       ||(t.kind >= THEN && t.kind <= WITH)
       ||(t.kind == US)
       ||(t.kind >= op_112 && t.kind <= op_116)
       )
       return true;
     else
       return false;
  }

  boolean isLabel(SyntaxTreeNode node) {
    /***********************************************************************
    * Checks that node is a label, meaning that it is either an            *
    * identifier token or else an OpApplication node each of whose         *
    * arguments is an OpArgs node whose child is a GeneralId node with an  *
    * empty IdPrefix.                                                      *
    ***********************************************************************/
    if (node == null) {return false;} ;    
    if (node.isKind(N_GeneralId)) {
        return (node.heirs()[0].heirs().length == 0) ;
       } ;
    if (! node.isKind(N_OpApplication)) {return false;} ;
    SyntaxTreeNode opArgs = (SyntaxTreeNode) node.heirs()[1] ;
if (opArgs.kind != N_OpArgs) { ToolIO.out.println("Bug: not N_OpArgs node"); };
        /*******************************************************************
        * Sanity check--can be removed after debugging.                    *
        *******************************************************************/
    for (int i = 1; i < opArgs.heirs().length; i = i+2) {
      /*********************************************************************
      * THe OpArg node for Op(arg_1, ... , arg_N) has the 2N+1 heirs       *
      *                                                                    *
      *     "("   arg_1   ","  ...  ","   arg_N   ")"                      *
      *********************************************************************/
      SyntaxTreeNode genId = (SyntaxTreeNode) opArgs.heirs()[i] ;
      if (genId.kind != N_GeneralId) {return false;} ;
      if (genId.heirs()[0].heirs().length != 0){return false;}
     } // for
    return true;
   }

  boolean labelDoesNotChangeParse(SyntaxTreeNode labeledExpr, 
                                  Operator labelOp) {
    /***********************************************************************
    * Checks if preceding the expression labeledExpr with a label has not  *
    * changed the parsing of the enclosing expression.  It has changed     *
    * the parsing iff                                                      *
    *   /\ labeledExpr is an infix or postfix expression with operator     *
    *      labelOp                                                         *
    *   /\ the top of OperatorStack is an infix or prefix operator stackOp *
    *   /\ it is not the case that stackOp \prec labelOp.                  *
    ***********************************************************************/
    if ( ! (   labeledExpr.isKind(N_InfixExpr)
            || labeledExpr.isKind(N_PostfixExpr) ) ) {return true;} ;

    OSelement topNode = OperatorStack.topOfStack();
    if (topNode == null) {return true;} ;    
    Operator stackOp = topNode.getOperator() ;
    return (stackOp == null) || Operator.prec(stackOp, labelOp) ;
  }

  void checkIndentation(SyntaxTreeNode nd, SyntaxTreeNode junct) 
     throws ParseException {
    /***********************************************************************
    * Goes through the descendants of node nd, stopping at an N_DisjList   *
    * or N_ConjList node.  For each node it finds, if checks whether it    *
    * is properly indented with respect to the current N_DisjItem or       *
    * N_ConjItem junct.  If not, it reports an error by throwing an        *
    * exception.                                                           *
    ***********************************************************************/
    TreeNode[] children = nd.heirs() ;
    for (int i = 0; i < children.length; i++) {
      SyntaxTreeNode child = (SyntaxTreeNode) children[i] ;
      if (! (   child.isKind(N_ConjList) 
             || child.isKind(N_DisjList))) {
         if (!BStack.aboveReference(child.location[1])) {
           throw new ParseException(
              "Item at " + child.getLocation().toString() +
              " is not properly indented inside conjunction or " + 
              " disjunction list item at " + junct.getLocation().toString()) ;
          } ;
         checkIndentation(child, junct) ;
       } ;
     } ;
    }

// predicate used in lookahead to discriminate between the Case Separator and
// the box operator. Returns true if it is most likely not the separator.
// This is a weak mechanism.
  boolean boxDisc() {
    Token t = getToken(1);
    if ( t.kind == CASESEP )
      return OperatorStack.preInEmptyTop();
    else
      return true;
  }

  boolean caseSep() {
    Token t = getToken(1);
    return ( t.kind == CASESEP );
  }

  boolean matchFcnConst () {
    /***********************************************************************
    * Seems to return true iff the next current token sequence begins      *
    * with "<< ...  >> \in" or "Identifier [, Identifier] \in".  It is     *
    * used after a "{" to see if this is a subset expression such as "{x   *
    * \in S : exp}" and after a "[" to see if it is a function expression  *
    * such as "[x \in S |-> exp]".  This leads to the bug that it starts   *
    * incorrectly interpreting the expressions "{x \in S}" and             *
    * "{<<1, 2>> \in {}}" as a subset expression and reports an error.     *
    ***********************************************************************/
    Token t = initPreviewToken();
    t = getNextPreviewToken( t );
   if (t.kind == LAB) {
      int count = 1;
      while (count != 0 ) {
        t = getNextPreviewToken( t );
        if (t.kind == LAB) count++;
        if (t.kind == RAB) count--;
        if (t.kind == EOF) return false;
      }
      t = getNextPreviewToken( t );
      return (t.kind == IN );
    } else
    if (t.kind == IDENTIFIER) {
      t = getNextPreviewToken( t );
      while ( t.kind == COMMA ) {
        t = getNextPreviewToken( t );
        if (t.kind != IDENTIFIER) return false;
        t = getNextPreviewToken( t );
      }
      return (t.kind == IN );
    } else
      return false;
  }

//  int numberFromStep( String step ) {
//    int top = step.indexOf('>');
//    return Integer.parseInt( step.substring( 1, top ) );
//  }
//
  Object msgStack[] = new Object[ 512 ];
  int msgStackMaxSize = 512;
  int msgStackCurrentSize = 0;

  private final void pushMsg( String s, Token t ) {
    if ( msgStackCurrentSize == msgStackMaxSize) {
      Object neo[] = new Object[ 2 * msgStackMaxSize ];
      System.arraycopy(msgStack, 0, neo, 0, msgStackMaxSize);
      msgStack = neo;
      msgStackMaxSize *= 2;
    }
    msgStack [ msgStackCurrentSize   ] = s;
    msgStack [ msgStackCurrentSize+1 ] = t;
    msgStackCurrentSize +=2;
  }

  private final void popMsg() {
    msgStackCurrentSize -=2;
  }

  private String expecting = "nothing";
    /***********************************************************************
    * It appears that the value of expecting is what is printed out in     *
    * error messages as what the parser was expecting when it encountered  *
    * an error.                                                            *
    ***********************************************************************/

  private final String msgStackToString(ParseException e) {
    StringBuffer msg;
    String name = " *unknown* (error occurred before module header)";
    if (mn != null) name = mn.toString();

    msg = new StringBuffer("***Parse Error***\n");
    if ( expecting != emptyString ) {
      msg.append("Was expecting \"");
      msg.append( expecting );
      msg.append("\"\n");
    }

    msg.append(e.getShortMessage());
//    msg.append(" while parsing ");
//    msg.append(name);
//
//    msg.append(".\nResidual stack trace follows:\n");

    msg.append("\n\nResidual stack trace follows:\n");
    int last = msgStackCurrentSize - 10;
    if (last < 0 ) last = 0;
    for ( int lvi = msgStackCurrentSize; lvi > last; lvi -=2 ) {
      msg.append( (String) msgStack[lvi -2 ] );
      msg.append(" starting at line ");
      Token t =  (Token) msgStack[lvi - 1 ];
      msg.append( t.beginLine );
      msg.append(", column ");
      msg.append( t.beginColumn );
      msg.append(".\n");
    }
    return msg.toString();
  }

//

  /*************************************************************************
  * heirsTable is an array of physical length heirsSize that implements a  *
  * dynamic array of length heirsIndex, where heirsIndex <= heirsSize.     *
  * Elements are added to heirsTable by the addHeir method, which          *
  * increments heirsSize if needed.  Elements are removed from the array   *
  * by the getLastHeirs() and popHeir() methods.                           *
  *                                                                        *
  * It appears that the heirsTable is used as a stack of sequences of      *
  * syntax tree nodes, each being the sequence of heirs (children) of a    *
  * node that is currently being parsed.  The top of the stack is the      *
  * sequence at the end of the heirsTable array.  Each sequence is begun   *
  * by a null entry.  The bpa() method is called when about to push such   *
  * a sequence onto the stack; it adds the null element that marks the     *
  * beginning of the sequence.  Similarly, the epa() method is called      *
  * after popping a sequence off the top of the stack; it removes the      *
  * null element.                                                          *
  *************************************************************************/
  private SyntaxTreeNode heirsTable[] = new SyntaxTreeNode[ 512 ];
  private int heirsSize = 512;
  private int heirsIndex = 0;

  private final void addHeir( SyntaxTreeNode sn ) {
    /***********************************************************************
    * Appends the syntax tree sn to the end of the dynamic array           *
    * implemented by heirsTable.                                           *
    ***********************************************************************/
    if ( heirsIndex == heirsSize ) {
      SyntaxTreeNode nh[] = new SyntaxTreeNode[ heirsSize + 512 ];
      System.arraycopy( heirsTable, 0, nh, 0, heirsSize );
      heirsSize += 512;
      heirsTable = nh;
    }
    heirsTable[ heirsIndex ] = sn; heirsIndex++;
  }

  private final SyntaxTreeNode[] getLastHeirs() {
    /***********************************************************************
    * This method will throw an array-out-of-bounds exception if called    *
    * when heirsIndex = 0 (so the dynamic array implemented by heirsTable  *
    * is empty) or if that dynamic array contains no null entry.           *
    *                                                                      *
    * If the last element of the dynamic heirsTable array is null, then    *
    * it returns null.  Otherwise, it returns an array equal to the        *
    * sequence of non-null elements at the end of the dynamic heirsTable   *
    * array and removes them from that array.                              *
    ***********************************************************************/
    int lvi = heirsIndex - 1;
    while (heirsTable[ lvi ] != null ) lvi--;
    /***********************************************************************
    * Assert: /\ lvi < heirsIndex                                          *
    *         /\ heirsTable[lvi] = null                                    *
    *         /\ \A i \in lvi+1 .. heirsIndex-1 : heirsTable[i] # null     *
    ***********************************************************************/
    int as = heirsIndex - lvi - 1;
    if (as == 0)
      return null;
    else {
      SyntaxTreeNode ts[] = new SyntaxTreeNode[ as ];
      System.arraycopy( heirsTable, lvi + 1, ts, 0, as);
      heirsIndex = lvi + 1;
      /*********************************************************************
      * Assert /\ as > 0                                                   *
      *        /\ \A i \in 0..as-1 : ts[i] = heirsTable[lvi + i + 1]       *
      *        /\ heirsIndex = lvi + 1                                     *
      *********************************************************************/
      return ts;
    }
  }

  private final boolean popHeir() {
   /************************************************************************
   * Throws an array-out-of-bounds exception if heirsIndex = 0 (meaning    *
   * that the dynamic array implemented by heirsTable is empty).           *
   *                                                                       *
   * It removes the last element from the heirsTable array and returns     *
   * true iff the new last element is null.                                *
   ************************************************************************/
    return heirsTable[ --heirsIndex ] == null;
  }

  private String emptyString = "";

  private final void bpa( String s) { // Beginning of Production Actions 
    addHeir( null );
if (System.getProperty("TLA-StackTrace", "off").equals("on")) ToolIO.out.println("Beginning " + s);
    pushMsg( s, getToken(1) );
    expecting = emptyString;
  }

  private final void epa() {
    popMsg();
if (System.getProperty("TLA-StackTrace", "off").equals("on")) ToolIO.out.println("Ending " + msgStack [ msgStackCurrentSize   ]);
    Assert.assertion( popHeir() );
    expecting = emptyString;
  }
//

  Stack internals = new Stack();

  private final void addDependency( UniqueString s ) {
    int lvi = internals.search( s );
    if ( lvi < 0 )
      dependencyList.addElement( s );
  }

  private final UniqueString reduceString( String s ) {
    int l = s.length();
    StringBuffer copy = new StringBuffer( l );
    int i = 0;
    int j = 0;
    while ( i!= l ) {
      if (s.charAt(i) == '\\' ) {
        i++; char c = s.charAt(i);
             if (c == '\\') copy.append( '\\');
        else if (c == 'n')  copy.append( '\n');
        else if (c == 'r')  copy.append( '\r');
        else if (c == 'f')  copy.append( '\f');
        else if (c == 't')  copy.append( '\t');
        else if (c == '"')  copy.append( '"');
      } else
         copy.append( s.charAt(i));
      i++; j++;
    }
    copy.setLength(j);
    return UniqueString.uniqueStringOf(copy.toString());
  }

/***************************************************************************
* Fields and methods for parsing proofs.                                   *
***************************************************************************/
private int proofDepth = -1 ;
  /*************************************************************************
  * The nesting level of the proof we're currently processing, counting    *
  * from 0 a la Java.                                                      *
  *************************************************************************/
  
private final int MaxProofDepth = 100 ;
private int[] proofLevelStack = new int[MaxProofDepth] ;
  /*************************************************************************
  * The level number of a proof with steps numbered <n>x is n.  The value  *
  * of proofLevelStack[proofDepth] is the level number of the current      *
  * proof.  If we have started processing a proof haven't yet determined   *
  * its level, then proofLevelStack[proofDepth] equals -1.                 *
  *************************************************************************/

private int levelOfProofStepLexeme(Token tok){
  /*************************************************************************
  * The level of a ProofStepLexeme or ProofStepDotLexeme.  It returns -1   *
  * for "*" and -2 for "*".                                                *
  *************************************************************************/
  String im = tok.image ;
  if (im.substring(1,2).equals("*")) {return -1;} ;
  if (im.substring(1,2).equals("+")) {return -2;} ;
  return new Integer(im.substring(1, im.indexOf('>'))) ;
 }  

/***************************************************************************
* The following method returns the canonical form of the step number       *
* contained in token t.  This means that a "+" or "*" is replaced by the   *
* appropriate level number, and leading zeros are removed from a regular   *
* level number.                                                            *
***************************************************************************/
private UniqueString correctedStepNum(Token t) {
  String str = t.image ;
  if (   str.substring(1,2).equals("*")
      || str.substring(1,2).equals("+") ) {
    int level = getProofLevel() ;
    if ((level < 0) && (proofDepth > 0)) {
      /*********************************************************************
      * We've started a proof without yet determining the level number.    *
      * Since this method is being called when encountering a step number  *
      * token, this means we've encountered a step number inside a BY. So  *
      * the actual level number to use here is the "previous" level        *
      * number.                                                            *
      *********************************************************************/
      level = proofLevelStack[proofDepth-1] ;
     }
    str = "<" + level + str.substring(2) ;
   } 
  else {str = "<" + levelOfProofStepLexeme(t) + str.substring(str.indexOf('>'));
   } ; 
  return UniqueString.uniqueStringOf(str) ;
  } ;

private void pushProofLevel() throws ParseException {
  /*************************************************************************
  * Called to begin the processing of a new proof level.  It increments    *
  * proofDepth and sets the proofLevelStack entry to -1.                   *
  *************************************************************************/
  proofDepth++ ;
  if (proofDepth >= MaxProofDepth) {
    throw new ParseException("Proofs nested more than " + 
                             MaxProofDepth + "deep.") ;
   } ;
  proofLevelStack[proofDepth] = -1 ;
 }

private void popProofLevel() throws ParseException {
  if (proofDepth < 0) {
    throw new ParseException("Parser bug: an extra QED step found." ) ;
   } ;
  proofDepth-- ;
 }

private void setProofLevel(int val) throws ParseException {
  if (proofDepth < 0) {
    throw new ParseException("Parser bug: proof step found outside proof." ) ;
   } ;
  proofLevelStack[proofDepth] = val;  
 }

private int getProofLevel() { 
  if (proofDepth < 0) { return proofDepth; } ;
  return proofLevelStack[proofDepth]; }

private boolean beginsProof(Token tok) {
  /*************************************************************************
  * True iff the token tok begins a new proof--that is, iff it is either   *
  * "BY", "PROOF", a step number that has a higher level than the current  *
  * level, begins "<+>", or begins "<*>" and we are not inside a proof.    *
  *************************************************************************/
  String im = tok.image ;
  if (im.length() < 2) {return false;}
    /***********************************************************************
    * This can happen if the user makes a weird error.                     *
    ***********************************************************************/
  if (im.substring(1,2).equals("*")) {return (proofDepth < 0);} ;

  if (im.substring(1,2).equals("+")) {return true ;} ;
  switch (tok.kind) {
    case ProofStepLexeme :
    case BareLevelLexeme :
    case UnnumberedStepLexeme :
    case ProofStepDotLexeme :
      if (proofDepth < 0) {return true ;} ;
      int tokLevel = levelOfProofStepLexeme(tok) ;
      return    (proofLevelStack[proofDepth] >= 0)
             && (tokLevel > proofLevelStack[proofDepth]) ;
    case BY :
    case PROOF :
    case OBVIOUS :
    case OMITTED :
      return true ;
   }; // switch
  return false ;
 }

private boolean correctLevel(Token tok) {
  /*************************************************************************
  * True iff tok is a correct proof step token for the current level of    *
  * proof, where precedeByPROOF is true iff the proof is preceded by a     *
  * "PROOF" token (needed in case this is the first step of the proof).    *
  * If this is the first step being processed for current proof, then it   *
  * sets the current proof level.                                          *
  *************************************************************************/
  int tokLevel = levelOfProofStepLexeme(tok) ;

  /*************************************************************************
  * Set lastDepth to the level of the containing proof, or -1 if this is   *
  * the top-level proof.                                                   *
  *************************************************************************/
  int lastLevel = -1 ;
  if (proofDepth > 0) {lastLevel = proofLevelStack[proofDepth-1] ;}
  switch (tokLevel) {
    case -1 :
      /*********************************************************************
      * tok is <*>...  This is always legal because it can begin a proof   *
      * iff it was preceded by a "PROOF".                                  *
      *********************************************************************/
      if (proofLevelStack[proofDepth] < 0) {
        proofLevelStack[proofDepth] = lastLevel + 1 ;
       } ;
      return true ;

    case -2 :
      /*********************************************************************
      * tok is <+>...  This is legal iff it begins a proof.                *
      *********************************************************************/
      if (proofLevelStack[proofDepth] < 0) {
        proofLevelStack[proofDepth] = lastLevel + 1 ;
        return true ;      
       }
      else return false ;

    default :
      if (proofLevelStack[proofDepth] < 0) {
        proofLevelStack[proofDepth] = tokLevel;
        return   (tokLevel > lastLevel) ;
       } 
      else return (proofLevelStack[proofDepth] == tokLevel) ;
   }  
 }


}


PARSER_END(TLAplusParser)

/* the default mode while skip over text, looking for the marker of a pragma, or the beginning of the spec. */

TOKEN_MGR_DECLS :
{ static int bracketCount = 0; }

TOKEN : {
  < #BEGIN_MODULE: "----" ("-")* (" ")* "MODULE">
}

TOKEN :
{
  < BEGIN_PRAGMA: "--->" > : PRAGMA
| < _BM1: <BEGIN_MODULE> > : SPEC
}

SKIP : { < ~[] > }

/* for some reason, all these hidden regexps must be defined in DEFAULT mode */
TOKEN: {
  < #CASE0 : "_" (<LETTER> | "_" | <DIGIT> )* <LETTER> (<LETTER> | "_" | <DIGIT> )*  >
| < #CASE1 : <DIGIT> (<LETTER> | "_" | <DIGIT> )* <LETTER> (<LETTER> | "_" | <DIGIT> )*  >
| < #CASE1b : <DIGIT> ( <LETTER> | <DIGIT> )* ".\\/" >
| < #CASE1c : <DIGIT> ( <LETTER> | <DIGIT> )* "./\\" >
| < #CASE2 : ("W" | "S") ( (  ["a"-"z","A"-"E", "G"-"Z", "_"] | <DIGIT> ) (<LETTER> | "_" | <DIGIT> )* )? >
| < #CASE2b : ("W" | "S") (  ["a"-"z","A"-"E", "G"-"Z"] | <DIGIT> ) ( <LETTER> | <DIGIT> )* ".\\/" >
| < #CASE2c : ("W" | "S") (  ["a"-"z","A"-"E", "G"-"Z"] | <DIGIT> ) ( <LETTER> | <DIGIT> )* "./\\" >
| < #CASE3 : ("WF" | "SF") ( ( <LETTER> | <DIGIT> ) (<LETTER> | "_" | <DIGIT> )* )? >
| < #CASE6 : ( ["a"-"z","A"-"R", "T"-"V", "X"-"Z"]) (<LETTER> | "_" | <DIGIT> )* >
| < #CASE6b: ( ["a"-"z","A"-"R", "T"-"V", "X"-"Z"]) (<LETTER> | <DIGIT> )* ".\\/" >
| < #CASE6c: ( ["a"-"z","A"-"R", "T"-"V", "X"-"Z"]) (<LETTER> | <DIGIT> )* "./\\" >
| < #CASEN : (<DIGIT>)+ <LETTER> ( <LETTER> | <DIGIT> | "_" )* >
| < #LETTER: ["a"-"z", "A"-"Z"] >
| < #DIGIT: ["0"-"9"] >
// | < #CASESEP: "[]" >
}


/* in pragma mode, we worry only about strings and numbers */

<PRAGMA> TOKEN : {
  < NUMBER : (<DIGIT>)+ | "0" >
| < _BM2: <BEGIN_MODULE> > : SPEC
}

<PRAGMA> SKIP : { < ~[] > }

/* SPEC mode is defined for TLA+ specifications. */

/*
  <SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
*/

<SPEC> SKIP : { " " | "\t" | "\n" | "\r" }
 
<SPEC> MORE : {
  < "(*." | "(*" >     : IN_COMMENT
| < "\\*" >   : IN_EOL_COMMENT
}

<IN_COMMENT> SPECIAL_TOKEN: {
  < "(*." | "(*" > { bracketCount++; } : EMBEDDED
| < "*)"> : SPEC
}

<EMBEDDED> SPECIAL_TOKEN: {
  < "*)"> { bracketCount--; if (bracketCount == 0) SwitchTo( IN_COMMENT ); }
| < "(*." | "(*" > { bracketCount++; }
}

<IN_EOL_COMMENT> SPECIAL_TOKEN: {
   < "\n" | "\r" | "\r\n" > : SPEC
}
 
<IN_COMMENT,IN_EOL_COMMENT,EMBEDDED> MORE: {
  < ~[] >
}

<SPEC> TOKEN : {
  < _BM0 : <BEGIN_MODULE> >
| < SEPARATOR: "----" ("-")* >
| < END_MODULE: "====" ("=")* >
}

<SPEC> TOKEN : {
  < ACTION: "ACTION" | "ACTIONS" >
| < ASSUME: "ASSUME" >
| < ASSUMPTION: "ASSUMPTION" | "AXIOM" >
| < CASE: "CASE" >
| < CHOOSE: "CHOOSE" >
| < CONSTANT: "CONSTANT" | "CONSTANTS" >
| < ELSE: "ELSE" >
// | < ENDPROOF: "ENDPROOF" | "EndProof" | "Endproof" >
| < EXCEPT: "EXCEPT" >
| < EXISTS: "\\E" | "\\exists" >
| < EXTENDS: "EXTENDS" >
| < FORALL: "\\A" | "\\forall" >
// | < FUNCTION: "FUNCTION" | "FCN" | "FUNCTIONS" | "FCNS" >
| < IF: "IF" >
// | < IN: "\\in" > will become a backslash op.
| < INSTANCE: "INSTANCE" >
| < LET: "LET" >
| < LETIN: "IN" >
| < LOCAL: "LOCAL"> // a hack, see above
| < MODULE: "MODULE" >
| < NEW: "NEW" >  /*** Added by LL on 5 Mar 2007 ****/
// | < OF: "OF" | "Of" | "of" >
| < OTHER: "OTHER" >
// | < PARAMETER: "PARAMETER" | "PARAMETERS" | "NEW" >
// | < PF: "Pf:" | "Proof:" | "PROOF:" >
// | < PREDICATE: "PREDICATE" | "PREDICATES" >
| < PROPOSITION: "PROPOSITION" | "LEMMA" | "COROLLARY" >
| < SF: "SF_" >
// | < ST: "S.T." >
| < T_EXISTS: "\\EE">
| < T_FORALL: "\\AA">
| < THEN: "THEN" >
| < BY: "BY">
| < DEFINE: "DEFINE">
| < DF: "DEF" | "DEFS"> // DEF is already used for "=="
| < THEOREM: "THEOREM" >
| < USE: "USE">
| < HIDE: "HIDE">
| < HAVE: "HAVE">
| < OBVIOUS: "OBVIOUS">
| < OMITTED: "OMITTED">
| < LAMBDA: "LAMBDA">
| < TAKE: "TAKE">
| < PROOF: "PROOF" > // | "Proof" > removed by LL 22 Jul 2007
| < PROVE: "PROVE" >
| < QED: "QED" >
| < RECURSIVE: "RECURSIVE" >
| < STATE: "STATE" >
| < TEMPORAL: "TEMPORAL" | "TEMPORALS" >
| < PICK: "PICK">
| < WITNESS: "WITNESS">
| < SUFFICES: "SUFFICES">
// | < TRANSITION: "TRANSITION" | "TRANS" >
| < VARIABLE: "VARIABLE" | "VARIABLES" >
| < WF: "WF_" >
| < WITH: "WITH" >
| < COMMA: "," >
| < COLON: ":" >
| < COLONCOLON: "::" >
| < DOT: "." >
| < US:   "_" >
| < DEF: "==" >
// | < EQUAL: "=" >
| < LBR: "(" >
| < RBR: ")" >
// | < CASESEP: "[]" >
| < DEFBREAK: "-|-"> // fictitious !
| < LSB: "[" >
| < ARSB: "]_" >
| < RSB: "]" >
| < LWB: "{|" >  // Obsolete
| < RWB: "|}" >  // Obsolete
| < LBC: "{" >
| < RBC: "}" >
| < LAB: "<<" >
| < ARAB: ">>_" >
| < RAB: ">>" >
| < BANG: "!" >
| < ARROW: "->" >
| < SUBSTITUTE: "<-" >
| < MAPTO: "|->" >
// | < ENDBY: "[.]">
// | < PROOFCASE: "PROOFCASE">
}

<SPEC> TOKEN : /* LITERALS */ {
  < NUMBER_LITERAL:
      (<DIGIT>)+
    | "0"
    | ("\\" ["o","O"] (["0"-"7"])+)
    | ("\\" ["b","B"] (["0","1"])+)
    | ("\\" ["h","H"] (["0"-"9","a"-"f","A"-"F"])+ )
  >
| < STRING_LITERAL:
      "\""
      ( (~["\"", "`", "\n", "\r", "\\" ])
      | ( "`" ( ~["'" ] )* "'")
      | ( "\\" ["n","t","r","f","\\", "\""] )
      )*
      "\""
  >
//  | < TLA_LITERAL: "STRING" >
// "\\" (["n","t","b","r","f","\\","\'","\""]
}

<SPEC,PRAGMA> TOKEN : /* junctions - they have to precede opSymbols */ {
  < BAND : <CASE1c> | <CASE2c> | <CASE6c> >
| < BOR  : <CASE1b> | <CASE2b> | <CASE6b> >
// | < AND : "/\\" >
// | < OR : "\\/" >
}

<SPEC> TOKEN : { < // -> postfix
  op_57 : "'" > | <
  op_68 : "^+" > | <
  op_69 : "^*" > | <
  op_70 : "^#" > | < // prefix ->
  op_76 : "-." > | <
  op_26 : "\\lnot" > | <
  op_29 : "\\neg" > | <
  op_58 : "~" > | <
  CASESEP : "[]" > | <
  op_61 : "<>" > | <
  op_112 : "ENABLED" > | <
  op_113 : "UNCHANGED" > | <
  op_114 : "SUBSET" > | <
  op_115 : "UNION" > | <
  op_116 : "DOMAIN" > | < // infix ->
  op_1 : "//" > | <
AND : "/\\" > | < //  op_2 : "/\" > | <
  op_3 : "/=" > | <
  op_4 : "/" > | <
OR : "\\/" > | <  //  op_5 : "\/" > | <
  op_6 : "\\approx" > | <
  op_7 : "\\asymp" > | <
  op_8 : "\\bigcirc" > | <
  op_9 : "\\bullet" > | <
  op_10 : "\\cap" > | <
  op_11 : "\\cdot" > | <
  op_12 : "\\circ" > | <
  op_13 : "\\cong" > | <
  op_14 : "\\cup" > | <
  op_15 : "\\div" > | <
  op_16 : "\\doteq" > | <
  op_17 : "\\equiv" > | <
  op_18 : "\\geq" > | <
  op_19 : "\\gg" > | <
  IN : "\\in" > | <
  op_21 : "\\intersect" > | <
  op_22 : "\\union" > | <
  op_23 : "\\land" > | <
  op_24 : "\\leq" > | <
  op_25 : "\\ll" > | <
  op_27 : "\\lor" > | <
//  op_28 : "\\mod" > | <
  op_30 : "\\o" > | <
  op_31 : "\\odot" > | <
  op_32 : "\\ominus" > | <
  op_33 : "\\oplus" > | <
  op_34 : "\\oslash" > | <
  op_35 : "\\otimes" > | <
  op_36 : "\\prec" > | <
  op_37 : "\\preceq" > | <
  op_38 : "\\propto" > | <
  op_39 : "\\sim" > | <
  op_40 : "\\simeq" > | <
  op_41 : "\\sqcap" > | <
  op_42 : "\\sqcup" > | <
  op_43 : "\\sqsubset" > | <
  op_44 : "\\sqsupset" > | <
  op_45 : "\\sqsubseteq" > | <
  op_46 : "\\sqsupseteq" > | <
  op_47 : "\\star" > | <
  op_48 : "\\subset" > | <
  op_49 : "\\subseteq" > | <
  op_50 : "\\succ" > | <
  op_51 : "\\succeq" > | <
  op_52 : "\\supset" > | <
  op_53 : "\\supseteq" > | <
  op_54 : "\\uplus" > | <
  op_55 : "\\wr" > | <
  op_56 : "\\" > | <
  op_59 : "~>" > | <
  op_62 : "=>" > | <
  op_63 : "=<" > | <
  op_64 : "=|" > | <
  EQUALS : "=" > | <
  op_66 : "##" > | <
  op_67 : "#" > | <
  op_71 : "^^" > | <
  op_72 : "^" > | <
  op_73 : "--" > | <
  op_74 : "-|" > | <
  op_75 : "-+->" > | <
  op_77 : "-" > | <
  op_78 : "**" > | <
  op_79 : "*" > | <
  op_80 : "++" > | <
  op_81 : "+" > | <
  op_82 : "<=>" > | <
  op_83 : "<:" > | <
  op_84 : "<=" > | <
  op_85 : "<" > | <
  op_86 : ">=" > | <
  op_87 : ">" > | <
  op_88 : "..." > | <
  op_89 : ".." > | <
  op_90 : "||" > | <
  op_91 : "|" > | <
  op_92 : "|-" > | <
  op_93 : "|=" > | <
  op_94 : "&&" > | <
  op_95 : "&" > | <
  op_96 : "$$" > | <
  op_97 : "$" > | <
  op_98 : "??" > | <
//  op_99 : "?" > | <
  op_100 : "%%" > | <
  op_101 : "%" > | <
  op_102 : "@@" > | <
  op_103 : "!!" > | <
  op_104 : ":>" > | <
  op_105 : ":=" > | <
  op_106 : "::=" > | <
  op_107 : "(+)" > | <
  op_108 : "(-)" > | <
  op_109 : "(.)" > | <
  op_110 : "(/)" > | <
  op_111 : "(\\X)"> | <
  op_117 : "\\notin"> | <
  op_118 : "\\times"> | <
  op_119 : "\\X">  
}
// op_119 : dernier compteur : impact sur ClosedStart et autres !!!

<SPEC,PRAGMA> TOKEN : /* IDENTIFIERS */ {
  < IDENTIFIER : <CASE0> | <CASE1> | <CASE2> | <CASE3> |  <CASE6> | <CASEN> | "@" >
}

/***************************************************************************
* The real production here was supposed to be                              *
*                                                                          *
*   <BeginningOfStep> ::= "<"  (<DIGIT>+ | "+" | "*")  ">"                 *
*                         ( (<LETTER> | <DIGIT>)+ | ("*")* | ("-")* )      *
*                         ( "." )*                                         *
*                                                                          *
* But we also need                                                         *
*                                                                          *
*   <ProofStepLexeme> ::= "<"  <DIGIT>+ ">" (<LETTER> | <DIGIT>)+          *
*                                                                          *
* split out because only it can be used as an expression.                  *
*                                                                          *
* However, the part with the "*"s and "-"s doesn't work, so they can't be  *
* used.  I think they're getting parsed as infix operators.  I also tried  *
* to allow underscore in addition to letters and digits, but I couldn't    *
* get it to work.                                                          *
*                                                                          *
* To get this to work even to the extent that it does, I had to do some    *
* weird hacking because javacc doesn't seem to work right with a           *
* production that ends in (...)* or (...)?, and when given <A> | <A> B it  *
* complains that the first <A> will never be matched.  That's why the ">"  *
* is not part of <ProofLevelLexeme> and <ProofImplicitLevelLexeme>.  I     *
* suppose this can be simplified.  However, all the kludgery here is       *
* pretty well encapsulated in StepStartToken(), though the beginsProof     *
* method will also have to be modified if this is changed.                 *
***************************************************************************/
<SPEC> MORE: {
  <ProofLevelLexeme   : "<" (<DIGIT>)+ >
| <ProofImplicitLevelLexeme : "<" ( "+" | "*")  >
}

<SPEC> TOKEN: {
  <ProofStepLexeme         : <ProofLevelLexeme> ">" ( <LETTER> | <DIGIT> )+ >
| <ProofImplicitStepLexeme : <ProofImplicitLevelLexeme> ">"
                                   ( <LETTER> | <DIGIT> )+ >
| <ProofStepDotLexeme   : (<ProofLevelLexeme> | <ProofImplicitLevelLexeme>) 
                           ">"
                            ( <LETTER> | <DIGIT> )+ (<DOT>)+ >
| <BareLevelLexeme :    <ProofLevelLexeme> ">"
                      | <ProofImplicitLevelLexeme> ">" >
| <UnnumberedStepLexeme : (<ProofLevelLexeme> ">" 
                           | <ProofImplicitLevelLexeme> ">")
                              ( "*" (".")* | "-" (".")* | (".")+)>
}


/* beginning of the grammar productions */
Token
PrefixOpToken() : {
  Token t;
}{
 ( t = <op_26>
 | t = <op_29>
 | t = <op_58>
 | t = <CASESEP>
 | t = <op_61>
 | t = <op_112>
 | t = <op_113>
 | t = <op_114>
 | t = <op_115>
 | t = <op_116>
 ) { return t; }
}

/***************************************************************************
* NEPrefixOpToken and PrefixOpToken differ because the first includes      *
* "-." while the second contains does not.  Neither includes "-".          *
***************************************************************************/
Token
NEPrefixOpToken() : {
  Token t;
}{
 ( t = <op_26>
 | t = <op_29>
 | t = <op_58>
// | t = <op_60>  XXX was probably CASESEP
 | t = <CASESEP>
 | t = <op_61>
 | t = <op_76>  // "-."
 | t = <op_112>
 | t = <op_113>
 | t = <op_114>
 | t = <op_115>
 | t = <op_116>
 ) { return t; }
}

Token
InfixOpToken() : {
  Token t;
}{
 ( t =  <op_1>
 | t =  <AND>
 | t =  <op_3>
 | t =  <op_4>
 | t =  <OR>
 | t =  <op_6>
 | t =  <op_7>
 | t =  <op_8>
 | t =  <op_9>
 | t =  <op_10>
 | t =  <op_11>
 | t =  <op_12>
 | t =  <op_13>
 | t =  <op_14>
 | t =  <op_15>
 | t =  <op_16>
 | t =  <op_17>
 | t =  <op_18>
 | t =  <op_19>
 | t =  <IN>
 | t =  <op_21>
 | t =  <op_22>
 | t =  <op_23>
 | t =  <op_24>
 | t =  <op_25>
 | t =  <op_27>
// | t =  <op_28>
 | t =  <op_30>
 | t =  <op_31>
 | t =  <op_32>
 | t =  <op_33>
 | t =  <op_34>
 | t =  <op_35>
 | t =  <op_36>
 | t =  <op_37>
 | t =  <op_38>
 | t =  <op_39>
 | t =  <op_40>
 | t =  <op_41>
 | t =  <op_42>
 | t =  <op_43>
 | t =  <op_44>
 | t =  <op_45>
 | t =  <op_46>
 | t =  <op_47>
 | t =  <op_48>
 | t =  <op_49>
 | t =  <op_50>
 | t =  <op_51>
 | t =  <op_52>
 | t =  <op_53>
 | t =  <op_54>
 | t =  <op_55>
 | t =  <op_56>
 | t =  <op_59>
 | t =  <op_62>
 | t =  <op_63>
 | t =  <op_64>
 | t =  <EQUALS>
 | t =  <op_66>
 | t =  <op_67>
 | t =  <op_71>
 | t =  <op_72>
 | t =  <op_73>
 | t =  <op_74>
 | t =  <op_75>
 | t =  <op_77>
 | t =  <op_78>
 | t =  <op_79>
 | t =  <op_80>
 | t =  <op_81>
 | t =  <op_82>
 | t =  <op_83>
 | t =  <op_84>
 | t =  <op_85>
 | t =  <op_86>
 | t =  <op_87>
 | t =  <op_88>
 | t =  <op_89>
 | t =  <op_90>
 | t =  <op_91>
 | t =  <op_92>
 | t =  <op_93>
 | t =  <op_94>
 | t =  <op_95>
 | t =  <op_96>
 | t =  <op_97>
 | t =  <op_98>
// | t =  <op_99>
 | t =  <op_100>
 | t =  <op_101>
 | t =  <op_102>
 | t =  <op_103>
 | t =  <op_104>
 | t =  <op_105>
 | t =  <op_106>
 | t =  <op_107>
 | t =  <op_108>
 | t =  <op_109>
 | t =  <op_110>
 | t =  <op_111>
 | t = <op_117>
 | t = <op_118>
 | t = <op_119>
 ) { return t; }
}

Token
PostfixOpToken() : {
Token t;
}{
 ( t = <op_57>
 | t = <op_68>
 | t = <op_69>
 | t = <op_70>
 ) { return t; }
}

SyntaxTreeNode
CompilationUnit() : {
  SyntaxTreeNode tempASTN;
  belchDEF();
}{
  [ Prelude() ]
  tempASTN = Module() { token_source.SwitchTo(0); }
    /***********************************************************************
    * In the classic practice of documentation by identifier name, we      *
    * find that the definition of SwitchTo in                              *
    * ConfigurationTokenManager.java is                                    *
    *                                                                      *
    *    static public void SwitchTo(int lexState)                         *
    *                                                                      *
    * so its argument seems to be a lexical state.  We also find in        *
    * that file                                                            *
    *                                                                      *
    *    static int defaultLexState = 0;                                   *
    *                                                                      *
    * leading us to guess that this is setting the lexical state to        *
    * DEFAULT.                                                             *
    ***********************************************************************/

  { return tempASTN;}
}
/* SwitchTo is used to reset the state of the tokenizer */

void Prelude() : { } {
  <BEGIN_PRAGMA> ( <NUMBER> | <IDENTIFIER> )*
}

SyntaxTreeNode
Module() : {
  Token t;
  SyntaxTreeNode lSTN[] = new SyntaxTreeNode[ 4 ];
  bpa( "Module definition" );
  internals.push( null );
  Object pop = null;
} {
{ expecting = "---- MODULE"; }
  lSTN[0] =  BeginModule()
{ expecting = "EXTENDS clause or module body"; }
  lSTN[1] =  Extends()
{ expecting = "Module body"; }
  lSTN[2] =  Body()
{ expecting = "==== or more Module body"; }
  lSTN[3] =  EndModule()
{ do { pop = internals.pop(); } while (pop != null );
  internals.push( lSTN[0].zero[1].image );
  epa(); return new SyntaxTreeNode( mn, N_Module, lSTN ); }
}

SyntaxTreeNode
BeginModule() :
{ SyntaxTreeNode lSTN[] = new SyntaxTreeNode[3];
  Token t;
  bpa( "Begin module" );
} {
{ expecting = "---- MODULE (beginning of module)"; }
  ( t=<_BM0> | t=<_BM1> | t = <_BM2> )
    { lSTN[0] =  new SyntaxTreeNode(mn, t); }
{ expecting = "Identifier";
  t = getToken(1);
  if (isFieldNameToken( t )) t.kind = IDENTIFIER; }
  lSTN[1] = Identifier() {
    if ( mn == null ) mn = lSTN[1].image; 
    expecting = "----"; }
   t = <SEPARATOR>  { lSTN[2] =  new SyntaxTreeNode(mn, t ); }
  { epa(); return new SyntaxTreeNode( mn, N_BeginModule, lSTN ); }
}

SyntaxTreeNode
EndModule() : {
  SyntaxTreeNode lSTN[] = new SyntaxTreeNode[1];
  Token t;
}{
  t = <END_MODULE> {
    lSTN[0] = new SyntaxTreeNode(mn, t);
    return new SyntaxTreeNode(mn, N_EndModule, lSTN ); }
}

SyntaxTreeNode
Extends() : {
  SyntaxTreeNode tn;
  Token t;
  bpa( "Extends" );
} {
[  t = <EXTENDS>      { addHeir( new SyntaxTreeNode(mn, t)); }
{ expecting = "Identifier";
  t = getToken(1);
  if (isFieldNameToken( t )) t.kind = IDENTIFIER; }
  tn = Identifier() { addDependency( tn.image ); addHeir( tn ); }
{ expecting = "comma or module body"; }
  ( t = <COMMA>      { addHeir( new SyntaxTreeNode(mn, t) ); }
{ expecting = "Identifier";
  t = getToken(1);
  if (isFieldNameToken( t )) t.kind = IDENTIFIER;}
    tn = Identifier() { addDependency( tn.image ); addHeir( tn ); }
  )*
]
  { SyntaxTreeNode sn[] = getLastHeirs();
    epa(); return new SyntaxTreeNode( mn, N_Extends, sn );
  }
}
 
SyntaxTreeNode
Body() : {
  SyntaxTreeNode tn, sn[];
  Token t;
  bpa("Module body");
  expecting = "LOCAL, INSTANCE, PROOF, ASSUMPTION, THEOREM, " +
              "RECURSIVE, declaration, or definition";
} {
( (   t = <SEPARATOR> { tn = new SyntaxTreeNode(mn, t); }
    | tn = VariableDeclaration()
    | tn = ParamDeclaration()
    | LOOKAHEAD ( 2 ) tn = OperatorOrFunctionDefinition()  
         /* Also handles a ModuleDefinition */
    |                 tn = Recursive()
    | LOOKAHEAD ( 2 ) tn = Instance()
    | LOOKAHEAD ( 2 ) tn = Assumption()
    | LOOKAHEAD ( 2 ) tn = Theorem()
    | LOOKAHEAD ( 1 ) tn = Module() { belchDEF(); }
    | LOOKAHEAD ( { (getToken(1).kind == USE) || (getToken(1).kind == HIDE) } )
      tn = UseOrHideOrBy()  ) { addHeir(tn); } )*
  { sn = getLastHeirs(); epa();
    return new SyntaxTreeNode(mn, N_Body, sn );
  }
}

SyntaxTreeNode
VariableDeclaration() : {
  SyntaxTreeNode tn, sn[];
  Token t;
  SyntaxTreeNode lSTN[] = new SyntaxTreeNode[1];
  bpa( "variable declaration" );
}{
  t = <VARIABLE>     { lSTN[0] = new SyntaxTreeNode( mn, t); }
{ expecting = "Identifier"; }
  tn = Identifier() { addHeir( tn ); }
{ expecting = "comma or module body"; }
  ( t = <COMMA>      { addHeir( new SyntaxTreeNode( mn, t) ) ; }
{ expecting = "Identifier"; }
    tn = Identifier() { addHeir( tn ); }
  )*
  { sn = getLastHeirs();
    epa(); return new SyntaxTreeNode(mn, N_VariableDeclaration, lSTN, sn ); }
}

SyntaxTreeNode
ParamDeclaration() : {
  SyntaxTreeNode tn, sn[];
  Token t;
  bpa("Parameter declaration");
  expecting = "CONSTANT";
} {
  tn = ParamSubDecl()  { addHeir(tn); }
{expecting = "Identifier, operator or _";}
  tn = ConstantDeclarationItems() { addHeir(tn); }
{expecting = ",";}
  ( t = <COMMA>      { addHeir( new SyntaxTreeNode(mn, t) ) ; }
{expecting = "Identifier, operator or _";}
    tn = ConstantDeclarationItems() { addHeir(tn); }
  )*
  { sn = getLastHeirs();
    epa(); return new SyntaxTreeNode(mn, N_ParamDeclaration, sn ); }
}


/***************************************************************************
* Used to allow "STATE FUNCTION", "TEMPORAL", etc.                         *
***************************************************************************/
SyntaxTreeNode
ParamSubDecl() : {
  SyntaxTreeNode tn, sn[];
  Token t, u;
  bpa("Parameter declaration item");
 } {
   t = <CONSTANT>  {
     sn = new SyntaxTreeNode[1]; sn[0] = new SyntaxTreeNode(mn, t);
     tn = new SyntaxTreeNode(mn, N_ConsDecl, sn ); }
  { epa();
    return tn; }
}

/***************************************************************************
* Recursive ::= <CONSTANT> ConstantDeclarationItems                        *
*                 ( <COMMA> ConstantDeclarationItems )*                    *
*                                                                          *
* Produces an N_Recursive node.                                            *
***************************************************************************/
SyntaxTreeNode
Recursive() : {
  SyntaxTreeNode tn, sn[];
  Token t;
  bpa("Recursive");
  expecting = "RECURSIVE";
} {
  t = <RECURSIVE> { addHeir(new SyntaxTreeNode(mn, t)); 
                    expecting = "Identifier, operator or _";}
  tn = ConstantDeclarationItems() { addHeir(tn); 
                                    expecting = ",";}
  ( t = <COMMA>      { addHeir( new SyntaxTreeNode(mn, t) ) ; 
                       expecting = "Identifier, operator or _";}
    tn = ConstantDeclarationItems() { addHeir(tn); 
                                      expecting = "`,' or `)'";}
  )*
  { sn = getLastHeirs();
    epa(); return new SyntaxTreeNode(mn, N_Recursive, sn ); }
}

SyntaxTreeNode
ConstantDeclarationItems() : {
  SyntaxTreeNode tn, sn[];
  int kind;
  Token t;
  bpa( "Constant declaration items");
  expecting = "Identifier, _ or prefix op";
} {
(
  tn = Identifier() { addHeir( tn ); kind = N_IdentDecl;
expecting  = "(, comma, or Module Body"; }
    [ LOOKAHEAD(2)
        /*******************************************************************
        * The following comment apparently made sense at the time.  I      *
        * wonder what it should have said.                                 *
        *                                                                  *
        * This lookahead was added by J-Ch & LL on 1 Mar 2007 to fix the   *
        * error when it tried to parse                                     *
        *                                                                  *
        *    CONSTANT ASSUME A                                             *
        *             (B+C)                                                *
        *    PROVE ...                                                     *
        *******************************************************************/
      t = <LBR> { addHeir( new SyntaxTreeNode( mn, t) ) ;
expecting = "_"; }
      t = <US>  { addHeir( new SyntaxTreeNode( mn, t) ) ;
expecting = "comma or )"; }
      ( t = <COMMA> { addHeir( new SyntaxTreeNode( mn, t) ) ;
expecting = "_"; }
        t = <US>    { addHeir( new SyntaxTreeNode( mn, t) ) ;
expecting = "comma or )"; }
      )*
      t = <RBR> { addHeir( new SyntaxTreeNode( mn, t) ) ; }
    ]
  | // LOOKAHEAD( <OpSymbol>, { isPrefixDeclOp( getToken(1) )  } )
    tn = NonExpPrefixOp() {
expecting = "_";
      kind = N_PrefixDecl; addHeir( tn ); }
    t = <US> { addHeir( new SyntaxTreeNode( mn, t) ) ; }
  | t = <US> {
expecting = "prefix or postfix operator"; }
//    (LOOKAHEAD( <OpSymbol>, { isInfixOp( getToken(1) )  } ))
      ( tn = InfixOp() {
expecting = "_";
        kind = N_InfixDecl;
        addHeir( new SyntaxTreeNode( mn, t) );
        addHeir(tn); }
        t = <US> { addHeir( new SyntaxTreeNode( mn, t) ) ; }
      | tn = PostfixOp() {
        kind = N_PostfixDecl;
        addHeir( new SyntaxTreeNode( mn, t) );
        addHeir(tn); }
      )
) { sn = getLastHeirs(); 
    epa();
    return new SyntaxTreeNode( mn, kind, sn); }
}

/***************************************************************************
* The following production OperatorOrFunctionDefinition() produces an      *
* N_OperatorDefinition, N_FunctionDefinition, or N_ModuleDefinition        *
* node.  These nodes have syntax "[LOCAL] ...".  The resulting node n      *
* has n.zero equal to null if the "LOCAL" is missing and equal to an       *
* array of length 1 containing the LOCAL token if it is present.  The      *
* rest of the children/heirs of the node are in the array n.one.           *
***************************************************************************/
SyntaxTreeNode
OperatorOrFunctionDefinition() : {
  SyntaxTreeNode tn;
  SyntaxTreeNode zn = null;
  bpa("Definition");
  int kind = 0;
  String n;
  Token t;
} {
{ expecting = "LOCAL, Identifier or Operator Symbol"; }
  [ t = <LOCAL> { zn = new SyntaxTreeNode( mn, t);} ]
  t = <DEFBREAK> // skip over
{ expecting = "LOCAL, Identifier or Operator Symbol"; }
  ( LOOKAHEAD (<IDENTIFIER> <LSB> ) /* recognize function */
        tn = Identifier() { addHeir( tn );  kind = N_FunctionDefinition;
expecting = "["; }
        t = <LSB> {
          addHeir( new SyntaxTreeNode(mn, t) );
expecting = "Identifier";
        }
        tn = QuantBound() { addHeir( tn );
expecting = "COMMA or ]"; }
        ( t = <COMMA> { addHeir( new SyntaxTreeNode(mn, t) );
expecting = "Identifier"; }
          tn = QuantBound() { addHeir( tn ); } // was FunctionParam
        )*
        t = <RSB> {
expecting = "==";
          addHeir( new SyntaxTreeNode(mn, t) ); }
        t = <DEF>  { belchDEF(); addHeir( new SyntaxTreeNode(mn, t) );
expecting = "Expression"; }
        tn = Expression() { addHeir( tn ); }
    |
//      LOOKAHEAD ( <IDENTIFIER> <OpSymbol>, { isPostfixOp( getToken(2) ) } )
      LOOKAHEAD ( <IDENTIFIER> PostfixOpToken() )
        tn = PostfixLHS() {  addHeir( tn );
expecting = "=="; }
        t = <DEF>  { belchDEF(); kind = N_OperatorDefinition;
          addHeir( new SyntaxTreeNode(mn, t) );
expecting = "Expression";  }
        tn = Expression() { addHeir( tn ); }
    |
//      LOOKAHEAD ( <IDENTIFIER> <OpSymbol>, { isInfixOp( getToken(2) ) } )
      LOOKAHEAD ( <IDENTIFIER> InfixOpToken() )
        tn = InfixLHS() {  addHeir( tn );
expecting = "=="; }
        t = <DEF>  { belchDEF();  kind = N_OperatorDefinition;
          addHeir( new SyntaxTreeNode(mn, t) );
expecting = "Expression";  }
        tn = Expression() { addHeir( tn ); }
    |
      LOOKAHEAD ( <IDENTIFIER> ( <LBR> | <DEF>)  ) /* recognize operator OR module instance */
        tn = IdentLHS() { addHeir( tn );
expecting = "=="; }
        t = <DEF>  { belchDEF(); addHeir( new SyntaxTreeNode(mn, t) );
expecting = "Expression or Instance";  }
        ( tn = Expression() { kind = N_OperatorDefinition; }
        | tn = Instantiation()   { kind = N_ModuleDefinition; }
        ) { addHeir( tn ); }
    |
      tn = PrefixLHS() { addHeir( tn );
expecting = "=="; }
      t = <DEF>  { belchDEF();
        kind = N_OperatorDefinition;
        addHeir( new SyntaxTreeNode(mn, t) );
expecting = "Expression";  }
      tn = Expression() { addHeir( tn ); }
  )
  { SyntaxTreeNode sn[] = getLastHeirs();
    epa(); return new SyntaxTreeNode(mn,kind, zn, sn);
  }
}

SyntaxTreeNode
IdentifierTuple( ) : {
  SyntaxTreeNode tn;
  SyntaxTreeNode hn[];
  Token t;
  bpa("Identifier tuple");
}{
  t = <LAB>  { addHeir( new SyntaxTreeNode(mn, t) );
expecting = "Identifier or >>"; }
  [ tn = Identifier() { addHeir( tn );
expecting = "COMMA or >>"; }
    (
      t = <COMMA> { addHeir( new SyntaxTreeNode(mn, t) );
expecting = "COMMA or >>"; }
      tn = Identifier() { addHeir( tn );
expecting = "COMMA or >>"; }
    )* ]
  t = <RAB>  { addHeir( new SyntaxTreeNode(mn, t) ); }
  { SyntaxTreeNode sn[] = getLastHeirs();
    epa(); return new SyntaxTreeNode( mn, N_IdentifierTuple, sn  ); }
}

SyntaxTreeNode
IdentLHS() : {
  SyntaxTreeNode tn;
  Token t;
  bpa("Identifier LHS");
} {
  tn = Identifier() { addHeir( tn );
expecting = "( or =="; }
  ( [ t = <LBR> { addHeir( new SyntaxTreeNode(mn, t) );
expecting = "Identifier Declaration, prefix op, _ or )"; }
      ( tn = IdentDecl() | tn = SomeFixDecl() )  { addHeir( tn );
expecting = "COMMA or )"; }
      ( t = <COMMA>  { addHeir( new SyntaxTreeNode(mn, t) );
expecting = "Identifier Declaration, prefix op or _"; }
        ( tn = IdentDecl() | tn = SomeFixDecl() )  { addHeir( tn );
expecting = "COMMA or )"; }
      )*
      t = <RBR> { addHeir( new SyntaxTreeNode(mn, t) ); }
    ]
  )
  { SyntaxTreeNode sn[] = getLastHeirs();
    epa(); return new SyntaxTreeNode( mn, N_IdentLHS, sn); }
}

SyntaxTreeNode
PrefixLHS() : {
  SyntaxTreeNode sn[] = new SyntaxTreeNode[2];
  SyntaxTreeNode tn;
  Token t;
  bpa("Prefix LHS");
} {
  t = NEPrefixOpToken()   { sn[0] = new SyntaxTreeNode(mn, t);
expecting = "Identifier"; }
  tn = Identifier() { sn[1] = tn; }
  { epa(); return new SyntaxTreeNode( mn, N_PrefixLHS, sn ); } 
}

SyntaxTreeNode
InfixLHS() : {
  SyntaxTreeNode sn[] = new SyntaxTreeNode[3];
  SyntaxTreeNode tn;
  Token t;
  bpa("Infix LHS");
} {
  tn = Identifier() { sn[0] = tn; }
  t = InfixOpToken()   { sn[1] = new SyntaxTreeNode(mn, t); }
  tn = Identifier() { sn[2] = tn; }
  { epa(); return new SyntaxTreeNode( mn, N_InfixLHS, sn ); } 
}

SyntaxTreeNode
PostfixLHS() : {
  SyntaxTreeNode sn[] = new SyntaxTreeNode[2];
  SyntaxTreeNode tn;
  Token t;
  bpa("Postfix LHS");
} {
  tn = Identifier() { sn[0] = tn; }
  t = PostfixOpToken()   { sn[1] = new SyntaxTreeNode(mn, t); }
  { epa(); return new SyntaxTreeNode( mn, N_PostfixLHS, sn ); }
}

SyntaxTreeNode
IdentDecl() : {
  SyntaxTreeNode tn;
  Token t;
  bpa("Identifier Declation");
} {
  tn = Identifier() { addHeir( tn );
expecting = "( or ..."; }
  [ t = <LBR>  { addHeir( new SyntaxTreeNode(mn, t) );
expecting = "_"; }
    t = <US>  { addHeir( new SyntaxTreeNode(mn, t) );
expecting = "COMMA or )"; }
    (
      t = <COMMA>  { addHeir( new SyntaxTreeNode(mn, t) );
expecting = "_"; }
      t = <US>  { addHeir( new SyntaxTreeNode(mn, t) );
expecting = "COMMA or )"; }
    )*
    t = <RBR>  { addHeir( new SyntaxTreeNode(mn, t) ); }
  ]
  { SyntaxTreeNode sn[] = getLastHeirs();
    epa(); return new SyntaxTreeNode( mn, N_IdentDecl, sn); }
}

SyntaxTreeNode
SomeFixDecl() : {
  SyntaxTreeNode localASTN = null;
  SyntaxTreeNode tn;
  SyntaxTreeNode sn[] = null;
  int kind;
  Token t;
  UniqueString n;
  bpa("Op. Symbol Declaration");
} {
  ( // LOOKAHEAD( <OpSymbol>, { isPrefixDeclOp( getToken(1) )  } )
      tn = NonExpPrefixOp() {
        kind = N_PrefixDecl; n = lastOp.getIdentifier();
        sn = new SyntaxTreeNode[2]; sn[0] = tn;
expecting = "_"; }
      t = <US>  { sn[1] = new SyntaxTreeNode(mn, t); }
    | 
    ( t = <US> {
expecting = "infix or postfix operator"; }
//      ( LOOKAHEAD( <OpSymbol>, { isInfixOp( getToken(1) )  } )
      ( tn =  InfixOp() {
          kind = N_InfixDecl; n = lastOp.getIdentifier();
          sn = new SyntaxTreeNode[3]; sn[1] = tn;
          sn[0] =  new SyntaxTreeNode(mn, t);
expecting = "_"; }
        t = <US>     { sn[2] = new SyntaxTreeNode(mn, t);}
      | tn = PostfixOp() {
          kind = N_PostfixDecl; n = lastOp.getIdentifier();
          sn = new SyntaxTreeNode[2]; sn[1] = tn;
          sn[0] =  new SyntaxTreeNode(mn, t); }
      )
    )
  )
  { epa(); return new SyntaxTreeNode(mn, kind, sn); } 
}

SyntaxTreeNode
Instance() : {
  SyntaxTreeNode tn;
  SyntaxTreeNode zn = null;
  Token t;
  bpa("Instance");
expecting = "LOCAL or instance";
} {
  [ t = <LOCAL> { 
    zn =  new SyntaxTreeNode(mn, t);} ]
  tn = Instantiation() { addHeir( tn );
expecting = "COMMA or Module Body"; }
  { SyntaxTreeNode sn[] = getLastHeirs();
    epa(); return new SyntaxTreeNode( mn, N_Instance, zn, sn); } 
}

SyntaxTreeNode
Instantiation() : {
  SyntaxTreeNode tn;
  Token t;
  bpa("NonLocalInstance");
} {
  t = <INSTANCE>  { addHeir( new SyntaxTreeNode(mn, t) );
expecting = "Module identifier";
  t = getToken(1);
  if (isFieldNameToken( t )) t.kind = IDENTIFIER; }
  tn = Identifier() { addDependency( tn.image ); addHeir( tn );
expecting = "WITH or another definition."; }
  [ t = <WITH>  { addHeir( new SyntaxTreeNode(mn, t) );
expecting = emptyString; }
    tn = Substitution() { addHeir( tn );
expecting = emptyString; }
    ( LOOKAHEAD(3)
      t = <COMMA>  { addHeir( new SyntaxTreeNode(mn, t) );
expecting = emptyString; }
      tn = Substitution() { addHeir( tn );
expecting = emptyString; }
    )*
  ]
  { SyntaxTreeNode sn[] = getLastHeirs();
    epa(); return new SyntaxTreeNode( mn, N_NonLocalInstance, sn); } 
}


SyntaxTreeNode
/***************************************************************************
* Substitution ::=                                                         *
*     ( Identifier | NonExpPrefixOp | InfixOp | PostfixOp)                 *
*     <SUBSTITUTE> OpOrExpr                                                *
*                                                                          *
* Note: <op_76> is "-.", the prefix - operator.                            *
*       <SUBSTITUTE> is "<-"                                               *
*                                                                          *
* Modified 27 March 2007 by LL to allow Lambda substitutions.              *
***************************************************************************/
Substitution() : {
  SyntaxTreeNode zn[] = new SyntaxTreeNode[3];
  SyntaxTreeNode tn = null;
  Token t;
  anchor = null;
    /***********************************************************************
    * See the comments for the declaration of anchor to see what this is   *
    * being used for.                                                      *
    ***********************************************************************/
  String n;
  bpa("Substitution");
} {
  ( tn = Identifier() { zn[0] = tn; }
/*
  | LOOKAHEAD( <OpSymbol>, { isPrefixDeclOp( getToken(1) )  } ) tn = NonExpPrefixOp() { zn[0] = tn; }
  | LOOKAHEAD( <OpSymbol>, { isInfixOp( getToken(1) )  } ) tn = InfixOp() { zn[0] = tn; }
  | LOOKAHEAD( <OpSymbol>, { isPostfixOp( getToken(1) )  } ) tn = PostfixOp() { zn[0] = tn; }
*/
  | tn = NonExpPrefixOp() { zn[0] = tn; }
  | tn = InfixOp() { zn[0] = tn; }
  | tn = PostfixOp() { zn[0] = tn; }
  )
{ expecting = "<-"; }
  t = <SUBSTITUTE> { n = tn.getImage();
     zn[1] = new SyntaxTreeNode(mn, t);
expecting = "Expression or Op. Symbol"; }
  tn = OpOrExpr()
  { epa(); zn[2] = tn; return new SyntaxTreeNode(mn, N_Substitution, zn ); }
}

/***************************************************************************
* Substitution ::=                                                         *
*     ( Identifier | NonExpPrefixOp | InfixOp | PostfixOp)                 *
*     <SUBSTITUTE> ( <op_76> | Lambda | Expression )                       *
*                                                                          *
* Note: <op_76> is "-.", the prefix - operator.                            *
*       <SUBSTITUTE> is "<-"                                               *
*                                                                          *
* Modified 27 March 2007 by LL to allow Lambda substitutions.              *
***************************************************************************/
SyntaxTreeNode
OldSubstitution() : {
  SyntaxTreeNode zn[] = new SyntaxTreeNode[3];
  SyntaxTreeNode tn = null;
  Token t;
  anchor = null;
    /***********************************************************************
    * See the comments for the declaration of anchor to see what this is   *
    * being used for.                                                      *
    ***********************************************************************/
  String n;
  bpa("Substitution");
} {
  ( tn = Identifier() { zn[0] = tn; }
/*
  | LOOKAHEAD( <OpSymbol>, { isPrefixDeclOp( getToken(1) )  } ) tn = NonExpPrefixOp() { zn[0] = tn; }
  | LOOKAHEAD( <OpSymbol>, { isInfixOp( getToken(1) )  } ) tn = InfixOp() { zn[0] = tn; }
  | LOOKAHEAD( <OpSymbol>, { isPostfixOp( getToken(1) )  } ) tn = PostfixOp() { zn[0] = tn; }
*/
  | tn = NonExpPrefixOp() { zn[0] = tn; }
  | tn = InfixOp() { zn[0] = tn; }
  | tn = PostfixOp() { zn[0] = tn; }
  )
{ expecting = "<-"; }
  t = <SUBSTITUTE> { n = tn.getImage();
     zn[1] = new SyntaxTreeNode(mn, t);
expecting = "Expression or Op. Symbol"; }
  try {
    ( LOOKAHEAD( <op_76> )
    t = <op_76> {
      SyntaxTreeNode zzn[] = new SyntaxTreeNode[2];
      zzn[0] = new SyntaxTreeNode( mn, N_IdPrefix, new SyntaxTreeNode[0] );
      zzn[1] =  new SyntaxTreeNode( mn, N_NonExpPrefixOp, t );
      tn = new SyntaxTreeNode( mn, N_GenNonExpPrefixOp, zzn );
    }
|   tn = Expression() 
|   tn = Lambda()
)
  } catch ( ParseException e ) {
// first things first - restore evaluation stack
    if ( OperatorStack.isWellReduced() )
      OperatorStack.popStack();
    else
      throw e;
// check the nature of the node returned. It can only be a GenOp. */
// should be reviewed - N_GenNonExpPrefixOp may be unnecessary because -. has been checked.
    if ( ( anchor != null )
       &&( anchor.isKind( N_GenPrefixOp ) || anchor.isKind( N_GenInfixOp ) || anchor.isKind( N_GenPostfixOp ) || anchor.isKind( N_GenNonExpPrefixOp ) ) ) {
       tn = anchor; anchor = null;
    } else
       throw e;
  }
  { epa(); zn[2] = tn; return new SyntaxTreeNode(mn, N_Substitution, zn ); }
}


SyntaxTreeNode
PrefixOp() : {
  Token t;
}{
  t = PrefixOpToken() {
    lastOp = Operators.getOperator( UniqueString.uniqueStringOf(t.image) ); // YYY to revise
    return new SyntaxTreeNode(mn, N_PrefixOp, t) ; }
}

SyntaxTreeNode
NonExpPrefixOp() : {
  Token t;
}{
  t = NEPrefixOpToken() {
    lastOp = Operators.getOperator( UniqueString.uniqueStringOf(t.image) ); // YYY to revise
    return new SyntaxTreeNode(mn, N_NonExpPrefixOp, t) ; }
}

SyntaxTreeNode
InfixOp() : {
  Token t;
bpa("Infix Op") ;
}{
  t = InfixOpToken() {
    lastOp = Operators.getOperator( UniqueString.uniqueStringOf(t.image) ); // YYY to revise
epa();
    return new SyntaxTreeNode( mn, N_InfixOp, t) ;
  }
}

SyntaxTreeNode
PostfixOp() : {
  Token t;
}{
  t = PostfixOpToken() {
    lastOp = Operators.getOperator( UniqueString.uniqueStringOf(t.image) ); // YYY to revise
    return new SyntaxTreeNode(mn, N_PostfixOp, t) ;
  }
}

SyntaxTreeNode
Identifier() : {
  Token t;
}{
  t = <IDENTIFIER> { return new SyntaxTreeNode(mn, t); }
}

/***************************************************************************
* Assumption ::= ( <ASSUME> | <ASSUMPTION> )                               *
*                  ( Identifier <DEF> )? Expression                        *
***************************************************************************/
SyntaxTreeNode
Assumption() : {
  SyntaxTreeNode tn;
  SyntaxTreeNode zn = null;
  Token t;
  bpa("Assumption");
// expecting = "LOCAL or ASSUM...";
expecting = "ASSUM...";
}{
//  [ t = <LOCAL> { zn = new SyntaxTreeNode(mn, t); } ]
  ( t = <ASSUMPTION> | t = <ASSUME> ) { addHeir( new SyntaxTreeNode(mn, t) ); }
  [ LOOKAHEAD(2) /* because of Expression, following */
   (t = <DEFBREAK>)? /* A DEFBREAK might get added here by belchDEF */
    tn = Identifier() { addHeir( tn );
expecting = "=="; }
    t = <DEF>        { // belchDEF(); extra belchDEF removed 15 Mar 2007 by LL because it caused
                       // an extra <DEFBREAK> to be inserted, producing an error.
                       addHeir( new SyntaxTreeNode(mn, t) ); }
  ]
  {  belchDEF();
expecting = "Expression"; }
  tn = Expression() 
  { addHeir(tn); }
  { SyntaxTreeNode sn[] = getLastHeirs();
    epa(); return new SyntaxTreeNode( mn, N_Assumption, zn, sn); }
}

SyntaxTreeNode
AssumeProve () : {
  /*************************************************************************
  * AssumeProve ::= (<IDENTIFIER> <COLONCOLON>)?                           *
  *                 <ASSUME> (AssumeProve | NewDecl | Expression)          *
  *                  (<COMMA> (AssumeProve  | NewDecl | Expression))+      *
  *                 <PROVE> Expression                                     *
  *                                                                        *
  * For ASSUME A1, A2 PROVE B, it constructs an AssumeProve node tn with   *
  * tn.zero equal to the array containing the 6 elements                   *
  *                                                                        *
  *     "ASSUME"  A1  ","  A2  "PROVE"  B                                  *
  *                                                                        *
  * If there is a label "foo::", it returns an N_Label node.               *
  *                                                                        *
  * Changed 18 May 2008 by LL to allow a label.                            *
  *************************************************************************/
  SyntaxTreeNode tn;
  Token t;
  SyntaxTreeNode sn[] ;
  bpa("Assume-Prove");
}{
  ( tn = Identifier()  {
      /*********************************************************************
      * The semantic analyzer expects the label name to be a GeneralId     *
      * node whose first child is an empty N_IdPrefix node and whose       *
      * second child is the label's Identifier node.                       *
      *********************************************************************/
      addHeir(new SyntaxTreeNode(
                    mn,
                    N_GeneralId,
                    new SyntaxTreeNode[] { 
                       new SyntaxTreeNode(
                             mn,
                             N_IdPrefix,
                             new SyntaxTreeNode[0]),
                       tn}
                      ) ) ;
      }
    t = <COLONCOLON>   {addHeir( new SyntaxTreeNode(mn, t) );}
    tn = AssumeProve() {addHeir(tn);}
    { sn = getLastHeirs();
      epa(); 
      return new SyntaxTreeNode( mn, N_Label, sn); 
    }
  )?

  t = <ASSUME>  { addHeir( new SyntaxTreeNode(mn, t) );
expecting = "Expression, Declaration, or AssumeProve"; }

  (  LOOKAHEAD ({(getToken(1).kind == ASSUME)
                   || (getToken(3).kind == ASSUME)})
     tn = AssumeProve() 
   | tn = NewSymb() 
   | tn = Expression() { }
  ) { addHeir(tn); 
expecting = "PROVE or `,'"; }
  ( t = <COMMA> { addHeir( new SyntaxTreeNode(mn, t) );
expecting = "Expression, Declaration, or AssumeProve"; }
    (  LOOKAHEAD({(getToken(1).kind == ASSUME)
                   || (getToken(3).kind == ASSUME)})
       tn = AssumeProve() 
     | tn = NewSymb() 
     | tn = Expression() 
    ) 
    { addHeir(tn); 
expecting = "PROVE or `,'"; }
  )*
  t = <PROVE> { addHeir( new SyntaxTreeNode(mn, t) );
expecting = "Expression"; }
  tn = Expression() { addHeir( tn ); }
  { sn = getLastHeirs();
    epa(); return new SyntaxTreeNode( mn, N_AssumeProve, sn); }
}

SyntaxTreeNode
NewSymb () : {
  /*************************************************************************
  * NewSymb ::=   (<NEW> | <CONSTANT> | <NEW> <CONSTANT>)                  *
  *               (Identifier <IN> Expression | IdentDecl | SomeFixDecl)   *
  *              | [<NEW>] <VARIABLE> Identifier                           *
  *              | [<NEW>] (<STATE> | <ACTION> | <TEMPORAL>)               *
  *                (IdentDecl | SomeFixDecl)                               *
  *************************************************************************/
  SyntaxTreeNode tn ;
  Token t ;
  boolean hasArgs ;
    /***********************************************************************
    * We want to allow "NEW Id \in S" but disallow "NEW Id(_) \in S".      *
    * For simplicity, the we do this by letting javacc accept either, but  *
    * set hasArgs to true in the latter case and report the error when we  *
    * detect the "\in".                                                    *
    ***********************************************************************/
  bpa( "NEW symbol declaration");
  expecting = "NEW, CONSTANT, VARIABLE, STATE, ACTION, or TEMPORAL";
} { 
( LOOKAHEAD(2)
     ( LOOKAHEAD(2)
         t = <NEW>        {addHeir( new SyntaxTreeNode(mn, t) );} 
         t = <CONSTANT>   {addHeir( new SyntaxTreeNode(mn, t) );} 
       | t = <NEW>        {addHeir( new SyntaxTreeNode(mn, t) );} 
       | t = <CONSTANT>   {addHeir( new SyntaxTreeNode(mn, t) );} 
     )
     {expecting = "Constant declaration"; }
     ( LOOKAHEAD(2)
         tn = IdentDecl() { hasArgs = tn.heirs().length > 1;
                            addHeir (tn) ; }
         [ t = <IN> { if (hasArgs) {
                        throw new ParseException(
                          "declared symbol with arguments before \\in at "
                           + tn.getLocation().toString());
                        } ;
                      addHeir(new SyntaxTreeNode(mn, t) ); 
                      expecting = "Expression";}
           tn = Expression() { addHeir (tn) ; }
         ]
      |
         tn = SomeFixDecl() { addHeir (tn) ; }
     )
     
 |   LOOKAHEAD(2)  
     [t = <NEW>  { addHeir(new SyntaxTreeNode(mn, t) );}]
     t = <VARIABLE> { addHeir(new SyntaxTreeNode(mn, t) );
                      expecting = "Identifier"; }
     tn = Identifier() { /**************************************************
                         * The semantic processor expects an N_IdentDecl   *
                         * node, and doesn't cope with a bare Identifier   *
                         * node.                                           *
                         **************************************************/
                         SyntaxTreeNode[] sn = new SyntaxTreeNode[1] ;
                         sn[0] = tn ;
                         addHeir(new SyntaxTreeNode( mn, N_IdentDecl, sn)); }

 |  LOOKAHEAD(2)  
     [  t = <NEW>  { addHeir(new SyntaxTreeNode(mn, t)); }]
     (  t = <STATE> |  t = <ACTION> | t = <TEMPORAL> )
     { addHeir( new SyntaxTreeNode(mn, t));
       expecting = "Declaration" ; }
     (   tn = IdentDecl() {addHeir(tn);}
       | tn = SomeFixDecl() {addHeir(tn);}
     )
)
  { SyntaxTreeNode sn[] = getLastHeirs();
    epa(); return new SyntaxTreeNode( mn, N_NewSymb, sn); } 
}


// NumberedAssumeProve() commented out 5 Mar 2007 by LL
// number . sequence 
// SyntaxTreeNode
// NumberedAssumeProve () : {
//   SyntaxTreeNode tn;
//   Token t;
//   boolean b = false;
//   bpa("Numbered Assume-Prove");
// }{
//   [ LOOKAHEAD(2)
//     t = <NUMBER_LITERAL>  { addHeir( new SyntaxTreeNode(mn, t) );
// expecting = "."; }
//     t = <DOT> {
//       BStack.newReference(t.endColumn, ASSUME); b = true;
//       addHeir( new SyntaxTreeNode(mn, t) );
// expecting = "Assume-Prove, Assume-Decl or expression"; } ]
//   ( tn = AssumeProve()
//   | LOOKAHEAD( { IsNotExpression() } ) tn = AssumeDecl()
//   | tn = Expression() ) /* XXX parser confusion here !!! */
//   { if (b) BStack.popReference();
//     addHeir(tn);
//     SyntaxTreeNode sn[] = getLastHeirs();
//     epa(); return new SyntaxTreeNode( mn, N_NumberedAssumeProve, sn); }
// }

// AssumeDecl() commented out 27 March 2007; it seems to be left over
//   from the old proof grammar.
// SyntaxTreeNode
// AssumeDecl () : {
//   SyntaxTreeNode zn[] = null;
//   SyntaxTreeNode tn;
//   Token t;
//   bpa("Assume Decl.");
// }{
//   ( tn = VariableDeclaration() { zn = new SyntaxTreeNode[1]; zn[0] = tn; }
//   | ( tn = ParamDeclaration() {
//         zn = new SyntaxTreeNode[2]; zn[0] = tn;
// expecting = "optional \\in or ..."; }
//       zn[1] = MaybeBound() )
//   | LOOKAHEAD (2) tn = OperatorOrFunctionDefinition() { zn = new SyntaxTreeNode[1]; zn[0] = tn; }
//   | tn = Instance() { zn = new SyntaxTreeNode[1]; zn[0] = tn; } )
//   { epa();
//     return new SyntaxTreeNode( mn, N_AssumeDecl, zn );  }
// }

SyntaxTreeNode
MaybeBound() : {
  SyntaxTreeNode zn[] = null;
  SyntaxTreeNode tn;
  Token t;
  bpa("Domain binding");
}{
  [ t = <IN> {
      zn    = new SyntaxTreeNode[2];
      zn[0] =  new SyntaxTreeNode(mn, t);
      zn[0].setKind(T_IN);
expecting = "Expression"; }
    zn[1] = Expression()  ]
  { epa(); return new SyntaxTreeNode( mn, N_MaybeBound, zn); }
}




/***************************************************************************
* Theorem ::= ( <THEOREM> | <PROPOSITION> )                                *
*                ( Identifier <DEF> )? ( AssumeProve | Expression )        *
*                                                                          *
* Produces a Theorem node tn with tn.zero containing 2 or 4 nodes,         *
* depending on whether or not the "Identifier <DEF>" is present.           *
***************************************************************************/
SyntaxTreeNode
Theorem() : {
  SyntaxTreeNode tn;
  Token t;
  bpa("Theorem");
expecting= "THEOREM, PROPOSITION";
}{
  //  [ t = <LOCAL> { zn = new SyntaxTreeNode(mn, t); } ]  // "LOCAL THEOREM" was eliminated.
  ( t = <THEOREM> | t = <PROPOSITION> ) { addHeir( new SyntaxTreeNode(mn, t) );
expecting = "Identifier, Assume-Prove or Expression"; }
  [ LOOKAHEAD(2)
    tn = Identifier() { addHeir( tn );
expecting = "=="; }
    t = <DEF>        { // belchDEF(); extra belchDEF removed 15 Mar 2007 by LL because it caused
                       // an extra <DEFBREAK> to be inserted, producing an error.
                       addHeir( new SyntaxTreeNode(mn, t) ); }
  ]
  { belchDEF(); }
  (  LOOKAHEAD (3)
     LOOKAHEAD({getToken(1).kind == ASSUME})     
     tn = AssumeProve() 
   | tn = Expression() )
  { addHeir(tn); }

  /*************************************************************************
  * Get proof. (Added by LL on 22 Jul 07)                                  *
  *************************************************************************/
  (   LOOKAHEAD (  {beginsProof(getToken(1))} )
     tn = Proof() 
     { addHeir(tn) ; }
   )?

  {SyntaxTreeNode sn[] = getLastHeirs();
    epa(); return new SyntaxTreeNode( mn, N_Theorem, sn); }
}



/***************************************************************************
* The Grammar of Proofs                                                    *
*  XXXXXXX THIS IS OBSOLETE                                                *
* Proof ::= InnerProof                                                     *
*   // Proof checks that we're not inside a proof at the end.              *
*                                                                          *
* InnerProof ::=                                                           *
*      TerminalProof                                                       *
*    | (<PROOF>)?                                                          *
*      ( Step )* // Terminated by lookahead for "QED"                      *
*      QEDStep                                                             *
*                                                                          *
*   // Note: (InnerProof)? uses lookahead for beginsProof(...)             *
*                                                                          *
* TerminalProof ::=    <BY> ...                                            *
*                    | (<PROOF>)? OBVIOUS                                  *
* QEDStep ::= (<ProofStepLexeme> | <ProofStepDotLexeme> )?                 *
*             <QED> (InnerProof)?                                          *
*                                                                          *
* Step ::=   N_DefStep                                                     *
*          | N_UseOrHide                                                   *
*          | N_NonLocalInstance                                            *
*          | N_NumerableStep                                               *
*          | N_QEDStep                                                     *
*                                                                          *
* NumerableStep ==    ExprStep                                             *
*                   | NumberedStep                                         *
*                   | UnnumberedStep                                       *
*                                                                          *
* DefStep ::= (<DEFINE>)? OperatorOrFunctionDefinition                     *
*                                                                          *
* NumberedStep ::= (<ProofStepLexeme> | <ProofStepDotLexeme> )             *
*                  UnnumberedStep                                          *
*                                                                          *
* ExprStep ::= (   <PROVE>                                                 *
*                | <SUFFICES>                                              *
*                | (<ProofStepLexeme> | <ProofStepDotLexeme> )             *
*                  (<SUFFICES>)?                                           *
*              )                                                           *
*              Expression                                                  *
*                                                                          *
* UnnumberedStep ::=                                                       *
*     Have                                                                 *
*   | Take                                                                 *
*   | Witness                                                              *
*   | (  Pick                                                              *
*      | (<SUFFICES>)? (AssumeProve | <CASE> Expression)                   *
*     )                                                                    *
*     (InnerProof)?                                                        *
***************************************************************************/


SyntaxTreeNode
Proof() : {
/***************************************************************************
* Returns an N_Proof or N_TerminalProof node.  The heirs of an N_Proof     *
* node consist of an option PROOF token followed by a seequence of         *
* N_ProofStep nodes.  The heirs of an N_ProofStep node are a StartStep()   *
* token, a statement body, and an optional proof.  A statement body is     *
* one of the following node kinds:                                         *
*                                                                          *
*   Have no proof:                                                         *
*     N_DefStep   N_UseOrHide   N_NonLocalInstance   N_HaveStep,           *
*     N_TakeStep  N_WitnessStep                                            *
*                                                                          *
*   Have a proof                                                           *
*     N_QEDStep  N_PickStep   N_CaseStep   N_AssertStep                    *
***************************************************************************/
  SyntaxTreeNode tn;
  Token t = null ;
  Token t0 = null;
  pushProofLevel() ;
  bpa("Proof");
}{ 
(  LOOKAHEAD( { (getToken(1).kind == BY) || (getToken(2).kind == BY) } )
   tn = UseOrHideOrBy()
 | LOOKAHEAD(2)
   (t0 = <PROOF>)?
   (t = <OBVIOUS> | t = <OMITTED>) 
   { SyntaxTreeNode sn[] ;
     if (t0 != null) {
       sn = new SyntaxTreeNode[2];
       sn[0] = new SyntaxTreeNode(mn, t0);
       sn[1] = new SyntaxTreeNode(mn, t);
      }
     else {
       sn = new SyntaxTreeNode[1];
       sn[0] = new SyntaxTreeNode(mn, t);
      };
     tn = new SyntaxTreeNode(mn, N_TerminalProof, sn ); }

 | ( LOOKAHEAD(2)
     t = <PROOF> {addHeir(new SyntaxTreeNode(mn, t));} )?
   ( LOOKAHEAD ( { getToken(2).kind != QED } )
      tn = Step() {addHeir(tn);
                   expecting = "a proof step";} 
   )*
   tn = QEDStep() 
   { addHeir(tn);
     SyntaxTreeNode sn[] = getLastHeirs();
     tn = new SyntaxTreeNode(mn, N_Proof, sn ); }
)
 { 
   epa(); 
   popProofLevel() ;
   return tn ; }
}

SyntaxTreeNode
UseOrHideOrBy() : {
/***************************************************************************
* Returns an N_TerminalProof (for a BY) or N_UseOrHide node.  Having       *
* one nonterminal that returns both is the only easy way I know to         *
* avoid having to duplicate the code for handling BY and for handling      *
* USE/HIDE.  Lookahead should prevent it from being called to parse        *
* the wrong kind of object.                                                *
*                                                                          *
* Note: This production accepts a By, USE, or HIDE with no items.  This    *
* should be reported by an error in the semantic analysis phase.           *
***************************************************************************/
  SyntaxTreeNode tn;
  Token t;
  int kind = N_UseOrHide;
  bpa("UseOrHideOrBy");
}{  ( (t = <PROOF> {addHeir(new SyntaxTreeNode(mn, t)); })?
      t = <BY>  {kind = N_TerminalProof;}
    | t = <USE> 
    | t = <HIDE> 
   )
   {addHeir(new SyntaxTreeNode(mn, t));
    expecting = "an expression, `MODULE' or `DEF'"; }
   ( (   t = <MODULE>      { addHeir( new SyntaxTreeNode(mn, t) ); 
                             expecting = "identifier";}
         tn = Identifier() { addHeir(tn); }
       | tn = Expression() {addHeir(tn);}
     )
     ( t = <COMMA> { addHeir( new SyntaxTreeNode(mn, t) ); 
                     expecting = "MODULE or expression";}
       (   t = <MODULE>      { addHeir( new SyntaxTreeNode(mn, t) ); 
                               expecting = "identifier";}
           tn = Identifier() { addHeir(tn); }
         | tn = Expression() {addHeir(tn);}
       )
       { if (kind == N_TerminalProof) { expecting = "comma, DEF, or [.]"; }
         else {expecting = "comma, DEF, or proof step";};
       }
     )*
   )?
   ( t = <DF> { addHeir( new SyntaxTreeNode(mn, t) ); 
                expecting = "MODULE or expression";}
     (   t = <MODULE>      { addHeir( new SyntaxTreeNode(mn, t) ); 
                               expecting = "identifier"; }
         tn = Identifier() { addHeir(tn); }
       | tn = Expression() {addHeir(tn);}
     )
     ( t = <COMMA> { addHeir( new SyntaxTreeNode(mn, t) );  
                     expecting = "MODULE or expression"; }
       (   t = <MODULE>      { addHeir( new SyntaxTreeNode(mn, t) ); 
                               expecting = "identifier";}
           tn = Identifier() { addHeir(tn); }
         | tn = Expression() {addHeir(tn);}
       )
        { if (kind == N_TerminalProof) { expecting = "comma or [.]"; }
         else {expecting = "comma or proof step" ; };
       }
     )*
  )?
   {if (kind == N_TerminalProof) {expecting = "[.]";}; }
// removed the terminal [.]
//   ( LOOKAHEAD( { kind == N_TerminalProof } )
//     t = <ENDBY> {addHeir(new SyntaxTreeNode(mn, t));}  
//   )?
  { SyntaxTreeNode sn[] = getLastHeirs();
    epa();
    return new SyntaxTreeNode(mn, kind, sn );
  }
}

Token
StepStartToken() : {
 Token t ;
}{ (  t = <ProofStepLexeme> 
    | t = <ProofImplicitStepLexeme>
    | t = <ProofStepDotLexeme> 
    | t = <BareLevelLexeme> 
    | t = <UnnumberedStepLexeme> )
   { return t ;} 
}

SyntaxTreeNode
QEDStep() : {
/***************************************************************************
* Returns an N_ProofStep node whose body is an N_QEDStep node.             *
***************************************************************************/
 Token t ;
 SyntaxTreeNode tn;
 SyntaxTreeNode[] sn;
 int level = -1 ;
 bpa("QED step") ;
 expecting = "Step number" ;
}{ t = StepStartToken() 
    { tn = new SyntaxTreeNode(mn, t) ;
      if (!correctLevel(t)) {
         throw new ParseException(tn.getLocation().toString() + 
             ": QED step's number has bad level." );
       };  
      if (   (t.kind == ProofImplicitStepLexeme)
          || (t.kind == ProofStepLexeme)
          || (t.kind == ProofStepDotLexeme)) {
        tn.originalImage = tn.image ;
        tn.image = correctedStepNum(t) ;
// ToolIO.out.println("correcting " + tn.originalImage) ;
       } ;
// ToolIO.out.println("xyz: t.image = " + t.image + ", correctedImage = " 
// + tn.image + ", t.kind = " + t.kind ) ;

      addHeir(tn) ; 
      expecting = "QED" ;
    }    

   t = <QED> 
      { sn = new SyntaxTreeNode[1] ;
        sn[0] = new SyntaxTreeNode(mn, t) ;
        addHeir(new SyntaxTreeNode(mn, N_QEDStep, sn));
      }

   ( LOOKAHEAD( {beginsProof(getToken(1))} )
     tn = Proof() 
     { addHeir(tn) ; }
   )?
   { sn = getLastHeirs();
     epa(); 
     return new SyntaxTreeNode(mn, N_ProofStep, sn);
   }
}

SyntaxTreeNode Step() : {
/***************************************************************************
* Returns an N_ProofStep node with the following heirs:                    *
*                                                                          *
*  - A StepStart() token.                                                  *
*                                                                          *
*  - An N_DefStep (for an operator or function def or named                *
*    instantiation, N_UseOrHide, N_NonLocalInstance, N_HaveStep,           *
*    N_TakeStep, N_WitnessStep, N_PickStep, N_CaseStep, or                 *
*    N_AssertStep node.  (An N_AssertStep node has an optional             *
*    "SUFFICES" followed by an expression or N_AssumeProve node.)          *
*                                                                          *
*  - An optional N_Proof or N_TerminalProof node.                          *
*                                                                          *
* Note: The grammar accepts a USE or HIDE with no items.  This should      *
* be reported as an error in the semantic analysis phase.                  *
***************************************************************************/
 Token t = null;
 SyntaxTreeNode tn = null;
 boolean mayHaveProof = false ;
 bpa("Step") ;
 expecting = "Step number" ;
}{ t = StepStartToken() 
    { tn = new SyntaxTreeNode(mn, t); 
      if (!correctLevel(t)) {
         throw new ParseException(tn.getLocation().toString() + 
             ": step's number has bad level." );
        };  
      if (   (t.kind == ProofImplicitStepLexeme)
          || (t.kind == ProofStepLexeme)
          || (t.kind == ProofStepDotLexeme)) {
        tn.originalImage = tn.image ;
        tn.image = correctedStepNum(t) ;
       } ;
// ToolIO.out.println("xyz2: t.image = " + t.image + ", correctedImage = " 
// + tn.image + ", t.kind = " + t.kind ) ;
      addHeir(tn) ;
      expecting = "proof step";
    }
   (  LOOKAHEAD ( { (getToken(1).kind == USE) || (getToken(1).kind == HIDE) } )
      tn = UseOrHideOrBy() {addHeir(tn) ;} 

    | LOOKAHEAD ( {getToken(1).kind == INSTANCE} )
      tn = Instantiation() {addHeir(tn) ;} 

    | LOOKAHEAD ( {   (getToken(1).kind == DEFBREAK) 
                   || (getToken(1).kind == DEFINE) }  )
      tn = DefStep()      {addHeir(tn) ;} 

    | tn = HaveStep()     {addHeir(tn) ;} 
    | tn = TakeStep()     {addHeir(tn) ;} 
    | tn = WitnessStep()  {addHeir(tn) ;} 
    | tn = PickStep()     {addHeir(tn) ;  mayHaveProof = true; } 
    | tn = CaseStep()     {addHeir(tn) ;  mayHaveProof = true; } 
//     ^^^^^^^^^^^
// javacc generates the following warning here:
//
//    Choice conflict involving two expansions at
//    line 2680, column 7 and line 2681, column 7 respectively.
//    A common prefix is: "CASE"
//    Consider using a lookahead of 2 for earlier expansion.
//
// This conflict is between "<1>2.  CASE expr" and 
// "<1>2.  CASE p -> ...".  This is an inherent ambiguity that arises
// from the use of "CASE" as a keyword here.  Javacc resolves
// conflicts by choosing the first successful match.  Here, this
// means that "<1>2.  CASE p -> ..." is parsed as
//
//      <ProofStepDotLexeme> <CASE> Expression()
//
// causing an error when it tries to parse "-> ..." as an expression.
    | tn = AssertStep()   {addHeir(tn) ; mayHaveProof = true; } 
   )

  ( LOOKAHEAD( {beginsProof(getToken(1))} )
    { if (! mayHaveProof) {
         throw new ParseException(tn.getLocation().toString() + 
             ": proof of step that does not take a proof." );
        } ;
     }
     tn = Proof() { addHeir(tn) ; }
  )?

  { SyntaxTreeNode sn[] = getLastHeirs();
     epa(); 
     return new SyntaxTreeNode(mn, N_ProofStep, sn);
  }
}


SyntaxTreeNode
DefStep() : {
/***************************************************************************
* Returns an N_DefStep node whose heirs begin with an optional <DEFINE>    *
* followed by a non-empty sequence of nodes returned by                    *
* OperatorOrFunctionDefinition().                                          *
***************************************************************************/
 Token t = null;
 SyntaxTreeNode tn = null;
 bpa("DefStep") ;
}{ ( t = <DEFINE> { addHeir(new SyntaxTreeNode(mn, t)); }) ?
   ( LOOKAHEAD(2) 
     tn = OperatorOrFunctionDefinition() { addHeir(tn) ; }
   )+
   { SyntaxTreeNode sn[] = getLastHeirs();
     epa();
     return new SyntaxTreeNode(mn, N_DefStep, sn );
   }
}

SyntaxTreeNode
HaveStep() : {
/***************************************************************************
* Returns an N_HaveStep node whose heirs are a <HAVE> token and an         *
* expression node.                                                         *
***************************************************************************/
 Token t = null;
 SyntaxTreeNode tn = null;
 bpa("HaveStep") ;
}{  t = <HAVE> { addHeir(new SyntaxTreeNode(mn, t)); 
                  expecting = "expression";}
    tn = Expression() 
    { addHeir(tn) ;    
      SyntaxTreeNode sn[] = getLastHeirs();
      epa();
      return new SyntaxTreeNode(mn, N_HaveStep, sn );
    }
}

SyntaxTreeNode
TakeStep() : {
/***************************************************************************
* Returns an N_TakeStep node whose first heir is a <TAKE> token and whose  *
* remaining heirs are a sequence of QuantBound() nodes or a sequence of    *
* identifiers.                                                             *
***************************************************************************/
 Token t = null;
 SyntaxTreeNode tn = null;
 bpa("TakeStep") ;
}{ t = <TAKE> { addHeir(new SyntaxTreeNode(mn, t)) ;    
                   expecting = "identifier";}
   ( LOOKAHEAD (  <IDENTIFIER> (<COMMA> <IDENTIFIER>)* <IN> | <LAB>) 
     tn = QuantBound() { addHeir(tn) ;  
                         expecting = "comma or step";}
     ( t = <COMMA> { addHeir( new SyntaxTreeNode(mn, t) ); 
                     expecting = "identifier or tuple of identifiers";}
       tn = QuantBound() { addHeir(tn) ;  
                           expecting = "comma or proof step";}
     )*
   |  
     tn = Identifier() { addHeir(tn) ; 
                         expecting = "comma or proof step";}
     ( t = <COMMA> { addHeir( new SyntaxTreeNode(mn, t) ); 
                     expecting = "identifier";}
       tn = Identifier() { addHeir(tn) ;  
                           expecting = "comma or proof step";}
     )*
   )
    { SyntaxTreeNode sn[] = getLastHeirs();
      epa();
      return new SyntaxTreeNode(mn, N_TakeStep, sn );
    }
}

SyntaxTreeNode
WitnessStep() : {
/***************************************************************************
* Returns an N_WitnessStep node whose heirs are a <WITNESS> token and a    *
* sequence of expression nodes.  It's up to later processing to decide if  *
* those expressions have the form <<expr, ...  , expr>> \in expr,          *
* expr \in expr, or just expr.                                             *
***************************************************************************/
 Token t = null;
 SyntaxTreeNode tn = null;
 bpa("WitnessStep") ;
}{  t = <WITNESS> { addHeir(new SyntaxTreeNode(mn, t)); 
                   expecting = "expression";}
    tn = Expression() { addHeir(tn) ; }
      /*********************************************************************
      * Note: The semantic phase must determine if this is expr \in expr,  *
      * or <<expr, ...  , expr>> \in expr, or just expr.                   *
      *********************************************************************/
      ( t = <COMMA> { addHeir( new SyntaxTreeNode(mn, t) ); 
                        expecting = "expression";}
        tn = Expression() { addHeir(tn) ;  
                            expecting = "comma or colon";}
      )*
    { SyntaxTreeNode sn[] = getLastHeirs();
      epa();
      return new SyntaxTreeNode(mn, N_WitnessStep, sn );
    }
}

SyntaxTreeNode
PickStep() : {
/***************************************************************************
* Returns an N_PickStep node whose heirs are a <PICK> token and an         *
* expression node.                                                         *
***************************************************************************/
 Token t = null;
 SyntaxTreeNode tn = null;
 bpa("PickStep") ;
}{  t = <PICK> { addHeir(new SyntaxTreeNode(mn, t)) ;  
                 expecting = "identifier";}
    ( LOOKAHEAD ( <IDENTIFIER> ( <COMMA> <IDENTIFIER> )* <COLON> ) 
                        /* CommaList Identifier */
      tn = Identifier() { addHeir(tn) ; 
                          expecting = "comma, or colon";}
      ( t = <COMMA> { addHeir( new SyntaxTreeNode(mn, t) ); 
                      expecting = "identifier";}
        tn = Identifier() { addHeir(tn) ;  
                            expecting = "comma or colon";}
      )*
    |  
      tn = QuantBound() { addHeir(tn) ;  
                          expecting = "comma or colon";}
      ( t = <COMMA> { addHeir( new SyntaxTreeNode(mn, t) ); 
                      expecting = "identifier or tuple of identifiers";}
        tn = QuantBound() { addHeir(tn) ;  
                            expecting = "comma or colon";}
      )*
    )
    t = <COLON> { addHeir( new SyntaxTreeNode(mn, t) );  
                  expecting = "expression";}
    tn = Expression() { addHeir(tn) ; }
    { SyntaxTreeNode sn[] = getLastHeirs();
      epa();
      return new SyntaxTreeNode(mn, N_PickStep, sn );
    }
}

SyntaxTreeNode
CaseStep() : {
/***************************************************************************
* Returns an N_CaseStep node whose heirs are a <CASE> token and an         *
* expression node.                                                         *
***************************************************************************/
 Token t = null;
 SyntaxTreeNode tn = null;
 bpa("CaseStep") ;
}{ t = <CASE> { addHeir(new SyntaxTreeNode(mn, t)); 
                  expecting = "expression";}
    tn = Expression()  

    { addHeir(tn) ;    
      SyntaxTreeNode sn[] = getLastHeirs();
      epa();
      return new SyntaxTreeNode(mn, N_CaseStep, sn );
    }
}

SyntaxTreeNode
AssertStep() : {
/***************************************************************************
* Returns an N_AssertStep node whose heirs are an optional <SUFFICES>      *
* token and an expression or N_AssumeProve node.                           *
***************************************************************************/
 Token t = null;
 SyntaxTreeNode tn = null;
 bpa("AssertStep") ;
}{ (t = <SUFFICES> { addHeir(new SyntaxTreeNode(mn, t)); 
                    expecting = "expression or ASSUME/PROVE";}
    ) ? 
    (  tn = Expression() 
     | 
       LOOKAHEAD({getToken(1).kind == ASSUME}) 
       tn = AssumeProve()
    )
    { addHeir(tn) ;    
      SyntaxTreeNode sn[] = getLastHeirs();
      epa();
      return new SyntaxTreeNode(mn, N_AssertStep, sn );
    }
}

// SyntaxTreeNode
// NumerableStep() : {
// /***************************************************************************
// * Returns an N_NumerableStep node, which has the syntax                    *
// *                                                                          *
// *  ( <ProofStep[Dot]Lexeme> (N_NonExprBody node)                           *
// *   | N_NonExprBody node )                                                 *
// *  ( N_Proof node | N_TerminalProof node)?                                 *
// ***************************************************************************/
//  Token t = null;
//  SyntaxTreeNode tn = null;
//  boolean mayHaveProof = true ;
//  bpa("NumerableStep") ;
//  }{( LOOKAHEAD(2)
//      (t = <ProofStepLexeme> | t = <ProofStepDotLexeme>)
//      { tn = new SyntaxTreeNode(mn, t) ;
//        addHeir(tn); 
//        if ((proofDepth > 0) && (proofLevelStack[proofDepth-1] == -1)){
//          throw new ParseException(tn.getLocation() + 
//                     ": numbered step inside unnumbered proof.");
//         } ;
//        if (!correctLevel(t)) {
//          throw new ParseException(tn.getLocation() + 
//                     ": step number has incorrect level.");
//         } ;
//       }
//      ( (t = <CASE> {addHeir(new SyntaxTreeNode(mn, t)); })?          // XXXX
// //     ^^^^^^^^^^^
// // javacc generates the following warning here:
// //   Choice conflict in [...] construct at line 2700, column 8.
// //   Expansion nested within construct and expansion following construct
// //   have common prefixes, one of which is: "CASE"
// //   Consider using a lookahead of 2 or more for nested expansion.
// //
// // This conflict is between "<1>2.  CASE expr" and 
// // "<1>2.  CASE p -> ...".  This is an inherent ambiguity that arises
// // from the use of "CASE" as a keyword here.  Javacc resolves
// // conflicts by choosing the first successful match.  Here, this
// // means that "<1>2.  CASE p -> ..." is parsed as
// //
// //      <ProofStepDotLexeme> <CASE> Expression()
// //
// // causing an error when it tries to parse "-> ..." as an expression.
// 
// 
// 
//        tn = Expression() {addHeir(tn);                               // XXXX
//                           mayHaveProof = true ;}   // XXXX
//       |                                                              // XXXX
//         tn = NonExprBody() {addHeir(tn);
//                             mayHaveProof = nonExprBodyMayHaveProof;}
//       )                                                              // XXXX
//    | t = <CASE> {addHeir(new SyntaxTreeNode(mn, t)); }             // XXXX
//      tn = Expression() {addHeir(tn);                               // XXXX
//                         mayHaveProof = nonExprBodyMayHaveProof;} // XXXX
// 
//    | tn = NonExprBody() 
//        { addHeir(tn); 
//          mayHaveProof = nonExprBodyMayHaveProof;
//          if (getProofLevel() == -2)
//            { setProofLevel(-1) ;
//           }
//          else {
//           if (getProofLevel() != -1) {
//          throw new ParseException(tn.getLocation() + 
//                     ": Unnumbered step in numbered proof.");
//             }
//           }
//       }
//   )
//   ( LOOKAHEAD( {mayHaveProof && beginsProof(getToken(1))} )
//      tn = Proof() 
//      { addHeir(tn) ; }
//   )?
//   { SyntaxTreeNode sn[] = getLastHeirs();
//     epa(); 
//     return new SyntaxTreeNode(mn, N_NumerableStep, sn);
//   }
// }

// /***************************************************************************
// * Hack: In addition to returning a node, NonExprBody() needs to return a   *
// * boolean saying whether or not the statement it is returning can have a   *
// * proof.  It does this by setting the field nonExprBodyMayHaveProof.       *
// ***************************************************************************/
// SyntaxTreeNode
// NonExprBody() : {
//  SyntaxTreeNode tn = null;
//  Token t = null;
//  nonExprBodyMayHaveProof = false ;
//  bpa("NonExprBody") ;
// }{ (  LOOKAHEAD(2)
//       (t = <SUFFICES>    { addHeir(new SyntaxTreeNode(mn, t)); }) ? 
//       tn = AssumeProve() { addHeir(tn) ; 
//                            nonExprBodyMayHaveProof = true;}
//     | LOOKAHEAD(2)
//       ( t = <PROVE> | t = <SUFFICES>)   // | t = <PROOFCASE>
//       { addHeir(new SyntaxTreeNode(mn, t));  
//         expecting = "expression";}
//       tn = Expression() { addHeir(tn) ; 
//                           nonExprBodyMayHaveProof = true;}
//     | t = <HAVE> { addHeir(new SyntaxTreeNode(mn, t)) ;   
//                    expecting = "expression";}
//       tn = Expression() { addHeir(tn) ; }
//     | t = <TAKE> { addHeir(new SyntaxTreeNode(mn, t)) ;    
//                    expecting = "identifier";}
//       ( LOOKAHEAD (  <IDENTIFIER> (<COMMA> <IDENTIFIER>)* <IN>
//                    | <LAB>) 
//         tn = QuantBound() { addHeir(tn) ;  
//                             expecting = "comma or step";}
//         ( t = <COMMA> { addHeir( new SyntaxTreeNode(mn, t) ); 
//                         expecting = "identifier or tuple of identifiers";}
//           tn = QuantBound() { addHeir(tn) ;  
//                               expecting = "comma or proof step";}
//         )*
//       |  
//         tn = Identifier() { addHeir(tn) ; 
//                              expecting = "comma or proof step";}
//          ( t = <COMMA> { addHeir( new SyntaxTreeNode(mn, t) ); 
//                           expecting = "identifier";}
//            tn = Identifier() { addHeir(tn) ;  
//                                expecting = "comma or proof step";}
//          )*
//       )
// 
//     | t = <WITNESS> { addHeir(new SyntaxTreeNode(mn, t)) ;     
//                       expecting = "expression";}
//       tn = Expression() { addHeir(tn) ; }
//       /*********************************************************************
//       * Note: The semantic phase must determine if this is expr \in expr,  *
//       * or <<expr, ...  , expr>> \in expr, or just expr.                   *
//       *********************************************************************/
//       ( t = <COMMA> { addHeir( new SyntaxTreeNode(mn, t) ); 
//                         expecting = "expression";}
//         tn = Expression() { addHeir(tn) ;  
//                             expecting = "comma or colon";}
//       )*
//       
//     | t = <PICK> { addHeir(new SyntaxTreeNode(mn, t)) ;  
//                    expecting = "identifier";}
//       ( LOOKAHEAD ( <IDENTIFIER> ( <COMMA> <IDENTIFIER> )* <COLON> ) 
//                           /* CommaList Identifier */
//         tn = Identifier() { addHeir(tn) ; 
//                              expecting = "comma, or colon";}
//          ( t = <COMMA> { addHeir( new SyntaxTreeNode(mn, t) ); 
//                           expecting = "identifier";}
//            tn = Identifier() { addHeir(tn) ;  
//                                expecting = "comma or colon";}
//          )*
//       |  
//         tn = QuantBound() { addHeir(tn) ;  
//                             expecting = "comma or colon";}
//         ( t = <COMMA> { addHeir( new SyntaxTreeNode(mn, t) ); 
//                         expecting = "identifier or tuple of identifiers";}
//           tn = QuantBound() { addHeir(tn) ;  
//                               expecting = "comma or colon";}
//         )*
//        )
//        t = <COLON> { addHeir( new SyntaxTreeNode(mn, t) );  
//                      expecting = "expression";}
//        tn = Expression() { addHeir(tn) ; }
//        { nonExprBodyMayHaveProof = true;}
//    )
//   { SyntaxTreeNode sn[] = getLastHeirs();
//     epa(); 
//     return new SyntaxTreeNode(mn, N_NonExprBody, sn);
//   }
// }



/***************************************************************************
* The GeneralId() production is not used and can be deleted.  The parser   *
* uses Java code to construct N_GeneralId nodes inside Extension(),        *
* NoOpExtension(), and BraceCases()                                        *
***************************************************************************/
SyntaxTreeNode
GeneralId() : {
  SyntaxTreeNode zn[] = new SyntaxTreeNode[2];
  Token t;
  bpa("General ID");
}{
  zn[0] = IdPrefix()
  zn[1] = Identifier()
  { epa(); return new SyntaxTreeNode( mn, N_GeneralId, zn); }
}

SyntaxTreeNode
IdPrefix() : {
  SyntaxTreeNode tn;
  bpa("ID Prefix");
}{
  ( LOOKAHEAD( IdPrefixElement() )
    tn = IdPrefixElement(){ addHeir( tn ); } )*
  { SyntaxTreeNode sn[] = getLastHeirs();
    epa(); return new SyntaxTreeNode(mn, N_Proof, sn ); }
}

SyntaxTreeNode
IdPrefixElement() : {
  SyntaxTreeNode tn;
  Token t;
  bpa("ID Prefix Element");
}{
  tn = Identifier() { addHeir( tn ); }
  [ tn = OpArgs(){ addHeir( tn ); } ]
  t = <BANG> { addHeir( new SyntaxTreeNode(mn, t) ); }
  { SyntaxTreeNode sn[] = getLastHeirs();
    epa(); return  new SyntaxTreeNode(mn, N_IdPrefixElement, sn); }
}

SyntaxTreeNode
ParenthesesExpression() : {
  SyntaxTreeNode tn;
//  BStack.newReference(0, LBR);
} {
  ( tn = ParenExpr() | tn = BraceCases() | tn = SBracketCases()
  | tn = SetExcept() | tn = TupleOrAction()  | tn = FairnessExpr() 
)
  {  return tn; } // BStack.popReference();
}

SyntaxTreeNode
ClosedExpressionOrOp() : {
  SyntaxTreeNode tn;
  Token t;
} {
  ( tn = ElementaryExpression() | tn = ParenthesesExpression() )
  { return tn; }
}

/***************************************************************************
* The following does not seem to be used anywhere.                         *
***************************************************************************/
SyntaxTreeNode
ClosedExpressionOnly() : {
  SyntaxTreeNode tn;
} {
  tn = ClosedExpressionOrOp()
  { if ( isGenOp( tn ) ) throw new ParseException( "Encountered unexpected Operator" );
    else return tn;
  }
}

SyntaxTreeNode
OpenExpression() : {
  SyntaxTreeNode tn;
} {
  ( tn = SomeQuant() | tn = SomeTQuant() | tn = IfThenElse()
  | tn = Case() | tn = LetIn() | tn = UnboundOrBoundChoose() )
  { return tn; }
}

/*
  L.GeneralId, L.OpApplication, L.String, L.Number, L.GenOp...
*/
SyntaxTreeNode
ElementaryExpression() : {
  SyntaxTreeNode tn;
  Token t;
  bpa("Elementary expression");
} {
  ( tn = Extension() /* may return GeneralId, GenOp.. or OpApplication */
  | tn = String() { epa(); }
  | tn = Number() { epa(); }
  )
  { return tn; }
}

SyntaxTreeNode
String() : {
  SyntaxTreeNode tn;
  Token t;
  bpa("String");
} {
  t = <STRING_LITERAL> {
    tn = new SyntaxTreeNode( mn, N_String, t);
    tn.image = reduceString( tn.image.toString() );
    epa();
    return tn;
  }
}

SyntaxTreeNode
Number() : {
  SyntaxTreeNode tn, sn[] = null;
  Token t1, t2;
  int kind = N_Number;
} {
  t1 = <NUMBER_LITERAL> 
  [ LOOKAHEAD(2) t2 = <DOT> {
     kind = N_Real;
     decimalFlag = true;
     sn = new SyntaxTreeNode[3];
     sn[0] = new SyntaxTreeNode(mn, t1);
     sn[1] = new SyntaxTreeNode(mn, t2); }
    t1 = <NUMBER_LITERAL> {
     sn[2] = new SyntaxTreeNode(mn,t1); } ]
  { if (sn == null) {
      numberFlag = true;
      sn = new SyntaxTreeNode[1];
      sn[0] =  new SyntaxTreeNode(mn, t1);
      kind = N_Number;
    }
    return new SyntaxTreeNode(mn, kind, sn); }
}

SyntaxTreeNode
Extension() : {
  SyntaxTreeNode last = null, tid, top = null;
  Token t = null;
  SyntaxTreeNode heirs[];
} {
  (//  LOOKAHEAD( { isPrefixOp( getToken(1) )  } )
      top = PrefixOp() {
        heirs = new SyntaxTreeNode[2];
        heirs[0] = new SyntaxTreeNode( mn, N_IdPrefix, getLastHeirs() );
        heirs[1] = top;
        last = new SyntaxTreeNode( mn, N_GenPrefixOp, heirs );
        epa();
      }
  |// LOOKAHEAD( { isInfixOp( getToken(1) )  } )
      top = InfixOp() {
        heirs = new SyntaxTreeNode[2];
        heirs[0] = new SyntaxTreeNode( mn, N_IdPrefix, getLastHeirs() );
        heirs[1] = top;
        last =  new SyntaxTreeNode( mn, N_GenInfixOp, heirs );
        epa();
      }
  |// LOOKAHEAD( { isPostfixOp( getToken(1) )  } )
      top = PostfixOp() {
        heirs = new SyntaxTreeNode[2];
        heirs[0] = new SyntaxTreeNode( mn, N_IdPrefix, getLastHeirs() );
        heirs[1] = top;
        last =  new SyntaxTreeNode( mn, N_GenPostfixOp, heirs );
        epa();
      }
  | tid = Identifier()
    [ top = OpArgs() ]
// ^^^  
// Warning 1  -- Eliminated in SANY2
    [ t = <BANG> {
        if ( top == null ) {
          heirs = new SyntaxTreeNode[2];
          heirs[1] = new SyntaxTreeNode( mn, t );
        } else {
          heirs = new SyntaxTreeNode[3];
          heirs[1] = top;
          heirs[2] = new SyntaxTreeNode(mn, t );
        }
        heirs[0] = tid;
        SyntaxTreeNode current = new SyntaxTreeNode( mn, N_IdPrefixElement, heirs );
        addHeir( current );
      }
      last = Extension() ]
    { if ( last == null ) {
         if ( top == null ) {
           heirs = new SyntaxTreeNode[2];
           heirs[0] = new SyntaxTreeNode( mn, N_IdPrefix, getLastHeirs() );
           heirs[1] = tid;
           last = new SyntaxTreeNode( mn, N_GeneralId, heirs );
         } else {
/* XXX Wrong.
           addHeir( tid );
           tid = new SyntaxTreeNode( mn, N_GeneralId, getLastHeirs() );
*/
           heirs = new SyntaxTreeNode[2];
           heirs[0] = new SyntaxTreeNode( mn, N_IdPrefix, getLastHeirs() );
           heirs[1] = tid;
           tid = new SyntaxTreeNode( mn, N_GeneralId, heirs );

           heirs = new SyntaxTreeNode[2];
           heirs[0] = tid;
           heirs[1] = top;
           last = new SyntaxTreeNode( mn, N_OpApplication, heirs );
         }
         epa();
      }
    }
  )
  { return last; }
}

SyntaxTreeNode
OpArgs() : {          // OpSuite contributes to Heir list.
  SyntaxTreeNode tn;
  Token t;
  bpa("Optional Arguments");
} {
  t = <LBR>  { addHeir( new SyntaxTreeNode(mn, t) ); }
  OpSuite( )
  ( t = <COMMA> { addHeir( new SyntaxTreeNode(mn, t) ); }
    OpSuite( )
  )*
  t = <RBR>  { addHeir( new SyntaxTreeNode(mn, t) ); }
  { SyntaxTreeNode sn[] = getLastHeirs();
    epa(); return new SyntaxTreeNode(mn, N_OpArgs, sn); }
}

/***************************************************************************
* OpOrExpr ::=    (NonExpPrefixOp | InfixOp | PostfixOp)                   *
*                   followed by                                            *
*                     "," | ")" | <DEFBREAK> | "LOCAL" | "INSTANCE" |      *
*                     "THEOREM" | "ASSUME" | "ASSUMPTION" |                *
*                     "CONSTANT" | "VARIABLE" | "RECURSIVE" |              *
*                    <END_MODULE> | <SEPARATOR> | <BEGIN_MODULE>           *
*               | Lambda                                                   *
*               | Expression                                               *
*                                                                          *
* This production is called where either an operator or an expression is   *
* expected--which is either as the argument of an operator or in a         *
* substitution.  For an expression or an operator argument that's a        *
* LAMBDA expression, there's no problem.  However, something like Foo!Bar  *
* could be either an expression or an operator.  In TLA+2, something like  *
* Foo!+!Bar could only be an operator, while something like                *
* Foo!+(a,b)!Bar could only be an expression.  However, in order to        *
* minimize the changes from the TLA+1 parser, we represent both Foo!+!Bar  *
* and Foo!+(a,b)!Bar as a GeneralId node and leave it to the semantic      *
* processing to sort things out.  Thus, Foo!+(a,b)!Bar produces the        *
* folowing tree of SyntaxTreeNode objects:                                 *
*                                                                          *
*    N_GeneralId                                                           *
*    _.N_IdPrefix                                                          *
*    _._.N_IdPrefixElement                                                 *
*    _._._.IDENTIFIER "Foo"                                                *
*    _._._.BANG "!"                                                        *
*    _._.N_IdPrefixElement                                                 *
*    _._._.N_InfixOp  +                                                    *
*    _._._.N_OpArgs                                                        *
*    _._._._.LBR "("                                                       *
*    _._._._.whatever a produces                                           *
*    _._._._.COMMA ","                                                     *
*    _._._._.whatever b produces                                           *
*    _._._._.RBR ")"                                                       *
*    _._._.BANG "!"                                                        *
*    _.IDENTIFIER "Bar"                                                    *
*                                                                          *
* Something like Foo!+(a,b)!Bar(x) producs an N_OpApplication node         *
* whose first child is the N_GeneralId node above and whose second         *
* child is an N_OpArgs node.                                               *
*                                                                          *
* TLA+2 adds labels and structural operators like "<<" to this kind of     *
* operator or expression.  A label in such an expression looks just like   *
* an ordinary identifier.  A structural operator is represented by a       *
* token with the new kind "N_StructOp".  Such a node is created by         *
*                                                                          *
*   new SynaxTreeNode(moduleName, N_StructOp, node)                        *
*                                                                          *
* where node is created by either                                          *
*                                                                          *
*   new SyntaxTreeNode(moduleName, tok)                                    *
*                                                                          *
* where tok is "<<", ">>", "@", or ":", or by                              *
*                                                                          *
*    new SynaxTreeNode(moduleName, N_Number, ...)                          *
*                                                                          *
* for a <NUMBER_LITERAL> token.                                            *
*                                                                          *
* Let OpArgs = (arg_1, ...  , arg_k).  In general, there are three         *
* interesting classes of expressions of the form e_1!e_2!...!e_n.          *
*                                                                          *
* Case 1: e_n = tok OpArgs,                                                *
*           where tok is an Identifier or an In/Pre/PostfixOp.             *
*   In this case an OpApplication node is produced with two children:      *
*   - An N_GeneralId node with children                                    *
*      - An N_IdPrefixNode with n-1 children consisting N_IdPRefixElement  *
*        nodes for e_1!, ... , e_n-1!.                                     *
*      - A node of kind IDENTIFIER, N_PrefixOp, etc. for tok               *
*   - An N_OpArgs nodes obtained from OpArgs                               *
*                                                                          *
* Case 2: e_n = tok                                                        *
*           where tok is an Identifier or an In/Pre/PostfixOp.             *
*   In this case, it produces just the N_GeneralId node of Case 1          *
*                                                                          *
* Case 3: e_n = OpArgs                                                     *
*   In this case, a GeneralId node is produced with two children:          *
*    - The N_IdPrefixNode node produced in cases 1 and 2                   *
*    - An N_OpArgs node for OpArgs.                                        *
***************************************************************************/
SyntaxTreeNode
OpOrExpr() : {
  /*************************************************************************
  * Used for parsing an operator argument or the right-hand side of a      *
  * substitution, which could be either an operator (like +) or an         *
  * expression (like a+b).                                                 *
  *************************************************************************/
SyntaxTreeNode tn; 
int kind ;
}{
( LOOKAHEAD(2, (NEPrefixOpToken() | InfixOpToken() | PostfixOpToken())
            (<COMMA> | <RBR> | <DEFBREAK> | <LOCAL> | <INSTANCE> | 
              <THEOREM> | <ASSUME> | <END_MODULE> | <SEPARATOR> | <_BM0>
              | <ASSUMPTION> | <CONSTANT> | <VARIABLE> | <RECURSIVE> ),
             {   BStack.aboveReference( getToken(1).beginColumn)
             } )           
  (   tn = NonExpPrefixOp() {kind = N_GenNonExpPrefixOp;}
    | tn = InfixOp()        
        {kind = N_GenInfixOp;
         if (   (tn.image == UniqueString.uniqueStringOf("\\X"))
             || (tn.image == UniqueString.uniqueStringOf("\\times"))){
            throw new ParseException(
                        tn.getLocation().toString() + 
                        ": \\X may not be used as an infix operator.");
           };
        }
    | tn = PostfixOp()      {kind = N_GenPostfixOp;}
  )
  { SyntaxTreeNode heirs[] = new SyntaxTreeNode[2];
    heirs[0] = new SyntaxTreeNode( mn, N_IdPrefix, ( SyntaxTreeNode []) null );
    heirs[1] = tn;
    tn = new SyntaxTreeNode(mn, kind, heirs); }
| LOOKAHEAD( <LAMBDA>,  {BStack.aboveReference( getToken(1).beginColumn)} )
    /***********************************************************************
    * Need the BStack.aboveReference check to make sure that the LAMBDA    *
    * is properly indented with respect to any enclosing dis/conjunction   *
    * list.  However, without the <LAMBDA>, the lookahead would succeed    *
    * and the next production would be executed even if it shouldn't       *
    * match.                                                               *
    ***********************************************************************/
  tn = Lambda() 
|
  tn = Expression() 
)
{return tn;}
}

void /* nodes are linked internally here : no value returned */
OpSuite() : {
SyntaxTreeNode tn; 
}{ tn = OpOrExpr() {addHeir(tn);}
} // OpSuite


// void /* nodes are linked internally here : no value returned */
// oldOpSuite() : {
//   SyntaxTreeNode tn = null;
//   anchor = null;
//     /***********************************************************************
//     * See the comments for the declaration of anchor to see what this is   *
//     * being used for.                                                      *
//     ***********************************************************************/
//   Token t;
// } {
//   ( /***********************************************************************
//     * This handles the operator argument "-." (token op_76)                *
//     ***********************************************************************/
// // XXXXX -- this won't work with the new expression syntax.
//     t = <op_76> {
//     tn = new SyntaxTreeNode(mn, N_NonExpPrefixOp, t); 
//     SyntaxTreeNode heirs[] = new SyntaxTreeNode[2];
//     heirs[0] = new SyntaxTreeNode( mn, N_IdPrefix, ( SyntaxTreeNode []) null );
//     heirs[1] = tn;
//     tn = new SyntaxTreeNode( mn, N_GenNonExpPrefixOp, heirs ); }
//   | LOOKAHEAD( (<AND> | <OR>) (<COMMA>|<RBR>) )
//       tn = InfixOp() {
//         heirs = new SyntaxTreeNode[2];
//         heirs[0] = new SyntaxTreeNode( mn, N_IdPrefix, (SyntaxTreeNode []) null );
//         heirs[1] = tn;
//         tn =  new SyntaxTreeNode( mn, N_GenInfixOp, heirs );
//      }
//   | tn = Lambda() 
//   | try {
//       tn = Expression()
//     } catch ( ParseException e ) {
// // ToolIO.out.println("Caught exception (bis)");
// // first things first - restore evaluation stack
//     if ( OperatorStack.isWellReduced() )
//       OperatorStack.popStack();
//     else
//       throw e;
//     /* it wasn't an expression, what was it ? */
//     /* check the nature of the node returned. It can only be a prefixed op. */
//     if ( ( anchor != null )
//        &&(    anchor.isKind( N_GenPrefixOp ) 
//            || anchor.isKind( N_GenInfixOp ) 
//            || anchor.isKind( N_GenPostfixOp ) ) ) {tn = anchor; anchor = null;
//       } else {
// // ToolIO.out.println("anchor is " + anchor.toString());
//        throw e;
//       } // end else
//     } // end catch.
// )
//     /* it wasn't an expression, what was it ?  L.GenNonExpPrefixOp | L.GenInfixOp | L.GenPostfixOp */
//     /* check the nature of the node returned . Below Expression, it has to be a prefixed op. */
//   { addHeir( tn ); }
// }

SyntaxTreeNode
ParenExpr() : {
  SyntaxTreeNode zn[] = new SyntaxTreeNode[3];
  SyntaxTreeNode tn;
  Token t;
} {
  t = <LBR>  { zn[0] = new SyntaxTreeNode(mn, t); }
  zn[1] = Expression()
  t = <RBR>  { zn[2] = new SyntaxTreeNode(mn, t); }
  { return new SyntaxTreeNode(mn, N_ParenExpr, zn ); }
}

SyntaxTreeNode /* for BoundQuant and parts of UnboundQuant */
SomeQuant() : {
  SyntaxTreeNode tn;
  Token t;
  bpa("Quantified form");
  int kind;
    /***********************************************************************
    * Set to N_UnboundQuant or N_BoundQuant                                *
    ***********************************************************************/
} { 
  ( t = <EXISTS> | t = <FORALL> ) { addHeir( new SyntaxTreeNode(mn, t)); }
  ( LOOKAHEAD ( <IDENTIFIER> ( <COMMA> <IDENTIFIER> )* <COLON> ) 
                          /* CommaList Identifier */
    ( tn = Identifier() {
      kind = N_UnboundQuant;
      addHeir( tn ); }
      ( t = <COMMA> { addHeir( new SyntaxTreeNode(mn, t) ); }
        tn = Identifier() {
        addHeir( tn ); } )*
    )
  | tn = QuantBound() {
      kind = N_BoundQuant;
      addHeir( tn );}
    ( t = <COMMA> { addHeir( new SyntaxTreeNode(mn, t) ); }
      tn = QuantBound() { addHeir( tn ); } )*
  ) 
  t = <COLON>  { addHeir( new SyntaxTreeNode(mn, t) ); }
  tn = Expression() { addHeir( tn ); }
  { SyntaxTreeNode sn[] = getLastHeirs();
    epa(); return new SyntaxTreeNode(mn, kind, sn); }
}

SyntaxTreeNode /* the rest of UnboundQuant */
SomeTQuant() : {
  SyntaxTreeNode tn;
  Token t;
  bpa("Bound Quantified Expression");
} {
  ( t = <T_EXISTS> | t = <T_FORALL> ) { addHeir( new SyntaxTreeNode(mn, t) ); }
  tn = Identifier() {
    addHeir( tn ); }
  ( t = <COMMA> { addHeir( new SyntaxTreeNode(mn, t) ); }
    tn = Identifier() {
      addHeir( tn ); } )*
  t = <COLON>  { addHeir( new SyntaxTreeNode(mn, t) ); }
  tn = Expression() { addHeir( tn );
    SyntaxTreeNode sn[] = getLastHeirs();
    epa(); return new SyntaxTreeNode(mn, N_UnboundQuant, sn); }
}

SyntaxTreeNode
QuantBound() : {
  SyntaxTreeNode tn;
  Token t;
  bpa("Quant Bound");
} {
  ( tn = IdentifierTuple() {
      addHeir( tn ); }
  | tn = Identifier() {
      addHeir( tn ); }
      (
        t = <COMMA> { addHeir( new SyntaxTreeNode(mn, t) ); }
        tn = Identifier() {
          addHeir( tn );
          expecting = ", or \\in"; }
      )*
  )
  t = <IN> {
    tn =  new SyntaxTreeNode(mn, t);
    tn.setKind(T_IN);
    addHeir(tn); }
  tn = Expression() { addHeir( tn );
    SyntaxTreeNode sn[] = getLastHeirs();
    epa(); return new SyntaxTreeNode(mn, N_QuantBound, sn); }
}

SyntaxTreeNode /* SetEnumerate, SubsetOf, SetOfAll, */
BraceCases() : {
  int kind = N_SetEnumerate; // set by default.
  SyntaxTreeNode tn, tn_0, tn_1, tn_2, htn = null;
  Token t;
  boolean te = false;
    /***********************************************************************
    * The value of te is set in a couple of places, but it is never        *
    * read.  J-Ch hopes it's obsolete.                                     *
    ***********************************************************************/
  bpa("Some { } form");
} {
  t = <LBC>  { addHeir( new SyntaxTreeNode(mn, t) ); }
  [ LOOKAHEAD({ matchFcnConst() }) 
    ( tn = IdentifierTuple() | tn = Identifier() ) {
      tn_0 = tn;
      expecting = "\\in"; }
// At this stage, we need to break since it maybe a MaybeBound or
// a SubsetOf
// So we'll hold to the pieces in the meantime.
    t = <IN> {
      tn_1 =  new SyntaxTreeNode(mn, t);
      tn_1.setKind(T_IN);
        /*******************************************************************
        * Changed from tn.setKind(T_IN) by LL on 19 Mar 2007.              *
        *                                                                  *
        * Appears to fix bug that caused semantic error on something like  *
        * {<<m, n>> \in Nat \X Nat : m > 0}.                               *
        *******************************************************************/

//      addHeir(tn);
    }
    tn_2 = Expression() {
//      addHeir( tn );
// need to create a node for a N_InfixExpr. Some reassembly required, but if course it may be for naught.
// This is in case it isn't a N_SubsetOf
      expecting = "':', ',' or '}'";
      SyntaxTreeNode zn[] = new SyntaxTreeNode[3];
      SyntaxTreeNode wn[]= new SyntaxTreeNode[2];
      wn[0] = new SyntaxTreeNode(mn, N_IdPrefix, new SyntaxTreeNode[0]);
      wn[1] = tn_0;
      zn[0] = new SyntaxTreeNode(mn, N_GeneralId, wn);
      wn = new SyntaxTreeNode[2];
      wn[0] = new SyntaxTreeNode(mn, N_IdPrefix, new SyntaxTreeNode[0]);
      wn[1] = tn_1;
      zn[1] = new SyntaxTreeNode(mn, N_GenInfixOp, wn);
      zn[2] = tn_2;
      htn = new SyntaxTreeNode( mn, N_InfixExpr, zn);
    }
    [ ( t = <COLON>  {
      htn = null; // it was for naught, ignore it later.
      addHeir(tn_0); // ID
      addHeir(tn_1); // \\in
      addHeir(tn_2); // expression
      addHeir( new SyntaxTreeNode(mn, t) );
      kind = N_SubsetOf;
      }
      tn = Expression() { addHeir( tn ); } )
    | ( t = <COMMA> {
        if (htn != null) {
          addHeir( htn); htn = null;
        }
        addHeir( new SyntaxTreeNode(mn, t) ); }
        tn = Expression() { addHeir( tn ); }
      )+
    ]
  | LOOKAHEAD( ( IdentifierTuple() | <IDENTIFIER>) <COMMA> )
    tn = Expression() {
      kind = N_SetEnumerate;
      addHeir( tn );}
    ( t = <COMMA>  { addHeir( new SyntaxTreeNode(mn, t) ); }
        tn = Expression() { addHeir( tn ); }
    )*
  | LOOKAHEAD( ( IdentifierTuple() | <IDENTIFIER>) <COLON> )
    { te = true; kind = N_SetOfAll; }
    tn = Expression() {
      addHeir( tn ); }
    t = <COLON>  { addHeir( new SyntaxTreeNode(mn, t) ); }
    tn = QuantBound() { addHeir( tn );}
    ( t = <COMMA> { addHeir( new SyntaxTreeNode(mn, t) ); }
      tn = QuantBound() { addHeir( tn ); } )*
  | tn = Expression() { addHeir( tn ); }
    [ t = <COLON>  {
        te = true; kind = N_SetOfAll; 
// IF tn is infix expression, with operator IN, we have a pbm for throw new ParseException( "Form {a \in b : c \in d } is forbidden" );

        /*******************************************************************
        * The following code causes an incorrect error on the legal        *
        * expression {1 \in x : x \in T}.  It seems to me that this        *
        * test should simply be eliminated.  It seems to be based on the   *
        * mistaken belief that {x \in S : x \in T} is illegal, when it's   *
        * actually an expression of type N_SubsetOf.                       *
        *******************************************************************/
        SyntaxTreeNode Hone[] = (SyntaxTreeNode[])tn.heirs();
	if (Hone.length>1) { // better make sure it's long enough.
          Hone = (SyntaxTreeNode[])Hone[1].heirs(); // second heir of second heir
          if ( tn.isKind( N_InfixExpr ) && Hone[1].getImage().equals("\\in") ) {
            throw new ParseException( "Form {a \\in b : c \\in d }, at line " + t.beginLine + ", is not allowed" );
	  }
        }
        addHeir( new SyntaxTreeNode(mn, t) );}
      tn = QuantBound() { addHeir( tn );}
      ( t = <COMMA> { addHeir( new SyntaxTreeNode(mn, t) ); }
      tn = QuantBound() { addHeir( tn ); } )*
    | ( t = <COMMA> { kind = N_SetEnumerate;
        addHeir( new SyntaxTreeNode(mn, t) ); }
        tn = Expression() { addHeir( tn ); } )+
    ]
  ]
  t = <RBC>  {
    if (htn!=null) addHeir(htn);
    addHeir( new SyntaxTreeNode(mn, t) );  
    SyntaxTreeNode sn[] = getLastHeirs();
    epa(); return new SyntaxTreeNode(mn, kind, sn); }
}

SyntaxTreeNode /* FcnConst, SetOfFcns, RcdConstructor, SetOfRcds, Except, ActionExpr - en partie */

/***************************************************************************
* Called when a "[" is encountered                                         *
***************************************************************************/
SBracketCases() : {
  SyntaxTreeNode tn;
  Token t;
  int kind = 0;
  bpa("Some [] Form");
} {
  t = <LSB>  { addHeir( new SyntaxTreeNode(mn, t) ); }
  ( LOOKAHEAD({ matchFcnConst() } ) // FcnConst - because we use OpSymbol rather than IN, we need to use semantic detection.
    tn = QuantBound() {
      kind = N_FcnConst;
      addHeir( tn ); }
    ( t = <COMMA> { addHeir( new SyntaxTreeNode(mn, t) ); }
      tn = QuantBound() { addHeir( tn ); } )*
    t = <MAPTO> { addHeir( new SyntaxTreeNode(mn, t) ); }
    tn = Expression() { addHeir( tn ); }
    t = <RSB> { addHeir( new SyntaxTreeNode(mn, t) ); }
  | LOOKAHEAD( <IDENTIFIER> <MAPTO> )  /* RcdConstructor */
    tn = FieldVal() {
      kind = N_RcdConstructor;
      addHeir( tn );}
    ( t = <COMMA> { addHeir( new SyntaxTreeNode(mn, t) ); }
      tn = FieldVal() { addHeir( tn ); } )*
    t = <RSB> { addHeir( new SyntaxTreeNode(mn, t) ); }
  | LOOKAHEAD( { (getToken(2).kind == MAPTO) && isFieldNameToken( getToken(1)) } )      /* RcdConstructor */
    { getToken(1).kind = IDENTIFIER; }
    tn = FieldVal() {
      kind = N_RcdConstructor;
      addHeir( tn );}
    ( t = <COMMA> { addHeir( new SyntaxTreeNode(mn, t) ); }
      tn = FieldVal() { addHeir( tn ); } )*
    t = <RSB> { addHeir( new SyntaxTreeNode(mn, t) ); }
  | LOOKAHEAD( <IDENTIFIER> <COLON> )      /* SetOfRcds */
    tn = FieldSet() {
      kind = N_SetOfRcds;
      addHeir( tn ); }
    ( t = <COMMA> { addHeir( new SyntaxTreeNode(mn, t) ); }
      tn = FieldSet() { addHeir( tn ); } )*
    t = <RSB> { addHeir( new SyntaxTreeNode(mn, t) ); }
  | tn = Expression() { addHeir( tn ); }
    ( ( t = <COMMA> { addHeir( new SyntaxTreeNode(mn, t) ); }
        tn = Expression() { addHeir( tn ); }
      )* 
      t = <RSB> { addHeir( new SyntaxTreeNode(mn, t) );
      kind = N_FcnAppl;
      lastOp = FcnOp; }
    | t = <ARROW> {                       // SetOfFcns
        kind = N_SetOfFcns;
        addHeir( new SyntaxTreeNode(mn, t) ); }
      tn = Expression() { addHeir( tn ); }
      t = <RSB> { addHeir( new SyntaxTreeNode(mn, t) ); }
    | t = <EXCEPT> {                       // Except
        kind = N_Except;
        addHeir( new SyntaxTreeNode(mn, t) ); }
      tn = ExceptSpec() { addHeir( tn ); }
      ( t = <COMMA> { addHeir( new SyntaxTreeNode(mn, t) ); }
        tn = ExceptSpec() { addHeir( tn ); } )*
      t = <RSB> { addHeir( new SyntaxTreeNode(mn, t) ); }
    | t = <ARSB>{
        kind = N_ActionExpr;
        addHeir( new SyntaxTreeNode(mn, t) ); }
      tn = ReducedExpression() { addHeir( tn ); }
    )
  )
  { SyntaxTreeNode sn[] = getLastHeirs();
    Assert.assertion(kind !=0);
    epa(); return new SyntaxTreeNode(mn, kind, sn); }
}

SyntaxTreeNode
FieldVal() : {
  SyntaxTreeNode zn[] = new SyntaxTreeNode[3];
  Token t;
  bpa("Field Value");
} {
  zn[0] = Identifier()
  t = <MAPTO> { zn[1] = new SyntaxTreeNode(mn, t); }
  zn[2] = Expression()
  { epa(); return new SyntaxTreeNode(mn, N_FieldVal, zn ); }
}

SyntaxTreeNode
FieldSet() : {
  SyntaxTreeNode zn[] = new SyntaxTreeNode[3];
  SyntaxTreeNode tn;
  Token t;
  bpa("Field Set");
} {
  zn[0] = Identifier()
  t = <COLON> { zn[1] = new SyntaxTreeNode(mn, t); }
  zn[2] = Expression()
  { epa(); return new SyntaxTreeNode( mn, N_FieldSet, zn ); }
}

SyntaxTreeNode
ExceptSpec() : {
  SyntaxTreeNode tn;
  Token t;
  bpa("Except Spec");
} {
  t = <BANG> { addHeir( new SyntaxTreeNode(mn, t) ); }
  (tn = ExceptComponent() {
    addHeir( tn );
    expecting = "= or ,"; }
  )+
  t = <EQUALS> {
    tn =  new SyntaxTreeNode(mn, t);
    tn.setKind(T_EQUAL);
    addHeir(tn); }
  tn = Expression() { addHeir( tn ); }
  { SyntaxTreeNode sn[] = getLastHeirs();
    epa(); return new SyntaxTreeNode( mn, N_ExceptSpec, sn ); }
}

SyntaxTreeNode
ExceptComponent () : {
  SyntaxTreeNode tn;
  Token t;
  bpa("Except Component");
} {
  ( t = <DOT> { addHeir( new SyntaxTreeNode(mn, t) ); 
                /***********************************************************
                * Following added by LL on 10 Oct 2007 to make something   *
                * like "!.THEN" work right.                                *
                ***********************************************************/
                Token next = getToken(1);
                if (isFieldNameToken( next )) next.kind = IDENTIFIER;
              }
    
    tn = Identifier() {
      if (tn.getUS().equals(At) ) {
        PErrors.push( new ParseError("@ used in !.@") );
      }
      addHeir( tn );
    }
  |
    t = <LSB> { addHeir( new SyntaxTreeNode(mn, t) ); }
    tn = Expression() { addHeir( tn ); }
    ( t = <COMMA> { addHeir( new SyntaxTreeNode(mn, t) ); }
      tn = Expression() { addHeir( tn ); } )*
    t = <RSB> { addHeir( new SyntaxTreeNode(mn, t) ); }
  )
  { SyntaxTreeNode sn[] = getLastHeirs(); epa();
    return new SyntaxTreeNode( mn, N_ExceptComponent, sn ); }
}

/***************************************************************************
* The SetExcept non-terminal was eliminated from the grammar, but not      *
* from the parser.                                                         *
***************************************************************************/
SyntaxTreeNode
SetExcept() : {
  SyntaxTreeNode tn;
  Token t;
  bpa("Set Except");
} {
  t = <LWB> { addHeir( new SyntaxTreeNode(mn, t) ); }
  tn = Expression() { addHeir( tn ); }
  t = <EXCEPT> { addHeir( new SyntaxTreeNode(mn, t) ); }
  tn = SExceptSpec() { addHeir( tn ); }
  ( t = <COMMA> { addHeir( new SyntaxTreeNode(mn, t) ); }
    tn = SExceptSpec() { addHeir( tn ); } )*
  t = <RWB> { addHeir( new SyntaxTreeNode(mn, t) ); }
  { SyntaxTreeNode sn[] = getLastHeirs();
    epa(); return new SyntaxTreeNode( mn, N_SetExcept, sn ); }
}

SyntaxTreeNode
SExceptSpec() : {
  SyntaxTreeNode zn[] = new SyntaxTreeNode[4];
  SyntaxTreeNode tn;
  Token t;
  bpa("Set Expect Spec");
} {
  t = <BANG> { zn[0] = new SyntaxTreeNode(mn, t); }
  zn[1] = ExceptComponent()
  { expecting = "= or \\in"; }
  ( t = <EQUALS> {
      zn[2] =  new SyntaxTreeNode(mn, t); zn[2].setKind( T_EQUAL ); }
  | t = <IN> {
      zn[2] =  new SyntaxTreeNode(mn, t); zn[2].setKind( T_IN ); } )
  zn[3] = Expression()  
  { epa(); return new SyntaxTreeNode( mn, N_SExceptSpec, zn ); }
}

SyntaxTreeNode
TupleOrAction() : {
  int kind = 0;
  SyntaxTreeNode tn;
  Token t;
  bpa("Some << -- >> or >>_ Form");
} {
  t = <LAB> { addHeir( new SyntaxTreeNode(mn, t) ); }
  [ tn = Expression() { addHeir( tn ); }
    ( t = <COMMA> { addHeir( new SyntaxTreeNode(mn, t) ); }
        tn = Expression() { addHeir( tn ); } )* ]
  (  t = <RAB> {
      kind = N_Tuple; addHeir( new SyntaxTreeNode(mn, t) );}
  | t = <ARAB> {
      kind = N_ActionExpr; addHeir( new SyntaxTreeNode(mn, t) ); }
    tn = ReducedExpression() { addHeir( tn ); }
  )
  { SyntaxTreeNode sn[] = getLastHeirs();
    epa(); return new SyntaxTreeNode( mn, kind, sn ); }
}

//  new SyntaxTreeNode( N_IdPrefix )  ???
SyntaxTreeNode 
NoOpExtension() : {
  SyntaxTreeNode tid, top, last;
  last = null; top = null;
  Token t = null;
} {
  ( tid = Identifier()
    [ LOOKAHEAD(2)
      top = OpArgs() ]
// ^^^
// Warning 2  Eliminated by LOOKAHEAD
    [ t = <BANG> {
        SyntaxTreeNode heirs[];
        if ( top == null ) {
          heirs = new SyntaxTreeNode[2];
          heirs[1] = new SyntaxTreeNode( mn, t );
        } else {
          heirs = new SyntaxTreeNode[3];
          heirs[1] = top;
          heirs[2] = new SyntaxTreeNode(mn, t );
        }
        heirs[0] = tid;
        SyntaxTreeNode current = new SyntaxTreeNode( mn, N_IdPrefixElement, heirs );
        addHeir( current );
      }
      last = NoOpExtension() ]

    { if ( last == null ) { // means no bang, bottom of recursion
         if ( top != null )
           FairnessHook = top;
         else
           FairnessHook = null;
         SyntaxTreeNode zn[] = new SyntaxTreeNode[2];
         zn[0] = new SyntaxTreeNode( mn, N_IdPrefix, getLastHeirs() );
         zn[1] = tid;
         last = new SyntaxTreeNode( mn, N_GeneralId, zn );
      }
    }
  )
  { return last; }
}

SyntaxTreeNode
ReducedExpression() : {
  /*************************************************************************
  * This is an expression that can follow "[...]_" or "<<...>>_".          *
  *************************************************************************/
  SyntaxTreeNode expr;
  bpa("restricted form of expression");
} {
 ( expr = NoOpExtension()
 | expr = ParenExpr()
 | expr = BraceCases()
 | expr = SBracketCases()
 | expr = SetExcept()
 | expr = TupleOrAction()
 ) { epa(); return expr; } 
}

// The following cases - for the first expression - must be recognized :
// "GeneralId", "OpApplication", "RecordComponent", "FcnAppl", "ParenExpr", "SetEnumerate", "SubsetOf", "SetOfAll", "FcnConst", "SetOfFcns", "RcdConstructor", "SetOfRcds", "Except", "Tuple", "ActionExpr"
// The cases break down in two categories: two set of () or a single one.
// in general, it's going to be some () [] or {} expression, or an Identifier foollowed by . () or [].
// Note that FcnAppl may be more intricate.

SyntaxTreeNode
FairnessExpr() : {
  SyntaxTreeNode zn[] = new SyntaxTreeNode[5];
  SyntaxTreeNode tn, expr;
  Token t;
  FairnessHook = null;
  bpa("Fairness Expression");
} {
  (t = <WF> | t = <SF>) { zn[0] = new SyntaxTreeNode(mn, t); }
  expr = ReducedExpression()
   [ LOOKAHEAD(2)
     t = <LBR> {
// ^^^  
// Warning 3 -- Eliminated by LOOKAHEAD
    zn[1] = expr; expr = null;
    zn[2] = new SyntaxTreeNode(mn, t); }
    zn[3] = Expression()
    t = <RBR> { zn[4] = new SyntaxTreeNode(mn, t); }
  ]
  { epa();
    if ( expr != null ) {  // no extra (), FairnessHook can't be null ** Add check.
      if (FairnessHook == null) {
        throw new ParseException("Ill-structured fairness expression at line " + zn[0].location[0] + ", column " + zn[0].location[1]);
      }

      SyntaxTreeNode parameters[] = (SyntaxTreeNode[]) FairnessHook.heirs();
      if ( parameters != null && parameters.length == 3) { // was FairnessHook
        zn[1] = expr;
        zn[2] = parameters[0];
        zn[3] = parameters[1];
        zn[4] = parameters[2];
      } else {
        PErrors.push( new ParseError("Error in fairness expression at " + zn[0].location[0] + ": " + zn[0].location[1] + "\n", "-- --") );
        return expr;
      }
// left for level checking.
//      if ( expr.isKind( N_ActionExpr ) ) {
//        PErrors.push( new ParseError("Error in fairness expression at " + zn[0].location[0] + ": " + zn[0].location[1] + ": use of an action form\n", "-- --") );
//        return expr;
//      }
    } else { // reattach FairnessHook ! unless it is tuple
// "GeneralId", "RecordComponent", "FcnAppl",
      if ( zn[1].isKind( N_GeneralId ) &&  FairnessHook != null ) {
        SyntaxTreeNode ozn[] = new SyntaxTreeNode[2];
        ozn[0] = zn[1];
        ozn[1] = FairnessHook;
        zn[1] = new SyntaxTreeNode( mn, N_OpApplication, ozn );
      } else if ( ! (zn[1].isKind( N_Tuple )|| zn[1].isKind( N_ParenExpr ) || zn[1].isKind( N_SetEnumerate )|| zn[1].isKind( N_SubsetOf )|| zn[1].isKind( N_SetOfAll )|| zn[1].isKind( N_SetOfFcns )|| zn[1].isKind( N_RcdConstructor )|| zn[1].isKind( N_SetOfRcds )|| zn[1].isKind( N_Except )|| zn[1].isKind( N_FcnConst )|| zn[1].isKind( N_ActionExpr )) ){
// "ParenExpr", "SetEnumerate", "SubsetOf", "SetOfAll", "FcnConst",
// "SetOfFcns", "RcdConstructor", "SetOfRcds", "Except",
// "Tuple", "ActionExpr"
        PErrors.push( new ParseError("Error in fairness expression at " + zn[0].location[0] + ": " + zn[0].location[1] + ": could not link arguments\n", "-- --") );
        return zn[1];
      }
    }
    return new SyntaxTreeNode( mn, N_FairnessExpr, zn );
  }
}

SyntaxTreeNode
IfThenElse() : {
  SyntaxTreeNode zn[] = new SyntaxTreeNode[6]; 
  Token t;
  bpa("IF THEN ELSE");
} {
  t =   <IF> { zn[0] = new SyntaxTreeNode(mn, t);}
               zn[1] =  Expression()
  t = <THEN> { zn[2] =  new SyntaxTreeNode(mn, t);}
               zn[3] =  Expression()
  t = <ELSE> { zn[4] =  new SyntaxTreeNode(mn, t);}
               zn[5] =  Expression()
  { epa(); return new SyntaxTreeNode(mn, N_IfThenElse, zn); }
}

SyntaxTreeNode
Case() : {
  SyntaxTreeNode tn;
  Token t;
  bpa("CASE Expression");
} {
  t = <CASE> { addHeir( new SyntaxTreeNode(mn, t) ); }
  tn = CaseArm() { addHeir( tn ); }
  ( LOOKAHEAD( { caseSep() && (getToken(2).kind != OTHER) } )
    t = <CASESEP> { addHeir( new SyntaxTreeNode(mn, t) ); }
    tn = CaseArm() { addHeir( tn ); } )*
  [ LOOKAHEAD( { caseSep() } )
    t = <CASESEP> { addHeir( new SyntaxTreeNode(mn, t) ); }
    tn = OtherArm() { addHeir( tn ); } ]
  { SyntaxTreeNode sn[] = getLastHeirs();
    epa(); return new SyntaxTreeNode(mn, N_Case, sn); }
}

SyntaxTreeNode
CaseArm() : {
  SyntaxTreeNode zn[] = new SyntaxTreeNode[3];
  Token t;
  bpa("Case Arm");
} {
  zn[0] = Expression()
  t = <ARROW> { zn[1] = new SyntaxTreeNode(mn, t); }
  zn[2] = Expression()
  { epa(); return new SyntaxTreeNode( mn, N_CaseArm, zn ); }
}

SyntaxTreeNode
OtherArm() : {
  SyntaxTreeNode zn[] = new SyntaxTreeNode[3];
  Token t;
  bpa("Case Other Arm");
} {
  t = <OTHER> { zn[0] = new SyntaxTreeNode(mn, t); }
  t = <ARROW> { zn[1] = new SyntaxTreeNode(mn, t); }
  zn[2] = Expression()
  { epa(); return new SyntaxTreeNode( mn, N_OtherArm, zn ); }
}

/***************************************************************************
* LetIn ::= <LET> LetDefinitions() <LETIN> Expression()                    *
*                                                                          *
* It produces a SyntaxTreeNode tn with the four heirs                      *
*    "LET", LetDefinitions, "IN", Expression                               *
* in tn.zero.                                                              *
***************************************************************************/
SyntaxTreeNode
LetIn() : {
  SyntaxTreeNode zn[] = new SyntaxTreeNode[4];
  SyntaxTreeNode tn;
  Token t;
  bpa("Case Other Arm");
} {
  t = <LET> { zn[0] = new SyntaxTreeNode(mn, t); }
  zn[1] = LetDefinitions()
  t = <LETIN> { zn[2] = new SyntaxTreeNode(mn, t); }
  zn[3] = Expression()
  { epa(); return new SyntaxTreeNode( mn, N_LetIn, zn ); }
}

SyntaxTreeNode
LetDefinitions() : {
  SyntaxTreeNode tn;
  Token t;
  bpa("Let Definitions");
} {
  (   tn = OperatorOrFunctionDefinition() { addHeir( tn ); } 
    | tn = Recursive() { addHeir( tn ); } 
  )+
  { SyntaxTreeNode sn[] = getLastHeirs();
    epa(); return new SyntaxTreeNode(mn, N_LetDefinitions, sn); }
}

SyntaxTreeNode
Junctions () : {
  BStack.newReference(getToken(1).endColumn, getToken(1).kind);
    /***********************************************************************
    * Pushes onto BStack an element of the appropriate kind with offest    *
    * equal to the column of the last character in the /\ or \/ token.     *
    ***********************************************************************/
    
  bpa("AND-OR Junction");
  int kind;
} { 
  ( LOOKAHEAD( /* <BOR> | */ <OR> ) { kind = N_DisjList; } DisjList()
  | LOOKAHEAD( /* <BAND> | */ <AND> ) {kind = N_ConjList; } ConjList()
  )
  { BStack.popReference(); 
    SyntaxTreeNode sn[] = getLastHeirs();
    epa(); return new SyntaxTreeNode( mn, kind, sn); }
}

void
DisjList() : {
  SyntaxTreeNode tn;
} {
  tn = JuncItem( N_DisjItem) {
    addHeir(tn); }
  ( LOOKAHEAD( { BStack.onReference( getToken(1).endColumn, getToken(1).kind ) })
    tn = JuncItem( N_DisjItem) { addHeir(tn); }
  )*
}

void
ConjList() : {
  SyntaxTreeNode tn;
} {
  tn = JuncItem( N_ConjItem) {
    addHeir( tn );}
  ( LOOKAHEAD( { BStack.onReference( getToken(1).endColumn, getToken(1).kind ) })
    tn = JuncItem( N_ConjItem) { addHeir( tn ); }
  )*
}


SyntaxTreeNode
JuncItem( int itemKind ) : {
  SyntaxTreeNode zn[] = new SyntaxTreeNode[2];
  SyntaxTreeNode tn;
  Token t;
  bpa("Junction Item");
} {
  ( /* t = <BOR> | */ t = <OR> | t = <AND> /* | t = <BAND> */ 
  ) {
    zn[0] = new SyntaxTreeNode(mn, t); }
  zn[1] = Expression()
  { epa(); 
    /***********************************************************************
    * Check for indentation errors.                                        *
    ***********************************************************************/
    tn = new SyntaxTreeNode( mn, itemKind, zn ); 
    TreeNode[] children = tn.heirs() ;
    for (int i = 1; i < children.length; i++) {
      checkIndentation((SyntaxTreeNode) children[i], tn) ;
     };
    return tn ;}
}

SyntaxTreeNode
UnboundOrBoundChoose() : {
  SyntaxTreeNode zn[] = new SyntaxTreeNode[5];
  SyntaxTreeNode tn;
  Token t;
  bpa("(Un)Bounded Choose");
} {
  t = <CHOOSE> { zn[0] = new SyntaxTreeNode(mn, t); }
  ( zn[1] = Identifier()
  | zn[1] = IdentifierTuple() )
  zn[2] = MaybeBound()
  t = <COLON> { zn[3] = new SyntaxTreeNode(mn, t); }
  zn[4] = Expression()
  { SyntaxTreeNode sn[] = getLastHeirs();
    epa(); return new SyntaxTreeNode( mn, N_UnboundOrBoundChoose, zn); }
}


/***************************************************************************
* Lambda expression added by LL on 27 March 2007                           *
*                                                                          *
* L.Lambda ::=                                                             *
*   <LAMBDA>                                                               *
*   (IdentDecl | SomeFixDecl) (<COMMA> (IdentDecl | SomeFixDecl))*         *
*   <COLON> Expression                                                     *
***************************************************************************/
SyntaxTreeNode
Lambda() : {
  SyntaxTreeNode tn;
  Token t;
  bpa("Lambda");
} { t = <LAMBDA> { addHeir(new SyntaxTreeNode(mn, t));
                   expecting = "Identifier"; }
     tn = Identifier() { addHeir( tn );
                                                 expecting = "`,' or `:'"; }
    ( t = <COMMA>  { addHeir( new SyntaxTreeNode(mn, t) );
                     expecting = "Identifier"; }
        ( tn = Identifier() ) {addHeir( tn );
                               expecting = "`,' or `:'"; }
    )*
    t = <COLON> { addHeir( new SyntaxTreeNode(mn, t) );
                  expecting = "Expression"; }
    tn = Expression() {addHeir(tn);
                       SyntaxTreeNode sn[] = getLastHeirs();
                       epa(); 
                       return new SyntaxTreeNode( mn, N_Lambda, sn); }
   }



// boxDisc (riminate) uses preInEmptyTop
// note that junction is processed separately.

SyntaxTreeNode
Expression() : {
  SyntaxTreeNode tn, tn0, tn1, tn2;
  int kind ;
  Token t;
  bpa("Expression");
  OperatorStack.newStack();
} {
( LOOKAHEAD( PrefixOpToken() | <op_77> /* "-" */,
             {BStack.aboveReference( getToken(1).beginColumn)})
  (  tn = PrefixOp() {kind = N_GenPrefixOp;}
   | tn = InfixOp()  {kind = N_GenInfixOp;}
       /********************************************************************
       * Existing code in the stack handling routine will figure out that  *
       * this is a prefix "-".                                             *
       ********************************************************************/
  )    
   { SyntaxTreeNode[] heirs = new SyntaxTreeNode[2];
     heirs[0] = new SyntaxTreeNode( mn, N_IdPrefix, (SyntaxTreeNode []) null);
     heirs[1] = tn ;
     OperatorStack.pushOnStack(new SyntaxTreeNode(mn, kind, heirs), lastOp);
     if (OperatorStack.size() != 1) {OperatorStack.reduceStack();} ;
          /*****************************************************************
          * This is probably a no-op since we can't reduce the stack at    *
          * this point.                                                    *
          *****************************************************************/
   }       
)*
( LOOKAHEAD(OpenStart(), {BStack.aboveReference( getToken(1).beginColumn)})
  tn = OpenExpression() { OperatorStack.pushOnStack( tn, null ); }
| LOOKAHEAD( {BStack.aboveReference( getToken(1).beginColumn)} )
  ExtendableExpr() // { OperatorStack.pushOnStack( tn, null ); }
    /*********************************************************************
    * ExtendableExpr() pushes stuff on the stack.                        *
    *********************************************************************/
)   

{ epa();
  tn = OperatorStack.finalReduce();
   if (tn==null) {
     throw new ParseException(" Couldn't reduce expression stack.");
    } ;
   OperatorStack.popStack();
   return tn ;
}
} // Expression

void   // it pushes stuff on the stack.
ExtendableExpr() : {
  SyntaxTreeNode tn, tn0, tn1, tn2;
  SyntaxTreeNode[] heirs;
  int kind ;
  Token t;
  bpa("ExtendableExpr") ;
}{
 ( /************************************************************************
   * Junction                                                              *
   ************************************************************************/
   LOOKAHEAD( /* <BAND> | <BOR> | */
            <AND> | <OR>, 
         {   OperatorStack.preInEmptyTop() 
           // && BStack.aboveReference( getToken(1).beginColumn) 
         } )
   tn = Junctions() { OperatorStack.pushOnStack( tn, null ); }
  |
   /************************************************************************
   * ParenthesesExpression                                                 *
   ************************************************************************/
   tn = ParenthesesExpression() { OperatorStack.pushOnStack( tn, null ); }
  |
   /************************************************************************
   * PrimitiveExpression                                                 *
   ************************************************************************/
   tn = PrimitiveExp() { OperatorStack.pushOnStack( tn, null ); }
)
(  LOOKAHEAD (PostfixOp(), {BStack.aboveReference( getToken(1).beginColumn)} )
   tn = PostfixOp()
     { heirs = new SyntaxTreeNode[2];
       heirs[0] = 
         new SyntaxTreeNode( mn, N_IdPrefix, (SyntaxTreeNode []) null);
       heirs[1] = tn ;
       OperatorStack.pushOnStack(new SyntaxTreeNode(mn, N_GenPostfixOp, heirs),
                                 lastOp);
       if (OperatorStack.size() != 1) {OperatorStack.reduceStack();} ;
   }
 | LOOKAHEAD(<DOT>, {BStack.aboveReference( getToken(1).beginColumn)})
   t = <DOT> 
     { Token next = getToken(1);
       if (isFieldNameToken( next )) next.kind = IDENTIFIER;
     }
   LOOKAHEAD({BStack.aboveReference( getToken(1).beginColumn)})
   tn = Identifier()
       { OperatorStack.reduceRecord(  new SyntaxTreeNode(mn, t) , tn ); }
 | LOOKAHEAD(<LSB>, {BStack.aboveReference( getToken(1).beginColumn)})
     /**********************************************************************
     * Next token is "[", so this must be function application.            *
     **********************************************************************/
   {expecting = "function argument";}
   tn = SBracketCases()
    { if ( isGenOp( tn ) ) {
        /*******************************************************************
        * In the normal case, tn will be an N_FcnAppl node and             *
        * isGenOp(tn) will be true.  In an error case, isGenOp(tn) should  *
        * be false, and whatever is returned will presumably not be an     *
        * operator and pushing it on the stack will produce an error       *
        * because the stack will have two expressions with no intervening  *
        * infix operator.                                                  *
        *******************************************************************/
        OperatorStack.pushOnStack( tn, lastOp );
        if (OperatorStack.size() != 1) {OperatorStack.reduceStack();} ;
       } 
      else {OperatorStack.pushOnStack( tn, null );};
    }
)*   

( LOOKAHEAD ( InfixOp(), {BStack.aboveReference( getToken(1).beginColumn)} )
  tn = InfixOp() 
   { heirs = new SyntaxTreeNode[2];
     heirs[0] = new SyntaxTreeNode( mn, N_IdPrefix, (SyntaxTreeNode []) null);
     heirs[1] = tn ;
     OperatorStack.pushOnStack(new SyntaxTreeNode(mn, N_GenInfixOp, heirs), 
                               lastOp);
     if (OperatorStack.size() != 1) {OperatorStack.reduceStack();} ;
   }
  ( LOOKAHEAD( PrefixOpToken() | <op_77> /* "-" */,
             {BStack.aboveReference( getToken(1).beginColumn)})
    (  tn = PrefixOp() {kind = N_GenPrefixOp;}
     | tn = InfixOp()  {kind = N_GenInfixOp;}
         /********************************************************************
         * Existing code in the stack handling routine will figure out that  *
         * this is a prefix "-".                                             *
         ********************************************************************/
    )    
    { heirs = new SyntaxTreeNode[2];
      heirs[0] = new SyntaxTreeNode( mn, N_IdPrefix, (SyntaxTreeNode []) null);
      heirs[1] = tn ;
      OperatorStack.pushOnStack(new SyntaxTreeNode(mn, kind, heirs), lastOp);
      if (OperatorStack.size() != 1) {OperatorStack.reduceStack();} ;
          /*****************************************************************
          * This is probably a no-op since we can't reduce the stack at    *
          * this point.                                                    *
          *****************************************************************/
    }       
  )*
  ( LOOKAHEAD(OpenStart(), {BStack.aboveReference( getToken(1).beginColumn)})
    tn = OpenExpression() { OperatorStack.pushOnStack( tn, null ); }
  | LOOKAHEAD( {BStack.aboveReference( getToken(1).beginColumn)} )
    ExtendableExpr() // { OperatorStack.pushOnStack( tn, null ); }
      /*********************************************************************
      * ExtendableExpr() pushes stuff on the stack.                        *
      *********************************************************************/
  )   

| LOOKAHEAD(<COLONCOLON>, {BStack.aboveReference( getToken(1).beginColumn)})
  t = <COLONCOLON> 
   { tn1 = new SyntaxTreeNode(mn, t) ;
     tn0 = OperatorStack.topOfStack().getNode();
     if (! isLabel(tn0)) {
       throw new ParseException("`::' at " + tn1.getLocation().toString()
                                 + " does not follow a label.") ;
      } ;
     OperatorStack.popCurrentTop() ;
   } // t = <COLONCOLON>
  tn2 = Expression() 
    { if (! labelDoesNotChangeParse(tn2, lastOp)) {
        /*****************************************************************
        * Note: if tn1 is a prefix, infix, or postfix expression, then   *
        * I believe (perhaps naively) that lastOp will be its operator.  *
        *****************************************************************/
        throw new ParseException(
          "Removing label at " + tn0.getLocation().toString() +
          " would change expression parsing.") ;
       } ;
      SyntaxTreeNode labelHeirs[] = {tn0, tn1, tn2} ;
      tn = new SyntaxTreeNode(N_Label, labelHeirs) ;
      OperatorStack.pushOnStack( tn, null );
     }
)?

 { epa() ; }
} // ExtendableExpr

SyntaxTreeNode
PrimitiveExp() : {
  SyntaxTreeNode tn, tn0, tn1, tn2;
  SyntaxTreeNode tnOpArgs = null ;
  SyntaxTreeNode tnBangs[] = null ;
  SyntaxTreeNode[] heirs ;
  Token t;
  bpa("Primitive expression") ;
} {
(  LOOKAHEAD (String(), {BStack.aboveReference( getToken(1).beginColumn)})
   tn = String() 
 | LOOKAHEAD (<NUMBER_LITERAL>, 
               {BStack.aboveReference( getToken(1).beginColumn)})
   tn = Number() 
 | ( ( ( tn0 = Identifier() 
        | (t = <ProofStepLexeme> | t = <ProofImplicitStepLexeme>)
                { tn0 = new SyntaxTreeNode(mn, t); 
                  if ((getProofLevel() < 0) && (proofDepth <= 0)) {
                    throw new 
                      ParseException(tn0.getLocation().toString() + 
                           ": Step number used outside proof.");
                    } ;
                  if (t.image.substring(1,2).equals("+")) {
                    throw new ParseException(tn0.getLocation().toString() + 
                           ": <+> step number used in an expression.");
                    } ;
                  if (t.kind == ProofImplicitStepLexeme) {
                    tn0.originalImage = tn0.image ;
                    tn0.image = correctedStepNum(t) ;
                   } ;
                  
// ToolIO.out.println("xyz-expr: t.image = " + t.image + 
// ", correctedImage = " + tn0.image) ;
                                                                 }
        | tn0 = InfixOp()
        | tn0 = PostfixOp()
        | LOOKAHEAD(<op_76>)
          tn0 = NonExpPrefixOp()
       )
       ( LOOKAHEAD(2)
         tnOpArgs = OpArgs() )?
     )
       /********************************************************************
       * Get the BangExt items, adding them to the stack of heirs.         *
       ********************************************************************/
       ( tn1 = BangExt() {addHeir(tn1) ;}
       )*

      { tnBangs = getLastHeirs() ;
        if (tnBangs == null) {
          heirs = new SyntaxTreeNode[2];
          heirs[0] = new SyntaxTreeNode( mn, N_IdPrefix, 
                                         new SyntaxTreeNode[0]);
          heirs[1] = tn0;
          tn1 = new SyntaxTreeNode(mn, N_GeneralId, heirs) ;
          if (tnOpArgs == null) {tn = tn1;}
          else { heirs    = new SyntaxTreeNode[2];
                 heirs[0] = tn1 ;
                 heirs[1] = tnOpArgs ;
                 tn = new SyntaxTreeNode(mn, N_OpApplication, heirs) ;
           }
         } // if (tnBangs == null)
        else { 
         /******************************************************************
         * There is a BangExt.  The parse tree constructed so far needs    *
         * to be rearranged to be what is expected of the parser           *
         * (because the parser was designed for TLA+1).  For example, if   *
         * we're parsing                                                   *
         *                                                                 *
         *   foo(1)!b!c(2,3), so far we have                               *
         *   tn0 = foo                                                     *
         *   tnOpArgs = OpArgs[1]                                          *
         *   tnBangs = IdPrefixElement[! b]                                *
         *             IdPrefixElement[! c OpArgs[2, 3]]                   *
         *                                                                 *
         * and we must turn that into                                      *
         *                                                                 *
         *   OpAppl[ GeneralId[ IdPrefix[IdPrefixElement[foo OpArgs[1] !]  *
         *                               IdPrefixElement[b !]]             *
         *                      c]                                         *
         *           OpArgs[2, 3]]                                         *
         *                                                                 *
         * Note that the result is an OpAppl node iff the last             *
         * IdPrefixElement contains an OpArg heir, otherwise it is a       *
         * GeneralId node.                                                 *
         ******************************************************************/

         /******************************************************************
         * We set heirs to the array of IdPrefixElement nodes that are     *
         * the heirs of the IdPrefix node that is the first heir of the    *
         * GeneralId node.                                                 *
         ******************************************************************/
         heirs = new SyntaxTreeNode[tnBangs.length] ;

         /******************************************************************
         * Set eltHeirs to the heirs of heirs[0].                          *
         ******************************************************************/
         SyntaxTreeNode[] eltHeirs;
         if (tnOpArgs == null) {
            eltHeirs = new SyntaxTreeNode[2] ;
            eltHeirs[0] = tn0 ;
            eltHeirs[1] = (SyntaxTreeNode) tnBangs[0].heirs()[0] ;
          }
         else {
            eltHeirs = new SyntaxTreeNode[3] ;
            eltHeirs[0] = tn0 ;
            eltHeirs[1] = tnOpArgs;
            eltHeirs[2] = (SyntaxTreeNode) tnBangs[0].heirs()[0] ;
          } ;
         heirs[0] = 
           new SyntaxTreeNode(mn, N_IdPrefixElement, eltHeirs);
         for (int i = 0; i < tnBangs.length - 1; i++) {
           eltHeirs = 
              new SyntaxTreeNode[tnBangs[i].heirs().length] ;           
           for (int j = 0 ; j < eltHeirs.length-1; j++) {
             eltHeirs[j] = (SyntaxTreeNode) tnBangs[i].heirs()[j+1];
             } ;
           eltHeirs[eltHeirs.length-1] = (SyntaxTreeNode) 
                                            tnBangs[i+1].heirs()[0];
           heirs[i+1] = new SyntaxTreeNode(mn, N_IdPrefixElement, eltHeirs);
          } // for
         TreeNode[] lastBang = tnBangs[tnBangs.length-1].heirs() ;
         SyntaxTreeNode[] genIdHeirs = new SyntaxTreeNode[2] ;
         genIdHeirs[0] = new SyntaxTreeNode(mn, N_IdPrefix, heirs) ;
         genIdHeirs[1] = (SyntaxTreeNode) lastBang[1];
         SyntaxTreeNode genId = 
             new SyntaxTreeNode(mn, N_GeneralId, genIdHeirs) ;
         if (lastBang.length == 2) {tn = genId;}
         else { heirs = new SyntaxTreeNode[2] ;
                heirs[0] = genId ;
                heirs[1] = (SyntaxTreeNode) lastBang[2] ;
                tn = new SyntaxTreeNode(mn, N_OpApplication, heirs) ;
          } // else       
      }	// else
     }
   )
)
 {  epa() ;
    return tn;
 }
} // PrimitiveExp


SyntaxTreeNode
BangExt() : {
  /*************************************************************************
  * Returns an N_IdPrefixElement node with 2 or 3 heirs consisting of:     *
  *  - A "!" (<BANG>) token.                                               *
  *  - An Identifier(), PrefixOp(), InfixOp(), or PostfixOp() node.        *
  *  - An optional OpArgs() node.                                          *
  * Note that this is not the kind of N_IdPrefixElement that the parser    *
  * ultimately produces, which ends with a "!" rather than beginning with  *
  * one.                                                                   *
  *************************************************************************/
  SyntaxTreeNode tn ;
  Token t;
  bpa("Bang Extension") ;
}{ t = <BANG> { addHeir(new SyntaxTreeNode(mn, t)) ; }
   ( (   LOOKAHEAD(Identifier() , {!getToken(1).image.equals("@")})
         tn = Identifier()
       | tn = NonExpPrefixOp()
       | tn = InfixOp() 
          /*****************************************************************
          * Note: if \X is used as an operator, semantic analysis will     *
          * complain because it's a built-in operator that can't follow a  *
          * "!".                                                           *
          *****************************************************************/
       | tn = PostfixOp()
      )
     {addHeir(tn);}
     ( LOOKAHEAD(2)
       tn = OpArgs() {addHeir(tn) ;}
     )?
   | tn = OpArgs()   {addHeir(tn) ;}
   | tn = StructOp() {addHeir(tn) ;}
  )
  { tn = new SyntaxTreeNode(mn, N_IdPrefixElement, getLastHeirs());
    epa();
    return tn ;}
} // BangExt

SyntaxTreeNode
StructOp() : {
  SyntaxTreeNode tn = null ;
  Token t = null;
  bpa("StructOp");
  expecting = "`<<' , `>>' , `:' , `@' , or number" ;
 }{
 (t = <LAB> | t = <RAB> | t = <COLON> | tn = Number() |
  LOOKAHEAD( {getToken(1).image.equals("@")})
  t = <IDENTIFIER>
 )
 { epa() ;
   if (tn == null){return new SyntaxTreeNode(mn, N_StructOp, t) ; }
     else { if (tn.getKind() == N_Real) {
              throw new ParseException(
                         "Illegal structural term at " + 
                          tn.getLocation().toString());
             };
           SyntaxTreeNode[] heirs = new SyntaxTreeNode[1] ;
           heirs[0] = tn;
           return new SyntaxTreeNode(mn, N_StructOp, heirs) ; } ;
 }
}

// SyntaxTreeNode
// oldExpression() : {
//   /*************************************************************************
//   * The basic production is                                                *
//   *                                                                        *
//   *    Expression ::= (  OpenExpression                                    *
//   *                     | (Junctions                                       *
//   *                         | ClosedExpressionOrOp                         *
//   *                         | <DOT> Identifier                             *
//   *                         | <COLONCOLON> Expression                      *
//   *                        )+                                              *
//   *                        ( OpenExpression )?                             *
//   *                   )                                                    *
//   *************************************************************************/
//   SyntaxTreeNode tn, tn0, tn1, tn2;
//   Token t;
//   OperatorStack.newStack();
// } { 
// ( 
//  LOOKAHEAD(OpenStart(), {BStack.aboveReference( getToken(1).beginColumn) } )
//    tn = OpenExpression() { OperatorStack.pushOnStack( tn, null ); }
// |   (  LOOKAHEAD( /* <BAND> | <BOR> | */ <AND> | <OR>, 
// // ^^^ 
// // Warning 4 -- Eliminated in SANY2
//          { OperatorStack.preInEmptyTop() && 
//            BStack.aboveReference( getToken(1).beginColumn) } )
//        tn = Junctions() { OperatorStack.pushOnStack( tn, null ); }
//      | LOOKAHEAD( {    ClosedStart(getToken(1)) 
//                    && boxDisc()  
//                         /***************************************************
//                        * \equiv                                            *
//                        *   (token is "[]" => it's the temporal operator)   *
//                         ***************************************************/
//                    && BStack.aboveReference( 
//                                 getToken(1).beginColumn) })
//        tn = ClosedExpressionOrOp() {
//           anchor = tn; // XXX is this correct ? Why had it disappered ? 
//                        // This is the only place where anchor is set it seems.
//           /*****************************************************************
//           * If tn is an operator, push it on the stack and, if it's not    *
//           * the only thing on the stack, then reduce the stack.            *
//           * Otherwise, just push it on the stack.                          *
//           *****************************************************************/
//           if ( isGenOp( tn ) ) {
//             OperatorStack.pushOnStack( tn, lastOp );
//             if (OperatorStack.size() != 1)
//               OperatorStack.reduceStack();
// // else
// // ToolIO.out.println("size of 1");
//           } else OperatorStack.pushOnStack( tn, null );
//         }
//      | 
//        t = <DOT> { 
//         Token next = getToken(1);
//         if (isFieldNameToken( next )) next.kind = IDENTIFIER;
//        }
//        tn = Identifier()
//        { OperatorStack.reduceRecord(  new SyntaxTreeNode(mn, t) , tn ); }
//      |
//        t = <COLONCOLON> {
//         tn1 = new SyntaxTreeNode(mn, t) ;
//         tn0 = OperatorStack.topOfStack().getNode();
//         if (! isLabel(tn0)) {
//           throw new ParseException("`::' at " + tn1.getLocation().toString()
//                                     + " does not follow a label.") ;
//          } ;
//         OperatorStack.popCurrentTop() ;
//        } // t = <COLONCOLON>
//        tn2 = Expression() {
// // String str = "null" ;
// // if (lastOp != null) { str = lastOp.toString(); } ;
// // ToolIO.out.println("lastOp after parsing labeled expression is: " + str);
//         if (! labelDoesNotChangeParse(tn2, lastOp)) {
//           /*****************************************************************
//           * Note: if tn1 is a prefix, infix, or postfix expression, then   *
//           * I believe (perhaps naively) that lastOp will be its operator.  *
//           *****************************************************************/
//           throw new ParseException(
//              "Removing label at " + tn0.getLocation().toString() +
//              " would change expression parsing.") ;
//           } ;
//         SyntaxTreeNode labelHeirs[] = {tn0, tn1, tn2} ;
//         tn = new SyntaxTreeNode(N_Label, labelHeirs) ;
//         OperatorStack.pushOnStack( tn, null );
//       }
//   )+
//   [ LOOKAHEAD( OpenStart(), {BStack.aboveReference( getToken(1).beginColumn) } )
//     tn = OpenExpression() { OperatorStack.pushOnStack( tn, null ); } ]
// )
//  { tn = OperatorStack.finalReduce();
//    if (tn==null) throw new ParseException( " Couldn't reduce expression stack.");
//    OperatorStack.popStack();
//    return tn; }
// } // Expression()

/* Obsolete
void
ClosedStart() : {
}{
  <IDENTIFIER> | <STRING_LITERAL> | <NUMBER_LITERAL> | <LBR> | <LSB> | <LAB> | <LBC> | <LWB> | <OpSymbol> | <OR> | <AND> | <WF> | <SF>
}
*/

void
OpenStart() : {
}{
  <CASE> | <CHOOSE> | <EXISTS> | <FORALL> | <IF> | <LET> | <T_EXISTS> | <T_FORALL> 
}

/***************************************************************************
* JavaCC WARNINGS                                                          *
* ---------------                                                          *
* The following is an explanation of all warnings issued by javacc.        *
***************************************************************************/

/* Warnings
Warning removed:

  Choice conflict in [...] construct at line 1886, column 3.
  Expansion nested within construct and expansion following construct
  have common prefixes, one of which is: "\\in"
  Consider using a lookahead of 2 or more for nested expansion.

This is in 

  MaybeBound() ::= [<IN> ... ]

because in

   ASSUME CONSTANT X [\in ...]
          Expression

there's ambiguity because Expression() allows an expression to begin
with an operator like \in.  (If the expression really begins with an
infix operator, that error will be discovered when trying to reduce
the stack.)  The grammar defined by this file therefore allows

   ASSUME CONSTANT X \in S

to be parsed as ASSUME CONSTANT x followed by the expression "\in S",
which extra-grammatical testing will declare to be an error.

This could be fixed by complicating the production Expression() not to
allow expressions that begin with an infix operator.  (This is
"easily" done because Expression() does not call itself directly.)
However, it's not necessary because this ambiguity is resolved the
correct way because MaybeBound() will return a non-empty value if it
can.  More precisely, if the input matches both foo and bar,
then [foo] bar will match foo, never bar.
-------------------
Warning 1: -- Eliminated in SANY2
         Choice conflict in [...] construct at line 2342 column 5.
         Expansion nested within construct and expansion following construct
         have common prefixes, one of which is: "("
         Consider using a lookahead of 2 or more for nested expansion.

In Extension() ::=   [.... | Identifier [ OpArgs()] ]
                                       ^^^
We think this is the ambiguity of

   THEOREM ASSUME A!B        vs.  THEOREM ASSUME A!B(C+D)     
                  (C+D)                   PROVE ...
           PROVE ...
------------------
Warning 2: -- Eliminated by LOOKAHEAD
   Choice conflict in [...] construct at line 2852, column 5.
   Expansion nested within construct and expansion following construct
   have common prefixes, one of which is: "("
   Consider using a lookahead of 2 or more for nested expansion.

In NoOpExtension() ::= Identifier [OpArgs] ...
                                 ^^^

Seems to be finding the ambiguity in

    WF_B(Action)  versus WF_B(A)(Action)

The parser is doing the right thing.  We believe that 

   - For WF_B(Act), it puts WF_ , B, and (Act) on the stack
   
   - For WF_B(A)(Act), it puts WF_ , B, (A), and (Act) on the stack

When the stack is reduced, the right thing happens.

-----------
-- Eliminated in SANY2
Warning 3: Choice conflict in [...] construct at line 2916 column 3.
         Expansion nested within construct and expansion following construct
         have common prefixes, one of which is: "("
         Consider using a lookahead of 2 or more for nested expansion.

This is similar to Warning 2, apparently caused by the javacc grammar
allowing something like "(a) (b)", which is flagged as an error when
the expression stack is popped.  However, it could be reporting
it in some other case--perhaps Op(b).

------------
-- Eliminated in SANY2
Warning 4: 
         Choice conflict in (...)+ construct at line 3142, column 3.
         Expansion nested within construct and expansion following construct
         have common prefixes, one of which is: "."

In Expression().  Caused by confict between "1./\ ..." and "1.2".
Should be eliminated when "1./\" is eliminated.


------------
-- Eliminated by LOOKAHEAD
Warning 5:
  Choice conflict in [...] construct at line 2501, column 4.
  Expansion nested within construct and expansion following construct
  have common prefixes, one of which is: "PROOF"
  Consider using a lookahead of 2 or more for nested expansion.

JavaCC thinks that there is a conflict between

   PROOF HIDE ...  which begins a new non-terminal proof.

and

   PROOF BY ...  which is a terminal proof.

I believe that this is the result of using UseOrHideOrBy to handle
both USE/HIDE and BY, but that the semantic lookahead sorts it out
properly.

***/
