<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- This is file org.lamport.tla.toobox.doc/html/prover/prover.html -->
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
 <LINK href="../style.css" rel="stylesheet" type="text/css">

    <title>The Decompose Proof Command</title>
</head>
<!-- a comment -->

<body>


<h1>The Decompose Proof Command</h1>

The Decompose Proof command is executed by placing the cursor in a proof obligation, either a proof step or
a theorem, and either typing <code>Ctl+G&nbsp;Ctl+D</code> or right-clicking and selecting
the command.&nbsp;  Clicking on the button labeled &nbsp;<font size=+1><b>?</b></font>&nbsp; in the upper right corner of the command's
pop-up window displays this page.

<p>
The command provides two basic ways to decompose a proof obligation
into simpler obligations:
<DL> <DT> <b><code>/\</code> decomposition</b> </DT>
<DD>If formula &nbsp;<code>P</code>&nbsp; equals 
   &nbsp;<code>P1 /\ ... /\ Pn</code>&nbsp;,
then the proof of &nbsp;<code>P</code>&nbsp; can be broken into the
proof of the &nbsp;<code>n</code>&nbsp; formulas 
  &nbsp;<code>P1, ... , Pn</code>&nbsp;.
</DD>

<BR> </BR>
 <DT><b><code>\/</code> decomposition &nbsp; (case split) </b>
 </DT>
<DD> 
If formula &nbsp;<code>P</code>&nbsp; equals 
   &nbsp;<code>P1&nbsp;\/ ... \/&nbsp;Pn</code>&nbsp;,
then the proof of &nbsp;<code>ASSUME&nbsp;P&nbsp;PROVE&nbsp;Q</code>&nbsp;
can be broken into the
proof of the &nbsp;<code>n</code>&nbsp; obligations
  &nbsp;<code>ASSUME&nbsp;P1&nbsp;PROVE&nbsp;Q,&nbsp;...,&nbsp;ASSUME&nbsp;Pn&nbsp;PROVE&nbsp;Q</code>&nbsp;
   (or the equivalent <code>CASE</code> steps).
</DD>
</DL>
</p>

<p>

Often, a proof obligation must be transformed into a different one in order to be decomposed into simpler
obligations, where the decomposition may be done manually or by the Decompose Proof command.&nbsp;  The command
provides the following two such transformations that can be
applied to the goal of an obligation.  The goal is the <code>PROVE</code> formula of an <code>ASSUME</code>/<code>PROVE</code>
obligation or the entire obligation, if it is a single formula.  For a <code>CASE</code> or <code>QED</code> step, it is the 
proof's current goal.

<DL> <DT> <b><code>=></code> splitting</b> </DT>
<DD>A goal &nbsp;<code>P => Q</code>&nbsp; is transformed to the assumption &nbsp;<code>P</code>&nbsp;
and the goal &nbsp;<code>Q</code>&nbsp;.
</DD>

<BR> </BR>
 <DT><b><code>\A</code> splitting</b>
 </DT>
<DD>A goal &nbsp;<code>\A x \in S : P</code>&nbsp; is transformed to the assumption &nbsp;<code>NEW&nbsp;x&nbsp;\in&nbsp;S</code>&nbsp;
and the goal &nbsp;<code>P</code>&nbsp;.&nbsp;  The goal &nbsp;<code>\A x&nbsp;:&nbsp;P</code>&nbsp; is similarly split.

</DD>
</DL>

There are two such transformations that can be applied to an assumption of an <code>ASSUME</code>/<code>PROVE</code> obligation:


<BR> </BR>
<DL> <DT><b><code>\E</code> splitting</b>
 </DT>
<DD>An assumption &nbsp;<code>\E x \in S : P</code>&nbsp; is transformed to the two assumptions 
 &nbsp;<code>NEW&nbsp;x&nbsp;\in&nbsp;S,&nbsp;P</code>&nbsp;.

</DD>

<BR> </BR>

<DT> <b><code>/\</code> splitting</b> </DT>
<DD>An assumption &nbsp;<code>P1 /\ ... /\ Pn</code>&nbsp;, is transformed to the &nbsp;<code>n</code>&nbsp; assumptions
&nbsp;<code>P1,&nbsp;...,&nbsp;Pn</code>&nbsp;.&nbsp;  This transformation can be performed by the Decompose Proof command only
if at least one of the conjuncts <code>Pi</code> can be further decomposed by the command.   
</DD>

</DL>


These transformations (decompositions and splittings) are effected by clicking on the appropriately labeled buttons.&nbsp;  
You can perform multiple transformations  before generating the proof.&nbsp; The <code>\/</code> 
decomposition and <code>\E</code>
splitting transformations can be combined hierarchically.&nbsp;  Clicking on the &nbsp;<font size=+1>&larr;</font>&nbsp; button undoes 
the last transformation that has not been undone.
</P>

<p>
The proof is generated by clicking a button that is either labeled by <font size=+1><b>P</b></font> or (for an <code>/\</code>
decomposition) by a button with <font size=+1><b>P</b></font> next to it.&nbsp;
</p>

<p>
Instead of generating an <code>/\</code> or <code>\/</code> decomposition, the button labeled <font size=+1><b>P</b></font>
at the top of the command's dialog window generates a proof consisting of only a 
  &nbsp;<code>SUFFICES&nbsp;ASSUME&nbsp;...&nbsp;PROVE</code>&nbsp;
step, constructed by splitting the original obligation, and a &nbsp;<code>QED</code>&nbsp; step.

For example, starting from the obligation &nbsp;<code>P&nbsp;=>&nbsp;\A&nbsp;x&nbsp;\in&nbsp;S&nbsp;:&nbsp;Q</code>&nbsp;, performing
a &nbsp;<code>=></code>&nbsp; split followed by a &nbsp;<code>\A</code> split on the goal and then clicking on this
button produces a proof like this:
<pre>
   <3> SUFFICES ASSUME P, NEW x \in S
                PROVE  Q
     OBVIOUS
   <3> QED
</pre>
</p>

<p>  The obligation to which you apply the Decompose Proof command must have either no proof or else a 
leaf proof, such as a &nbsp;<code>BY</code>&nbsp; proof or the proof &nbsp;<code>OBVIOUS</code>&nbsp;.&nbsp;  If it has a leaf proof, that proof
is made the proof of each of the simpler obligations into which the proof is decomposed.&nbsp;  For a proof generated by
the top  <font size=+1><b>P</b></font> button (which does no decomposing), the obligation's leaf proof becomes the 
<code>QED</code> step's proof.
</p>

<p>
You can use the command to transform the goal and/or usable assumptions that come  from the 
statement's <code>ASSUME</code> formulas and/or
from previous statements.&nbsp;  The formula to be transformed must either have  the appropriate form
or else consist of a single occurrence of a user-defined operator whose definition has that form.&nbsp;  

The command displays
only  assumptions that can be transformed and new assumptions that have been created so far 
by the current use of the command--the latter being
displayed below a dashed line.
</p>

<h2>Options</h2>

There are three options that you can select.

<DL> <DT> <b>Show Context</b> </DT>
<DD>A context assumption is a usable assumption that comes from the theorem or from a previous step.&nbsp;  Context
assumptions are displayed (and can thus be transformed) if and only if this option is chosen.
</DD>

<BR></BR>
<DT> <b>Use <code>SUFFICES</code></b> </DT>
<DD>Splitting the goal or a <code>\E</code> assumption generates new assumptions.&nbsp;
Selecting this option causes those assumptions to be asserted by a 
  &nbsp;<code>SUFFICES&nbsp;ASSUME/PROVE</code>&nbsp;
step.&nbsp;  Otherwise, these assumptions are added to each step of the decomposed proof to which they apply.&nbsp;
</DD>

<BR> </BR>
 <DT><b>Use <code>CASE</code></b>
 </DT>
<DD>This selection determines whether, in the created substeps of the proof of an <code>\/</code>
decomposition, <code>CASE</code> steps should be used instead of <code>ASSUME/PROVE</code>
steps when possible.&nbsp;  
</DD>

<!-- COMMENT
<BR> </BR>
 <DT><b>Use subexpression names</b>
 </DT>
<DD>The command looks at the expansions of definitions when looking for splittings and decompositions.&nbsp;
For example, you can do an <code>/\</code> decomposition if the goal is    &nbsp;<code>P</code>&nbsp;, where
&nbsp;<code>P</code>&nbsp; is defined to equal a conjunction of formulas.&nbsp;  Normally, this decomposition
will produce steps that prove each of the conjuncts as they appear in the definition of &nbsp;<code>P</code>&nbsp;.
However, if you select this option, the generated steps will contain the goals &nbsp;<code>P!1,&nbsp;P!2,&nbsp;...</code>&nbsp;.
</DD>
END COMMENT -->
</DL>

<h2>Limitations</h2>

The following are the known problems and limitations of the command.
<ul>

<li> The command will not expand definitions that are imported into the current module by parametrized instantiation--that
is, via a statement such as.
<pre>      Foo(x) == INSTANCE M WITH ... 
</pre>
</li>


<li> Decomposing a proof step may require renaming of bound identifiers
to avoid name clashes.&nbsp; This renaming is not done for clashes with identifiers
introduced by a <code>LET</code> definition within the step or by an expression in an argument
of a user-defined operator whose definition is being expanded.&nbsp; 
This failure to avoid name clashes will cause parsing
errors in the decomposed proof that must be fixed by hand.

</li>
</ul>
<hr>
<a href = "reading.html">&uarr; Viewing and Editing Structured Proofs</a>
</hr>

</body>
</html>