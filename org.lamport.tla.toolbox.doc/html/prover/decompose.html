<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- This is file org.lamport.tla.toobox.doc/html/prover/prover.html -->
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
 <LINK href="../style.css" rel="stylesheet" type="text/css">

    <title>The Decompose Proof Command</title>
</head>
<!-- a comment -->

<body>


<h1>The Decompose Proof Command</h1>

The Decompose Proof command is executed by placing the cursor in a proof obligation, either a proof step or
a theorem, and either typing <code>Ctl+G&nbsp;Ctl+D</code> or right-clicking and selecting
the command.

<p>
There are two basic ways to decompose a proof obligation
into simpler obligtions:
<DL> <DT> <b><code>/\</code> decomposition</b> </DT>
<DD>If &nbsp;<code>P</code>&nbsp; equals 
   &nbsp;<code>P1 /\ ... /\ Pn</code>&nbsp;,
then the proof of &nbsp;<code>P</code>&nbsp; can be broken into the
proof of the &nbsp;<code>n</code>&nbsp; formulas 
  &nbsp;<code>P1, ... , Pn</code>&nbsp;.
</DD>

<BR> </BR>
 <DT><b><code>\/</code> decomposition &nbsp; (case split) </b>
 </DT>
<DD> 
If &nbsp;<code>P</code>&nbsp; equals 
   &nbsp;<code>P1&nbsp;\/ ... \/&nbsp;Pn</code>&nbsp;,
then the proof of &nbsp;<code>ASSUME&nbsp;P&nbsp;PROVE&nbsp;Q</code>&nbsp;
can be broken into the
proof of the &nbsp;<code>n</code>&nbsp; obligations
  &nbsp;<code>ASSUME&nbsp;P1&nbsp;PROVE&nbsp;Q,&nbsp;...,&nbsp;ASSUME&nbsp;Pn&nbsp;PROVE&nbsp;Q</code>&nbsp;.
</DD>
</DL>
</p>

<p>
Often, a proof obligation must be transformed into an equivalent one in order to be decomposed
by <code>/\</code> or <code>\/</code> decomposition.  There are two transformations that can be
applied to the goal of an obligation.  (The goal is the <code>PROVE</code> formula of an <code>ASSUME</code>/<code>PROVE</code>
obligation or the entire obligation, if it is a single formula.)

<DL> <DT> <b><code>=></code> splitting</b> </DT>
<DD>A goal &nbsp;<code>P => Q</code>&nbsp; is equivalent to the assumption &nbsp;<code>P</code>&nbsp;
and the goal &nbsp;<code>Q</code>&nbsp;.
</DD>

<BR> </BR>
 <DT><b><code>\A</code> splitting</b>
 </DT>
<DD>A goal &nbsp;<code>\A x \in S : P</code>&nbsp; is equivalent to the assumption &nbsp;<code>NEW&nbsp;x&nbsp;\in&nbsp;S</code>&nbsp;
and the goal &nbsp;<code>P</code>&nbsp;.&nbsp;  The goal &nbsp;<code>\A x&nbsp;:&nbsp;P</code>&nbsp; is similarly split.

</DD>
</DL>

There are two transformations that can be applied to an assumption of an <code>ASSUME</code>/<code>PROVE</code> obligation:

<DL> <DT> <b><code>/\</code> splitting</b> </DT>
<DD>An assumption &nbsp;<code>P1 /\ ... /\ Pn</code>&nbsp;, is equivalent to the &nbsp;<code>n</code>&nbsp; assumptions
&nbsp;P1,&nbsp;...,&nbsp;Pn</code>&nbsp;.
</DD>

<BR> </BR>
 <DT><b><code>\E</code> splitting</b>
 </DT>
<DD>An assumption &nbsp;<code>\E x \in S : P</code>&nbsp; is equivalent to the two assumptions 
 &nbsp;<code>NEW&nbsp;x&nbsp;\in&nbsp;S,&nbsp;P</code>&nbsp;.

The goal &nbsp;<code>\E x&nbsp;:&nbsp;P</code>&nbsp; is similarly split.
</DD>
</DL>

These splittings are effected by clicking on the appropriately labeled buttons.&nbsp;  (<code>\/</code> and <code>\E</code>
splittings can be combined hierarchically.)&nbsp;
</P>

<p>
The proof is generated by clicking a button that is either labeled by <font size=+1><b>P</b></font> or (for an <code>/\</code>
decomposition) by a button with <font size=+1><b>P</b></font> next to it.&nbsp;
</p>

<p>
Instead of generating an <code>/\</code> or <code>\/</code> decomposition, the button labeled <font size=+1><b>P</b></font>
at the top of the command's dialog window generates a proof consisting of only a 
  &nbsp;<code>SUFFICES&nbsp;ASSUME&nbsp;...&nbsp;PROVE</code>&nbsp;
step constructed by splitting the original obligation and a &nbsp;<code>QED</code>&nbsp; step.

For example, starting from the obligation &nbsp;<code>P&nbsp;=>&nbsp;\E&nbsp;x&nbsp;\in&nbsp;S&nbsp;:&nbsp;Q</code>, performing
a &nbsp;<code>=></code>&nbsp; split followed by a &nbsp;<code>\A</code> split on the goal and then clicking on this
button produces a proof like this:
<pre>
   <3> SUFFICES ASSUME P, NEW x \in S
                PROVE  Q
     OBVIOUS
   <3> QED
</pre>
</p>

<p>  The obligation to which you apply the Decompose Proof command must have either no proof or else a 
leaf proof, such as a <code>BY</code> proof or the proof <code>OBVIOUS</code>).&nbsp;  If it has a leaf proof, that proof
is made the proof of each of the simpler obligations into which the proof is decomposed.&nbsp;  For a proof generated by
the top  <font size=+1><b>P</b></font> button (which does no decomposing), the obligation's leaf proof becomes the 
<code>QED</code> step's proof.
</p>

<h2>Options</h2>

There are two options that you can select.

<DL> <DT> <b>Use <code>SUFFICES</code></b> </DT>
<DD>Splitting the goal or a <code>\E</code> assumption generates new assumptions.&nbsp;
Selecting this option causes those assumptions to be asserted by a 
  &nbsp;<code>SUFFICES&nbsp;ASSUME/PROVE</code>&nbsp;
step.&nbsp;  Otherwise, these assumption are added to each of the decomposed proof steps.&nbsp;
</DD>

<BR> </BR>
 <DT><b>Use <code>CASE</code></b>
 </DT>
<DD>This selection determines whether, in the created substeps of the proof of an <code>\/</code>
decomposition, <code>CASE</code> steps should be used instead of <code>ASSUME/PROVE</code>
steps when possible.&nbsp;  One reason not to choose this option is that
the Decompose Command does not decompose <code>CASE</code> steps.
</DD>

<!-- COMMENT
<BR> </BR>
 <DT><b>Use subexpression names</b>
 </DT>
<DD>The command looks at the expansions of definitions when looking for splittings and decompositions.&nbsp;
For example, you can do an <code>/\</code> decomposition if the goal is    &nbsp;<code>P</code>&nbsp;, where
&nbsp;<code>P</code>&nbsp; is defined to equal a conjunction of formulas.&nbsp;  Normally, this decomposition
will produce steps that prove each of the conjuncts as they appear in the definition of &nbsp;<code>P</code>&nbsp;.
However, if you select this option, the generated steps will contain the goals &nbsp;<code>P!1,&nbsp;P!2,&nbsp;...</code>&nbsp;.
</DD>
END COMMENT -->
</DL>

<h2>Limitations</h2>

The following are the known problems and limitations of the command.
<ul>

<li> The command will not expand definitions that come from a different module.
</li>

<BR></BR>

<li> Decomposing a proof step may require renaming of bound identifiers
to avoid name clashes.&nbsp; This renaming is not done for clashes with names
defined by <code>LET</code> definitions within the step.&nbsp; This can cause parsing
errors in the decomposed proof.

</li>
</ul>
<hr>
<a href = "reading.html">&uarr; Viewing and Editing Structured Proofs</a>
</hr>

</body>
</html>